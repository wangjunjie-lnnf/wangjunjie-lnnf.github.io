---
layout: post
title:  "jvm之gc算法"
date:   2023-03-27 09:22:07 +0000
categories: jekyll
tags: jvm gc
---

# gc

## gc相关参数

```c++

jint Threads::create_vm(JavaVMInitArgs* args, ...)
{
    Arguments::parse(args);
    {
        parse_vm_init_args(args);
        {
            parse_each_vm_init_arg(args, &scp, ...);
            {
                // 打印gc信息
                if (match_option(option, "-verbose", &tail)) {
                    if (!strcmp(tail, ":gc")) {
                        FLAG_SET_CMDLINE(bool, PrintGC, true);
                    }
                } else if (match_option(option, "-Xnoclassgc", &tail)) {
                    // 默认回收class
                    FLAG_SET_CMDLINE(bool, ClassUnloading, false);
                } else if (match_option(option, "-Xmn", &tail)) {
                    FLAG_SET_CMDLINE(uintx, MaxNewSize, ...);
                    FLAG_SET_CMDLINE(uintx, NewSize, ...);
                } else if (match_option(option, "-Xms", &tail)) {
                    FLAG_SET_CMDLINE(uintx, InitialHeapSize, ...);
                } else if (match_option(option, "-Xmx", &tail) || match_option(option, "-XX:MaxHeapSize=", &tail)) {
                    FLAG_SET_CMDLINE(uintx, MaxHeapSize, ...);
                } else if (match_option(option, "-Xss", &tail)) {
                    FLAG_SET_CMDLINE(intx, ThreadStackSize, ...);
                } else if (match_option(option, "-Xloggc:", &tail)) {
                    // 打印gc信息到指定文件
                    _gc_log_filename = strdup(tail);
                    FLAG_SET_CMDLINE(bool, PrintGC, true);
                    FLAG_SET_CMDLINE(bool, PrintGCTimeStamps, true);
                }
            }
        }
    }

    Arguments::apply_ergo();
    {
        set_ergonomics_flags();
        {
            select_gc();
            {
                if (!gc_selected()) {
                    // 设置默认gc
                    select_gc_ergonomically();
                    {
                        // 配置超过2核2G视为server
                        if (os::is_server_class_machine()) {
                            if (should_auto_select_low_pause_collector()) {
                                // 设置了cms相关参数
                                FLAG_SET_ERGO(bool, UseConcMarkSweepGC, true);
                            } else {
                                // 默认UseParallelGC
                                FLAG_SET_ERGO(bool, UseParallelGC, true);
                            }
                        }
                    }
                }
            }
        }

        set_heap_size();
        {
            julong phys_mem = MIN2(os::physical_memory(), (julong)MaxRAM);

            // MaxHeapSize默认96M
            // InitialHeapSize默认0

            // 下文中的参数全部使用默认值
            if (FLAG_IS_DEFAULT(MaxHeapSize)) {
                julong reasonable_max = (julong)((phys_mem * 25) / 100);
                const julong reasonable_min = (julong)((phys_mem * 50) / 100);

                if (reasonable_min < MaxHeapSize) {
                    reasonable_max = reasonable_min;
                } else {
                    reasonable_max = MAX2(reasonable_max, (julong)MaxHeapSize);
                }

                if (!FLAG_IS_DEFAULT(InitialHeapSize)) {
                    reasonable_max = MAX2(reasonable_max, (julong)InitialHeapSize);
                }

                // max(物理内存/4, 96M)
                FLAG_SET_ERGO(uintx, MaxHeapSize, (uintx)reasonable_max);
            }

            if (InitialHeapSize == 0 || min_heap_size() == 0) {
                // 默认OldSize=4M
                // 默认NewSize=1M
                julong reasonable_minimum = (julong)(OldSize + NewSize);
                reasonable_minimum = MIN2(reasonable_minimum, (julong)MaxHeapSize);

                julong reasonable_initial = (julong)((phys_mem * 1.5625) / 100);

                reasonable_initial = MAX3(reasonable_initial, reasonable_minimum, (julong)min_heap_size());
                reasonable_initial = MIN2(reasonable_initial, (julong)MaxHeapSize);

                // min(phys_mem * 1.5625%, MaxHeapSize)
                FLAG_SET_ERGO(uintx, InitialHeapSize, (uintx)reasonable_initial);
            }
        }
    }

    init_globals();
    {
        universe_init();
        {
            Universe::initialize_heap();
            {
                if (UseParallelGC) {
                    Universe::_collectedHeap = new ParallelScavengeHeap();
                } else if (UseG1GC) {
                    G1CollectorPolicyExt* g1p = new G1CollectorPolicyExt();
                    g1p->initialize_all();
                    Universe::_collectedHeap = new G1CollectedHeap(g1p);
                } else {
                    // 忽略UseSerialGC和UseConcMarkSweepGC
                    if (UseSerialGC) {
                        gc_policy = new MarkSweepPolicy();
                    } else if (UseConcMarkSweepGC) {

                    } else {
                        // 2核2G以下默认同UseSerialGC
                        gc_policy = new MarkSweepPolicy();
                    }

                    gc_policy->initialize_all();

                    Universe::_collectedHeap = new GenCollectedHeap(gc_policy);
                }

                // 初始化
                Universe::heap()->initialize();
            }
        }
    }
}

```

## CollectedHeap接口

```c++

class CollectedHeap {

    // 初始化
    virtual jint initialize() = 0;
    virtual void post_initialize() = 0;

    // 内存分配：核心接口，heap是为了分配内存而生
    virtual HeapWord* allocate_new_tlab(size_t size);
    virtual HeapWord* mem_allocate(size_t size, bool* gc_overhead_limit_was_exceeded) = 0;

    // 主动gc相关
    virtual void collect(GCCause::Cause cause) = 0;
    virtual void do_full_collection(bool clear_all_soft_refs) = 0;

    // heap枚举
    virtual void oop_iterate(ExtendedOopClosure* cl) = 0;
    virtual void object_iterate(ObjectClosure* cl) = 0;

    // 常用inline static工具方法
    inline static HeapWord* allocate_from_tlab(KlassHandle klass, Thread* thread, size_t size)
    {
        // 指针碰撞
        HeapWord* obj = thread->tlab().allocate(size);
        if (obj != NULL) {
            return obj;
        }

        return allocate_from_tlab_slow(klass, thread, size);
        {
            // tlab还剩很多，跳过tlab从heap里分配
            if (thread->tlab().free() > thread->tlab().refill_waste_limit()) {
                thread->tlab().record_slow_allocation(size);
                return NULL;
            }

            // 生成新的tlab并从tlab分配
            HeapWord* obj = Universe::heap()->allocate_new_tlab(new_tlab_size);
            thread->tlab().fill(obj, obj + size, new_tlab_size);
            return obj;
        }
    }

    inline static oop obj_allocate(KlassHandle klass, int size, TRAPS)
    {
        HeapWord* obj = common_mem_allocate_init(klass, size, CHECK_NULL);
        {
            // 为指定类的实例分配内存
            HeapWord* obj = common_mem_allocate_noinit(klass, size, CHECK_NULL);
            {
                // 先尝试tlab
                result = allocate_from_tlab(klass, THREAD, size);
                if (result != NULL) {
                    return result;
                }

                // 直接从heap里分配
                result = Universe::heap()->mem_allocate(size, &gc_overhead_limit_was_exceeded);
                if (result != NULL) {
                    return result;
                }

                if (!gc_overhead_limit_was_exceeded) {
                    // heap空间不足
                    report_java_out_of_memory("Java heap space");
                } else {
                    // 尝试了太多次
                    report_java_out_of_memory("GC overhead limit exceeded");
                }
            }

            init_obj(obj, size);
            {
                const size_t hs = oopDesc::header_size();
                // header之后用0填充
                Copy::fill_to_aligned_words(obj + hs, size - hs);
            }

            return obj;
        }

        post_allocation_setup_obj(klass, obj, size);
        {
            // 指定class初始化自己的实例
            post_allocation_setup_common(klass, obj_ptr);
            {
                post_allocation_setup_no_klass_install(klass, obj_ptr);
                {
                    oop obj = (oop)obj_ptr;
                    if (UseBiasedLocking && (klass() != NULL)) {
                        obj->set_mark(klass->prototype_header());
                    } else {
                        // 设置默认对象头
                        obj->set_mark(markOopDesc::prototype());
                    }
                }

                // 设置对象头中的class
                obj->release_set_klass(klass());
            }
        }

        return (oop)obj;
    }

    inline static oop array_allocate(KlassHandle klass, int size, int length, TRAPS)
    {
        HeapWord* obj = common_mem_allocate_init(klass, size, CHECK_NULL);
        post_allocation_setup_array(klass, obj, length);
        {
            post_allocation_setup_common(klass, obj_ptr);
        }

        return (oop)obj;
    }
}

class CollectorPolicy {

    virtual void initialize_alignments() = 0;
    virtual void initialize_flags();
    virtual void initialize_size_info();

    size_t _initial_heap_byte_size;
    size_t _max_heap_byte_size;
    size_t _min_heap_byte_size;

    size_t _space_alignment;
    size_t _heap_alignment;

    virtual void initialize_all() {
        initialize_alignments();
        initialize_flags();
        initialize_size_info();
    }

    virtual HeapWord* mem_allocate_work(size_t size,
                                        bool is_tlab,
                                        bool* gc_overhead_limit_was_exceeded) = 0;

}

```

## ParallelGC

### 初始化

初始化之后的heap的示意图，绿色表示已经申请了物理内存

![ps-heap](/assets/images/2023-03-27/ps-heap.png)

```c++

class ParallelScavengeHeap : public CollectedHeap {

    // 按默认行为
    jint ParallelScavengeHeap::initialize() {
        // 确定XxxNewSize、XxxOldSize、XxxHeapSize
        _collector_policy = new GenerationSizer();
        _collector_policy->initialize_all();
        {
            initialize_alignments();
            {
                // young和old之间的边界
                _space_alignment = _gen_alignment = 512 * K;

                // cardTable按page申请内存，cardTable的1字节标记heap的512字节
                _heap_alignment = compute_heap_alignment();
                {
                    return 512 * os::vm_page_size();
                }
            }

            initialize_flags();
            {
                TwoGenerationCollectorPolicy::initialize_flags();
                {
                    GenCollectorPolicy::initialize_flags();
                    {
                        CollectorPolicy::initialize_flags();
                        {
                            // InitialHeapSize和MaxHeapSize按_heap_alignment对齐
                            _min_heap_byte_size = align_size_up(_min_heap_byte_size, _heap_alignment);
                            FLAG_SET_ERGO(uintx, InitialHeapSize, align_size_up(InitialHeapSize, _heap_alignment));
                            FLAG_SET_ERGO(uintx, MaxHeapSize, align_size_up(MaxHeapSize, _heap_alignment));
                            _initial_heap_byte_size = InitialHeapSize;
                            _max_heap_byte_size = MaxHeapSize;
                        }

                        // 计算NewSize = max(NewSize, 3 * _space_alignment)

                        // 最小的young: eden + two survivors
                        uintx smallest_new_size = align_size_up(3 * _space_alignment, _gen_alignment);
                        // 最小的heap = smallest_new_size + old
                        uintx smallest_heap_size = align_size_up(smallest_new_size + _space_alignment, _heap_alignment);
                    
                        NewSize =  MAX2(smallest_new_size, (uintx)align_size_down(NewSize, _gen_alignment));
                        _initial_gen0_size = NewSize;
                    }

                    // 调节NewSize、OldSize、MaxHeapSize的关系
                    if (NewSize + OldSize > MaxHeapSize) {
                        if (_max_heap_size_cmdline) {
                            // 如果指定了MaxHeapSize则按比例减少NewSize和OldSize
                            uintx calculated_size = NewSize + OldSize;
                            double shrink_factor = (double) MaxHeapSize / calculated_size;
                            uintx smaller_new_size = align_size_down((uintx)(NewSize * shrink_factor), _gen_alignment);
                            FLAG_SET_ERGO(uintx, NewSize, MAX2(young_gen_size_lower_bound(), smaller_new_size));
                            FLAG_SET_ERGO(uintx, OldSize, MaxHeapSize - NewSize);
                        } else {
                            // 未指定MaxHeapSize则增加MaxHeapSize
                            FLAG_SET_ERGO(uintx, MaxHeapSize, align_size_up(NewSize + OldSize, _heap_alignment));
                            _max_heap_byte_size = MaxHeapSize;
                        }
                    }
                }                
            }

            initialize_size_info();
            {
                TwoGenerationCollectorPolicy::initialize_size_info();
                {
                    GenCollectorPolicy::initialize_size_info();
                    {
                        // 根据NewRatio和XxxHeapSize计算XxxNewSize
                        max_new_size = scale_by_NewRatio_aligned(_max_heap_byte_size);
                        _min_gen0_size = MAX2(scale_by_NewRatio_aligned(_min_heap_byte_size), NewSize);
                        desired_new_size = MAX2(scale_by_NewRatio_aligned(_initial_heap_byte_size), NewSize);
                    }

                    // 根据XxxNewSize和XxxHeapSize计算XxxOldSize
                    _max_gen1_size = MAX2(_max_heap_byte_size - _max_gen0_size, _gen_alignment);
                    _min_gen1_size = MAX2(_min_heap_byte_size - _min_gen0_size, _gen_alignment);
                    _initial_gen1_size = MAX2(_initial_heap_byte_size - _initial_gen0_size, _gen_alignment);
                    FLAG_SET_ERGO(uintx, OldSize, _initial_gen1_size);
                }
            }
        }

        // 使用mmap按MaxHeapSize申请线性地址空间
        const size_t heap_size = _collector_policy->max_heap_byte_size();
        ReservedSpace heap_rs = Universe::reserve_heap(heap_size, _collector_policy->heap_alignment());
        {
            // 默认不限制heap线性地址，选择UseCompressedOops时选择较大的base可以空出地址中较高的bit
            char* addr = Universe::preferred_heap_base(total_reserved, alignment, Universe::UnscaledNarrowOop);
            base = os::reserve_memory(size, NULL, alignment);
            {
                flags = MAP_PRIVATE | MAP_NORESERVE | MAP_ANONYMOUS;
                addr = (char*)::mmap(requested_addr, bytes, PROT_NONE, flags, ...);
            }
        }

        // 线性地址空间范围
        _reserved = MemRegion((HeapWord*)heap_rs.base(),
                              (HeapWord*)(heap_rs.base() + heap_rs.size()));

        // 创建cardTable: 覆盖2个region: young, old
        CardTableExtension* const barrier_set = new CardTableExtension(_reserved, 3);
        {
            _covered = new MemRegion[_max_covered_regions];
        }

        barrier_set->initialize();
        {
            // 每个card占1字节对应heap的512字节，计算需要的card数量
            _guard_index = cards_required(_whole_heap.word_size()) - 1;
            _last_valid_index = _guard_index - 1;

            // card按page取整
            _byte_map_size = compute_byte_map_size();

            // 使用mmap为cardTable申请线性地址
            ReservedSpace heap_rs(_byte_map_size, rs_align, false);

            _byte_map = (jbyte*) heap_rs.base();
            // 为方便计算byte_map_base表示从0开始card，实际[0, low_bound]之间是空的
            byte_map_base = _byte_map - (uintptr_t(low_bound) >> card_shift);

            // cardTable最后一个page
            byte* guard_card = &_byte_map[_guard_index];
            uintptr_t guard_page = align_size_down((uintptr_t)guard_card, _page_size);
            _guard_region = MemRegion((HeapWord*)guard_page, _page_size);
            // 为cardTable的最后一个page申请物理内存
            os::commit_memory_or_exit((char*)guard_page, _page_size, _page_size, ...);

            // 记录每个region的边界
            _lowest_non_clean = NEW_C_HEAP_ARRAY(CardArr, _max_covered_regions, mtGC);
            _lowest_non_clean_chunk_size = NEW_C_HEAP_ARRAY(size_t, _max_covered_regions, mtGC);
            _lowest_non_clean_base_chunk_index = NEW_C_HEAP_ARRAY(uintptr_t, _max_covered_regions, mtGC);
            _last_LNC_resizing_collection = NEW_C_HEAP_ARRAY(int, _max_covered_regions, mtGC);

            for (int i = 0; i < _max_covered_regions; i++) {
                _lowest_non_clean[i] = NULL;
                _lowest_non_clean_chunk_size[i] = 0;
                _last_LNC_resizing_collection[i] = -1;
            }
        }

        _barrier_set = barrier_set;
        oopDesc::set_bs(_barrier_set);

        // 把heap分成old和young两部分
        _gens = new AdjoiningGenerations(heap_rs, _collector_policy, generation_alignment());
        {
            _virtual_spaces(old_young_rs, policy->min_gen1_size(), policy->min_gen0_size(), alignment) {
            size_t init_low_byte_size = policy->initial_gen1_size();
            size_t min_low_byte_size = policy->min_gen1_size();
            size_t max_low_byte_size = policy->max_gen1_size();
            size_t init_high_byte_size = policy->initial_gen0_size();
            size_t min_high_byte_size = policy->min_gen0_size();
            size_t max_high_byte_size = policy->max_gen0_size();
            
            // 整个heap分成MaxOldSize和MaxNewSize两部分
            ReservedSpace old_rs = virtual_spaces()->reserved_space().first_part(max_low_byte_size);
            ReservedSpace heap_rs = virtual_spaces()->reserved_space().last_part(max_low_byte_size);
            ReservedSpace young_rs = heap_rs.first_part(max_high_byte_size);

            _young_gen = new PSYoungGen(init_high_byte_size,
                                        min_high_byte_size,
                                        max_high_byte_size);
            _old_gen = new PSOldGen(init_low_byte_size,
                                    min_low_byte_size,
                                    max_low_byte_size,
                                    "old", 1);

            _young_gen->initialize(young_rs, alignment);
            {
                initialize_virtual_space(rs, alignment);
                {
                    _virtual_space = new PSVirtualSpace(rs, alignment);
                    // 申请物理内存
                    virtual_space()->expand_by(_init_gen_size);
                }

                initialize_work();
                {
                    // 整个线性地址空间
                    _reserved = MemRegion((HeapWord*)virtual_space()->low_boundary(),
                                          (HeapWord*)virtual_space()->high_boundary());

                    // commited的线性地址空间
                    MemRegion cmr((HeapWord*)virtual_space()->low(),
                                  (HeapWord*)virtual_space()->high());
                    
                    // 为覆盖此区域的cardTable分配内存
                    Universe::heap()->barrier_set()->resize_covered_region(cmr);

                    _eden_space = new MutableSpace(virtual_space()->alignment());
                    _from_space = new MutableSpace(virtual_space()->alignment());
                    _to_space   = new MutableSpace(virtual_space()->alignment());

                    // 线性地址空间按比例计算eden和survivor的大小
                    max_survivor_size = size / InitialSurvivorRatio;
                    max_eden_size = size - 2 * max_survivor_size;

                    compute_initial_space_boundaries();
                    {
                        size_t size = virtual_space()->committed_size();


                        set_space_boundaries(eden_size, survivor_size);
                        {
                            // commited地址按eden/to/from的顺序排列
                            char *eden_start = virtual_space()->low();
                            char *to_start   = eden_start + eden_size;
                            char *from_start = to_start   + survivor_size;
                            char *from_end   = from_start + survivor_size;

                            MemRegion eden_mr((HeapWord*)eden_start, (HeapWord*)to_start);
                            MemRegion to_mr  ((HeapWord*)to_start, (HeapWord*)from_start);
                            MemRegion from_mr((HeapWord*)from_start, (HeapWord*)from_end);

                            eden_space()->initialize(eden_mr, true, ZapUnusedHeapArea);
                              to_space()->initialize(to_mr  , true, ZapUnusedHeapArea);
                            from_space()->initialize(from_mr, true, ZapUnusedHeapArea);
                        }
                    }
                }
            }

            _old_gen->initialize(old_rs, alignment, "old", 1);
            {
                initialize_virtual_space(rs, alignment);
                {
                    _virtual_space = new PSVirtualSpace(rs, alignment);
                    _virtual_space->expand_by(_init_gen_size);
                }

                initialize_work(perf_data_name, level);
                {
                    // 整个线性地址空间
                    MemRegion limit_reserved((HeapWord*)virtual_space()->low_boundary(), heap_word_size(_max_gen_size));
                    // 稀疏索引记录对象相对于block的offset: ((char*)obj_ptr - (char*)block_start) / 8
                    start_array()->initialize(limit_reserved);

                    // 已经commited的线性地址
                    MemRegion cmr((HeapWord*)virtual_space()->low(),
                                  (HeapWord*)virtual_space()->high());

                    // 为对应的cardTable申请内存
                    Universe::heap()->barrier_set()->resize_covered_region(cmr);

                    // 储存对象
                    _object_space = new MutableSpace(virtual_space()->alignment());
                    object_space()->initialize(cmr, ...);

                    start_array()->set_covered_region(cmr);
                }
            }
        }

        _old_gen = _gens->old_gen();
        _young_gen = _gens->young_gen();

        // 根据暂停时间收集信息动态调整heap的大小
        _size_policy = new PSAdaptiveSizePolicy(eden_capacity, initial_promo_size, ...);

        // 创建用于gc的线程池
        _gc_task_manager = GCTaskManager::create(ParallelGCThreads);
        {
            initialize();
            {
                // 创建任务队列
                GCTaskQueue* unsynchronized_queue = GCTaskQueue::create_on_c_heap();
                _queue = SynchronizedGCTaskQueue::create(unsynchronized_queue, lock());

                // 创建线程池
                _thread = NEW_C_HEAP_ARRAY(GCTaskThread*, workers(), mtGC);
                for (uint t = 0; t < workers(); t += 1) {
                    set_thread(t, GCTaskThread::create(this, t, processor_assignment[t]));
                }
            }
        }

        // 并行整理gc算法初始化
        PSParallelCompact::initialize();
        {
            MemRegion mr = heap->reserved_region();

            _mark_bitmap.initialize(mr);
            {
                // 一个bit标记8个字节
                const idx_t bits = bits_required(covered_region);
                const size_t words = bits / BitsPerWord;
                const size_t raw_bytes = words * sizeof(idx_t);
                _reserved_byte_size = align_size_up(raw_bytes, MAX2(page_sz, granularity));
                // 申请线性地址
                ReservedSpace rs(_reserved_byte_size, rs_align, rs_align > 0);
                _virtual_space = new PSVirtualSpace(rs, page_sz);
                // 申请物理内存
                _virtual_space->expand_by(_reserved_byte_size);
            }

            _summary_data.initialize(mr);
            {
                const size_t region_size = covered_region.word_size();
                initialize_region_data(region_size);
                {
                    // 使用一个RegionData描述一个64k的region
                    const size_t count = (region_size + RegionSizeOffsetMask) >> Log2RegionSize;
                    _region_vspace = create_vspace(count, sizeof(RegionData));
                }

                initialize_block_data();
                {
                    // 使用一个BlockData描述一个128字节的block
                    const size_t count = _region_count << Log2BlocksPerRegion;
                    _block_vspace = create_vspace(count, sizeof(BlockData));
                }
            }
        }
    }

    void ParallelScavengeHeap::post_initialize() {
        PSScavenge::initialize();
        if (UseParallelOldGC) {
            PSParallelCompact::post_initialize();
        } else {
            PSMarkSweep::initialize();
        }
        PSPromotionManager::initialize();
    }
}

```

### 内存分配

分配`tlab`

```c
HeapWord* ParallelScavengeHeap::allocate_new_tlab(size_t size) {
  return young_gen()->allocate(size);
  {
    return eden_space()->cas_allocate(word_size);
    {
        // 基于cas的指针碰撞从eden分配
        do {
            HeapWord* obj = (HeapWord*)OrderAccess::load_ptr_acquire(top_addr());
            if (pointer_delta(end(), obj) >= size) {
                HeapWord* new_top = obj + size;
                HeapWord* result = (HeapWord*)Atomic::cmpxchg_ptr(new_top, top_addr(), obj);
                if (result != obj) {
                    continue;
                }
                return obj;
            } else {
                return NULL;
            }
        } while (true);
    }
  }
}
```

从heap中分配

```c
HeapWord* ParallelScavengeHeap::mem_allocate(size_t size,
                                             bool* gc_overhead_limit_was_exceeded) {
    *gc_overhead_limit_was_exceeded = false;

    HeapWord* result = young_gen()->allocate(size);                                            
}
```


### gc

## G1GC

### 初始化

```c++

```