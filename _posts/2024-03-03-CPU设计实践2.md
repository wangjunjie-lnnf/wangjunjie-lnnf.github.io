---
layout: post
title:  "CPU设计实践2"
date:   2024-03-03 23:49:07 +0000
categories: jekyll
tags: hardware
---

# CPU设计实践2

此版本是使用HLS实现的riscv-32指令集

## 非流水线

每个周期完成一条指令的处理过程，包含`取值、译码、执行、访存、回写`

### 顶层模块

```c
typedef struct decoded_instruction_s {
  opcode_t    opcode;
  reg_num_t   rd;
  func3_t     func3;
  reg_num_t   rs1;
  reg_num_t   rs2;
  func7_t     func7;
  type_t      type;
  immediate_t imm;
  bit_t       is_load;
  bit_t       is_store;
  bit_t       is_branch;
  bit_t       is_jalr;
  bit_t       is_op_imm;
  bit_t       is_lui;
  bit_t       is_ret;
  bit_t       is_r_type;
} decoded_instruction_t;

typedef struct decoded_immediate_s {
  bit_t       inst_31;
  ap_uint<6>  inst_30_25;
  ap_uint<4>  inst_24_21;
  bit_t       inst_20;
  ap_uint<8>  inst_19_12;
  ap_uint<4>  inst_11_8;
  bit_t       inst_7;
} decoded_immediate_t;

static void running_cond_update(
  instruction_t  instruction,
  code_address_t pc,
  bit_t         *is_running) {  
  *is_running = (instruction != RET || pc != 0);
}

static void statistic_update(
  unsigned int *nbi) {
  *nbi = *nbi + 1;
}

// cpu核
void rv32i_npp_ip(
  unsigned int  start_pc,
  unsigned int  code_ram[CODE_RAM_SIZE],
  int           data_ram[DATA_RAM_SIZE],
  unsigned int *nb_instruction) {
  // 端口定义
#pragma HLS INTERFACE s_axilite port=start_pc
#pragma HLS INTERFACE s_axilite port=code_ram
#pragma HLS INTERFACE s_axilite port=data_ram
#pragma HLS INTERFACE s_axilite port=nb_instruction
#pragma HLS INTERFACE s_axilite port=return
#pragma HLS INLINE recursive

  // 状态
  code_address_t        pc;

  int                   reg_file[NB_REGISTER];
#pragma HLS ARRAY_PARTITION variable=reg_file dim=1 complete

  instruction_t         instruction;
  bit_t                 is_running;
  unsigned int          nbi;
  decoded_instruction_t d_i;

  // reset
  for (int i=0; i<NB_REGISTER; i++) reg_file[i] = 0;
  pc  = start_pc;
  nbi = 0;

  // 循环一次表示一个时钟周期  
  do {
#pragma HLS PIPELINE II=7
    fetch(pc, code_ram, &instruction);
    decode(instruction, &d_i);
    // 执行/访存/回写/更新pc
    execute(pc, reg_file, data_ram, d_i, &pc);
    statistic_update(&nbi);
    running_cond_update(instruction, pc, &is_running);
  } while (is_running);

  *nb_instruction = nbi;
}

```

### 取指

```c

// 取指
void fetch(
  code_address_t pc,
  instruction_t *code_ram,
  instruction_t *instruction) {
  *instruction = code_ram[pc];
}

```

### 译码

```c

static void decode_instruction(
  instruction_t          instruction,
  decoded_instruction_t *d_i) {
  d_i->opcode     = (instruction >>  2);
  d_i->rd         = (instruction >>  7);
  d_i->func3      = (instruction >> 12);
  d_i->rs1        = (instruction >> 15);
  d_i->rs2        = (instruction >> 20);
  d_i->func7      = (instruction >> 25);
  d_i->is_load    = (d_i->opcode == LOAD);
  d_i->is_store   = (d_i->opcode == STORE);
  d_i->is_branch  = (d_i->opcode == BRANCH);
  d_i->is_jalr    = (d_i->opcode == JALR);
  d_i->is_ret     = (instruction == RET);
  d_i->is_lui     = (d_i->opcode == LUI);
  d_i->is_op_imm  = (d_i->opcode == OP_IMM);
  d_i->type       = type(d_i->opcode);
  d_i->is_r_type  = (d_i->type   == R_TYPE);
}

static void decode_immediate(
  instruction_t          instruction,
  decoded_instruction_t *d_i) {

  decoded_immediate_t d_imm;
  d_imm.inst_31    = (instruction >> 31);
  d_imm.inst_30_25 = (instruction >> 25);
  d_imm.inst_24_21 = (instruction >> 21);
  d_imm.inst_20    = (instruction >> 20);
  d_imm.inst_19_12 = (instruction >> 12);
  d_imm.inst_11_8  = (instruction >>  8);
  d_imm.inst_7     = (instruction >>  7);

  switch(d_i->type) {
    case UNDEFINED_TYPE: d_i->imm = 0; break;
    case R_TYPE:         d_i->imm = 0; break;
    case I_TYPE:         d_i->imm = i_immediate(d_imm); break;
    case S_TYPE:         d_i->imm = s_immediate(d_imm); break;
    case B_TYPE:         d_i->imm = b_immediate(d_imm); break;
    case U_TYPE:         d_i->imm = u_immediate(d_imm); break;
    case J_TYPE:         d_i->imm = j_immediate(d_imm); break;
    case OTHER_TYPE:     d_i->imm = 0; break;
  }
}

void decode(
  instruction_t          instruction,
  decoded_instruction_t *d_i) {
  decode_instruction(instruction, d_i);
  decode_immediate  (instruction, d_i);
}

```

### 执行

```c

static void read_reg(
  int      *reg_file,
  reg_num_t rs1,
  reg_num_t rs2,
  int      *rv1,
  int      *rv2) {
  *rv1 = reg_file[rs1];
  *rv2 = reg_file[rs2];
}

static void write_reg(
  int                  *reg_file,
  decoded_instruction_t d_i,
  int                   result) {
  if (d_i.rd != 0   &&
     !d_i.is_branch &&
     !d_i.is_store)
    reg_file[d_i.rd] = result;
}

static bit_t compute_branch_result(
  int     rv1,
  int     rv2,
  func3_t func3) {
  switch(func3){
    case BEQ : return (rv1 == rv2);
    case BNE : return (rv1 != rv2);
    case 2   :
    case 3   : return 0;
    case BLT : return (rv1 <  rv2);
    case BGE : return (rv1 >= rv2);
    case BLTU: return (unsigned int)rv1 <  (unsigned int)rv2;
    case BGEU: return (unsigned int)rv1 >= (unsigned int)rv2;
  }
  return 0;
}

static int compute_op_result(
  int                   rv1,
  int                   rv2,
  decoded_instruction_t d_i) {

  bit_t      f7_6 = d_i.func7>>5;
  ap_uint<5> shift;
  int        result;

  if (d_i.is_r_type)
    shift = rv2;
  else  // I_TYPE
    shift = d_i.rs2;

  switch(d_i.func3) {
    case ADD : if (d_i.is_r_type && f7_6)
                 result = rv1 - rv2;//SUB
               else
                 result = rv1 + rv2;
               break;
    case SLL : result = rv1 << shift;
               break;
    case SLT : result = rv1 < rv2;
               break;
    case SLTU: result = (unsigned int)rv1 < (unsigned int)rv2;
               break;
    case XOR : result = rv1 ^ rv2;
               break;
    case SRL : if (f7_6)
                 result = rv1 >> shift;//SRA
               else
                 result = (unsigned int)rv1 >> shift;
               break;
    case OR  : result = rv1 | rv2;
               break;
    case AND : result = rv1 & rv2;
               break;
  }
  return result;
}

static int compute_result(
  int                   rv1,
  int                   rv2,
  decoded_instruction_t d_i,
  code_address_t        pc) {

  int            imm12 = ((int)d_i.imm)<<12;
  code_address_t pc4   = pc<<2;
  code_address_t npc4  = pc4 + 4;
  int            result;

  switch(d_i.type) {
    case R_TYPE:
      result = compute_op_result(rv1, rv2, d_i);
      break;
    case I_TYPE:
      if (d_i.is_jalr)
        result = npc4;
      else if (d_i.is_load)
        result = rv1 + (int)d_i.imm;
      else if (d_i.is_op_imm)
        result = compute_op_result(rv1, (int)d_i.imm, d_i);
      else
        result = 0; // (d_i.opcode == SYSTEM)
      break;
    case S_TYPE:
      result = rv1 + (int)d_i.imm;
      break;
    case B_TYPE:
      result = (unsigned int)compute_branch_result(rv1, rv2, d_i.func3);
      break;
    case U_TYPE:
      if (d_i.is_lui)
        result = imm12;
      else  // d_i.opcode == AUIPC
        result = pc4 + imm12;
      break;
    case J_TYPE:
      result = npc4;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

static code_address_t compute_next_pc(
  code_address_t        pc,
  int                   rv1,
  decoded_instruction_t d_i,
  bit_t                 cond) {

  code_address_t next_pc;

  switch(d_i.type) {
    case R_TYPE:
      next_pc = (code_address_t)(pc+1);
      break;
    case I_TYPE:
      next_pc = (d_i.is_jalr) ? (code_address_t)((rv1 + ((int)d_i.imm)&0xfffffffe)>>2)
                              : (code_address_t)(pc+1);
      break;
    case S_TYPE:
      next_pc = (code_address_t)(pc+1);
      break;
    case B_TYPE:
      next_pc = (cond) ? (code_address_t)(pc+(d_i.imm>>1))
                       : (code_address_t)(pc+1);
      break;
    case U_TYPE:
      next_pc = (code_address_t)(pc+1);
      break;
    case J_TYPE:
      next_pc = (code_address_t)(pc+(d_i.imm>>1));
      break;
    default:
      next_pc = (code_address_t)(pc+1);
      break;
  }

  return next_pc;
}

static int mem_load(
  int             *data_ram,
  b_data_address_t address,
  func3_t          msize) {

  ap_uint<2>       a01 =  address;
  bit_t            a1  = (address >> 1);
  w_data_address_t a2  = (address >> 2);
  int              result;
  char             b, b0, b1, b2, b3;
  unsigned char    ub, ub0, ub1, ub2, ub3;
  short            h, h0, h1;
  unsigned short   uh, uh0, uh1;
  int              w, ib, ih;
  unsigned int     iub, iuh;

  w   = data_ram[a2];
  b0  = w;
  ub0 = b0;
  b1  = w>>8;
  ub1 = b1;
  h0  = ((ap_uint<16>)ub1<<8) | (ap_uint<16>)ub0;
  uh0 = h0;
  b2  = w>>16;
  ub2 = b2;
  b3  = w>>24;
  ub3 = b3;
  h1  = ((ap_uint<16>)ub3<<8) | (ap_uint<16>)ub2;
  uh1 = h1;

  switch(a01) {
    case 0b00: b = b0; break;
    case 0b01: b = b1; break;
    case 0b10: b = b2; break;
    case 0b11: b = b3; break;
  }

  ub  = b;
  ib  = (int)b;
  iub = (unsigned int)ub;
  h   = (a1)?h1:h0;
  uh  = h;
  ih  = (int)h;
  iuh = (unsigned int)uh;

  switch(msize) {
    case LB:
      result = ib;  break;
    case LH:
      result = ih;  break;
    case LW:
      result = w;   break;
    case 3:
      result = 0;   break;
    case LBU:
      result = iub; break;
    case LHU:
      result = iuh; break;
    case 6:
    case 7:
      result = 0;   break;
  }

  return result;
}

static void mem_store(
  int             *data_ram,
  b_data_address_t address,
  int              rv2,
  ap_uint<2>       msize) {

  h_data_address_t a1 = (address >> 1);
  w_data_address_t a2 = (address >> 2);
  char             rv2_0;
  short            rv2_01;
  rv2_0  = rv2;
  rv2_01 = rv2;

  switch(msize) {
    case SB:
      *((char*) (data_ram) + address) = rv2_0;
      break;
    case SH:
      *((short*)(data_ram) + a1)      = rv2_01;
      break;
    case SW:
      data_ram[a2]                    = rv2;
      break;
    case 3:
      break;
  }
}

void execute(
  code_address_t        pc,
  int                  *reg_file,
  int                  *data_ram,
  decoded_instruction_t d_i,
  code_address_t       *next_pc) {

  int              rv1, rv2, result;
  b_data_address_t address;

  // 读寄存器
  read_reg(reg_file, d_i.rs1, d_i.rs2, &rv1, &rv2);
  // 计算执行结果
  result  = compute_result(rv1, rv2, d_i, pc);

  // 读写内存  
  address = result;
  if (d_i.is_store)
    mem_store(data_ram, address, rv2, (ap_uint<2>)d_i.func3);
  if (d_i.is_load)
    result = mem_load(data_ram, address, d_i.func3);

  // 回写  
  write_reg(reg_file, d_i, result);
  
  // 更新pc
  *next_pc = compute_next_pc(pc, rv1, d_i, (bit_t)result);
}

```

### 测试

```c

#include <stdio.h>
#include "rv32i_npp_ip.h"

int          data_ram[DATA_RAM_SIZE];
unsigned int code_ram[CODE_RAM_SIZE] = {
#include "test_load_store_0_text.hex"
};

int main() {
  unsigned int nbi;
  int          w;

  rv32i_npp_ip(0, code_ram, data_ram, &nbi);

  printf("%d fetched and decoded instructions\n", nbi);

  printf("data memory dump (non null words)\n");

  for (int i=0; i<DATA_RAM_SIZE; i++){
    w = data_ram[i];
    if (w != 0)
      printf("m[%5x] = %16d (%8x)\n", 4*i, w, (unsigned int)w);
  }

  return 0;
}

```

### 总结

非流水线版本代码很简洁，一方面是rv32i指令集本身指令很少，另一方面HLS相对verilog表达能力很强


## 二阶段单周期流水线

![2s-pipeline](/assets/images/2024-03-03/2s-pipeline.png)

拆分成`取指-译码`和`执行-回写`两个阶段，每个阶段在一个逻辑周期内完成

![2s-inter-conn](/assets/images/2024-03-03/2s-inter-conn.png)

阶段之间传递数据，综合之后转为时序电路

```c

// 传递默认pc
typedef struct from_f_to_f_s {
  code_address_t next_pc;
} from_f_to_f_t;

// 译码阶段向执行阶段传递解析的指令
typedef struct from_f_to_e_s {
  code_address_t        pc;
  decoded_instruction_t d_i;
} from_f_to_e_t;

// 分支指令反向传递跳转信息
typedef struct from_e_to_f_s {
  code_address_t target_pc;
  bit_t          set_pc;
} from_e_to_f_t;

// 分支指令发生跳转时忽略已经完成译码并进入执行阶段的指令
typedef struct from_e_to_e_s {
  bit_t cancel;
} from_e_to_e_t;

```

### 顶层模块

```c

typedef struct decoded_instruction_s {
  // ...
} decoded_instruction_t;

typedef struct decoded_immediate_s {
  // ...
} decoded_immediate_t;

static void running_cond_update(
  bit_t  cancel,
  bit_t  is_ret,
  bit_t  target_pc,
  bit_t *is_running) {
  *is_running = (cancel || !is_ret || (target_pc!=0));
}

static void statistic_update(
  bit_t         cancel,
  unsigned int *nbi) {
  *nbi = *nbi + (int)(!cancel);
}

void simple_pipeline_ip(
  unsigned int  start_pc,
  unsigned int  code_ram[CODE_RAM_SIZE],
  int           data_ram[DATA_RAM_SIZE],
  unsigned int *nb_instruction) {
#pragma HLS INTERFACE s_axilite port=start_pc
#pragma HLS INTERFACE s_axilite port=code_ram
#pragma HLS INTERFACE s_axilite port=data_ram
#pragma HLS INTERFACE s_axilite port=nb_instruction
#pragma HLS INTERFACE s_axilite port=return
#pragma HLS INLINE recursive

  int            reg_file[NB_REGISTER];
#pragma HLS ARRAY_PARTITION variable=reg_file dim=1 complete

  from_f_to_f_t  f_to_f, f_from_f;
  from_f_to_e_t  f_to_e, e_from_f;
  from_e_to_f_t  e_to_f, f_from_e;
  from_e_to_e_t  e_to_e, e_from_e;
  bit_t          is_running;
  unsigned int   nbi;

  for (int i=0; i<NB_REGISTER; i++) reg_file[i] = 0;
  e_to_f.target_pc = start_pc;
  e_to_f.set_pc    = 1;
  e_to_e.cancel    = 1;
  nbi              = 0;

  do {
#pragma HLS PIPELINE II=5
    f_from_f = f_to_f; e_from_f = f_to_e;
    f_from_e = e_to_f; e_from_e = e_to_e;
    fetch_decode(f_from_f, f_from_e, code_ram, &f_to_f, &f_to_e);
    execute_wb(e_from_f, e_from_e, reg_file, data_ram, &e_to_f, &e_to_e);
    statistic_update(e_from_e.cancel, &nbi);
    running_cond_update(e_from_e.cancel, e_from_f.d_i.is_ret, e_to_f.target_pc, &is_running);
  } while (is_running);

  *nb_instruction = nbi;
}

```

### 取指-译码

```c

void fetch(
  code_address_t  pc,
  instruction_t  *code_ram,
  code_address_t *next_pc,
  instruction_t  *instruction) {
  *next_pc = (code_address_t)(pc + 1);
  *instruction = code_ram[pc];
}

void fetch_decode(
  from_f_to_f_t  f_from_f,
  from_e_to_f_t  f_from_e,
  unsigned int  *code_ram,
  from_f_to_f_t *f_to_f,
  from_f_to_e_t *f_to_e) {
  
  code_address_t pc;
  instruction_t  instruction;

  // 上一条分支指令发生跳转
  pc = (f_from_e.set_pc) ? f_from_e.target_pc : f_from_f.next_pc;

  fetch(pc, code_ram, &(f_to_f->next_pc), &instruction);
  decode(instruction, &(f_to_e->d_i));

  f_to_e->pc = pc;
}

```

### 执行-回写

```c

void execute_wb(
  from_f_to_e_t  e_from_f,
  from_e_to_e_t  e_from_e,
  int           *reg_file,
  int           *data_ram,
  from_e_to_f_t *e_to_f,
  from_e_to_e_t *e_to_e) {
  
  int   rv1, rv2, rs, op_result, result;
  bit_t bcond, taken_branch;

  // 上一条指令分支跳转导致当前指令无效
  if (e_from_e.cancel) {
    e_to_f->set_pc = 0;
    e_to_e->cancel = 0;
  } else {
    read_reg(reg_file, e_from_f.d_i.rs1, e_from_f.d_i.rs2, &rv1, &rv2);
    bcond        = compute_branch_result(rv1, rv2, e_from_f.d_i.func3);
    taken_branch = e_from_f.d_i.is_branch && bcond;
    rs           = (e_from_f.d_i.is_r_type) ? rv2 : (int)e_from_f.d_i.imm;
    op_result    = compute_op_result(e_from_f.d_i, rv1, rs);
    result       = compute_result(e_from_f.pc, e_from_f.d_i, rv1, op_result);

    if (e_from_f.d_i.is_store)
      mem_store(data_ram, (b_data_address_t)result, rv2, e_from_f.d_i.func3);
    else if (e_from_f.d_i.is_load)
      result = mem_load(data_ram, (b_data_address_t)result, e_from_f.d_i.func3);

    write_reg(e_from_f.d_i, reg_file, result);

    e_to_f->target_pc = compute_next_pc(e_from_f.pc, e_from_f.d_i, bcond, rv1);

    // 分支跳转
    e_to_f->set_pc    = e_from_f.d_i.is_jalr || e_from_f.d_i.is_jal || taken_branch;
    e_to_e->cancel    = e_to_f->set_pc;
  }
}

```

![2s-pipeline-cancel](/assets/images/2024-03-03/2s-pipeline-cancel.png)

遇到分支指令发生跳转时，已经完成取指-译码的指令是错误的，需要在执行阶段取消掉，然后在取指阶段重新从跳转之后的地址取指令


## 四阶段单周期流水线

![4s-pipeline](/assets/images/2024-03-03/4s-pipeline.png)

进一步拆分成4个周期: 取指-译码、执行、访存、回写

![4s-inter-conn](/assets/images/2024-03-03/4s-inter-conn.png)

阶段之间传递数据，综合之后转为时序电路

```c

typedef struct from_f_to_f_s {
  code_address_t next_pc;
} from_f_to_f_t;

typedef struct from_f_to_e_s {
  code_address_t        pc;
  decoded_instruction_t d_i;
} from_f_to_e_t;

typedef struct from_e_to_f_s {
  code_address_t target_pc;
  bit_t          set_pc;
} from_e_to_f_t;

typedef struct from_e_to_e_s {
  bit_t          cancel;
} from_e_to_e_t;

typedef struct from_e_to_m_s {
  bit_t                 cancel;
  int                   result;
  int                   rv2;
  decoded_instruction_t d_i;
} from_e_to_m_t;

typedef struct from_m_to_w_s {
  bit_t                 cancel;
  int                   result;
  reg_num_t             rd;
  // 是否ret指令
  bit_t                 is_ret;
  // 是否回写寄存器
  bit_t                 has_no_dest;
} from_m_to_w_t;

```

### 顶层模块

```c

typedef struct decoded_instruction_s {
  // ...
} decoded_instruction_t;

typedef struct decoded_immediate_s {
  // ...
} decoded_immediate_t;

static void running_cond_update(
  bit_t  cancel,
  bit_t  is_ret,
  int    ra,
  bit_t *is_running) {
  *is_running = (cancel || !is_ret || ra != 0);
}

static void statistic_update(
  bit_t         cancel,
  unsigned int *nbi,
  unsigned int *nbc) {
  *nbi = *nbi + (int)(!cancel);
  *nbc = *nbc + 1;
}

void rv32i_pp_ip(
  unsigned int  start_pc,
  unsigned int  code_ram[CODE_RAM_SIZE],
  int           data_ram[DATA_RAM_SIZE],
  unsigned int *nb_instruction,
  unsigned int *nb_cycle) {
#pragma HLS INTERFACE s_axilite port=start_pc
#pragma HLS INTERFACE s_axilite port=code_ram
#pragma HLS INTERFACE s_axilite port=data_ram
#pragma HLS INTERFACE s_axilite port=nb_instruction
#pragma HLS INTERFACE s_axilite port=nb_cycle
#pragma HLS INTERFACE s_axilite port=return
#pragma HLS INLINE recursive

  int            reg_file[NB_REGISTER];
#pragma HLS ARRAY_PARTITION variable=reg_file dim=1 complete

  // 在各个阶段之间传递数据
  from_f_to_f_t  f_to_f, f_from_f;
  from_f_to_e_t  f_to_e, e_from_f;
  from_e_to_f_t  e_to_f, f_from_e;
  from_e_to_e_t  e_to_e, e_from_e;
  from_e_to_m_t  e_to_m, m_from_e;
  from_m_to_w_t  m_to_w, w_from_m;

  bit_t          is_running;
  unsigned int   nbi;
  unsigned int   nbc;

  for (reg_num_p1_t i=0; i<NB_REGISTER; i++) reg_file[i] = 0;

  e_to_f.target_pc = start_pc;
  e_to_f.set_pc    = 1;
  e_to_e.cancel    = 1;
  e_to_m.cancel    = 1;
  m_to_w.cancel    = 1;
  nbi              = 0;
  nbc              = 0;

  do {
#pragma HLS PIPELINE II=3
    f_from_f = f_to_f; f_from_e = e_to_f; e_from_f = f_to_e;
    e_from_e = e_to_e; m_from_e = e_to_m; w_from_m = m_to_w;

    fetch_decode(f_from_f, f_from_e, code_ram, &f_to_f, &f_to_e);

    execute(f_to_e, e_from_f, e_from_e.cancel,
            m_from_e.cancel, m_from_e.d_i.has_no_dest,
            m_from_e.d_i.rd, m_from_e.result,
            w_from_m.cancel, w_from_m.has_no_dest,
            w_from_m.rd, w_from_m.result, reg_file,
           &e_to_f,  &e_to_e,  &e_to_m);
    
    mem_access(m_from_e, data_ram, &m_to_w);
    wb(w_from_m, reg_file);

    statistic_update(w_from_m.cancel, &nbi, &nbc);
    running_cond_update(w_from_m.cancel, w_from_m.is_ret, w_from_m.result, &is_running);
  } while (is_running);

  *nb_cycle       = nbc;
  *nb_instruction = nbi;
}

```

### 取指-译码

```c

void fetch_decode(
  from_f_to_f_t  f_from_f,
  from_e_to_f_t  f_from_e,
  unsigned int  *code_ram,
  from_f_to_f_t *f_to_f,
  from_f_to_e_t *f_to_e) {
  // ...
}

```

### 执行

![4s-load-dependent](/assets/images/2024-03-03/4s-load-dependent.png)

如果当前指令和上一条load指令有数据依赖，当前指令处在执行阶段读寄存器时，load阶段处于访存阶段，当前指令必须取消执行然后重新取指译码等待load指令到达回写阶段才能回传最新的数据

![4s-bypass](/assets/images/2024-03-03/4s-bypass.png)

流水线拆分的阶段越多，数据依赖的链路越长，采取的策略是暂停流水线直到依赖的数据可以回传

```c

// 数据反向前推以解决Read-After-Write数据依赖问题
static int bypass(
  bit_t     m_bp,
  int       mem_result,
  int       wb_result) {
  if (m_bp) return mem_result;
  else      return wb_result;
}

static void get_source(
  int           r1,
  int           r2,
  from_f_to_e_t e_from_f,
  bit_t         m_cancel,
  bit_t         m_has_no_dest,
  reg_num_t     m_rd,
  int           m_result,
  bit_t         w_cancel,
  bit_t         w_has_no_dest,
  reg_num_t     w_rd,
  int           w_result,
  int          *rv1,
  int          *rv2) {

  bit_t     m_bp_1, m_bp_2, w_bp_1, w_bp_2;
  bit_t     bypass_rs1, bypass_rs2;
  reg_num_t rs1, rs2;

  rs1 = e_from_f.d_i.rs1;
  rs2 = e_from_f.d_i.rs2;

  // 操作数寄存器和访存阶段写入的寄存器相同
  m_bp_1 = (!m_cancel && !m_has_no_dest &&
            rs1!=0    && rs1==m_rd);
  // 操作数寄存器和回写阶段写入的寄存器相同
  w_bp_1 = (!w_cancel && !w_has_no_dest &&
            rs1!=0    && rs1==w_rd);
  bypass_rs1 = m_bp_1 || w_bp_1;

  m_bp_2 = (!m_cancel && !m_has_no_dest &&
            rs2!=0    && rs2==m_rd);
  w_bp_2 = (!w_cancel && !w_has_no_dest &&
            rs2!=0    && rs2==w_rd);
  bypass_rs2 = m_bp_2 || w_bp_2;

  // 数据前递解决Read-After-Write数据依赖
  *rv1 = (bypass_rs1) ? bypass(m_bp_1, m_result, w_result) : r1;
  *rv2 = (bypass_rs2) ? bypass(m_bp_2, m_result, w_result) : r2;
}

void execute(
  from_f_to_e_t  f_to_e,
  from_f_to_e_t  e_from_f,
  bit_t          e_cancel,
  bit_t          m_cancel,
  bit_t          m_has_no_dest,
  reg_num_t      m_rd,
  int            m_result,
  bit_t          w_cancel,
  bit_t          w_has_no_dest,
  reg_num_t      w_rd,
  int            w_result,
  int           *reg_file,
  from_e_to_f_t *e_to_f,
  from_e_to_e_t *e_to_e,
  from_e_to_m_t *e_to_m) {

  int       r1, r2, rv1, rv2, rs;
  int       c_op_result, c_result, result;
  reg_num_t rs1, rs2;
  bit_t     bcond, taken_branch, load_delay, is_rs1_reg, is_rs2_reg;
  opcode_t  opcode;

  rs1 = e_from_f.d_i.rs1;
  rs2 = e_from_f.d_i.rs2;
  r1  = read_reg(reg_file, rs1);
  r2  = read_reg(reg_file, rs2);

  // mux选择操作数
  get_source(r1, r2,
             e_from_f,
             m_cancel,
             m_has_no_dest,
             m_rd,
             m_result,
             w_cancel,
             w_has_no_dest,
             w_rd,
             w_result,
            &rv1, &rv2);
  
  bcond = compute_branch_result(rv1, rv2, e_from_f.d_i.func3);
  taken_branch = e_from_f.d_i.is_branch && bcond;
  rs = (e_from_f.d_i.is_r_type) ? rv2 : (int)e_from_f.d_i.imm;
  c_op_result = compute_op_result(e_from_f.d_i, rv1, rs);
  c_result    = compute_result(e_from_f.pc, e_from_f.d_i, rv1);
  result      = (e_from_f.d_i.is_r_type || e_from_f.d_i.is_op_imm) ? c_op_result : c_result;

  e_to_f->target_pc = compute_next_pc(e_from_f.pc, e_from_f.d_i, rv1, bcond);

  opcode     = f_to_e.d_i.opcode;
  is_rs1_reg = ((opcode != JAL)    && (opcode != LUI)   &&
                (opcode != AUIPC)  && (f_to_e.d_i.rs1 != 0));
  is_rs2_reg = ((opcode != OP_IMM) && (opcode != LOAD)  &&
                (opcode != JAL)    && (opcode != JALR)  &&
                (opcode != LUI)    && (opcode != AUIPC) &&
                (f_to_e.d_i.rs2 != 0));

  // f_to_e处于译码阶段，e_from_f处于执行阶段
  // 如果上一个指令是load且当前指令与之有数据依赖
  // 则修改pc重新取指译码直到load指令到达回写阶段
  load_delay = !e_cancel  &&  e_from_f.d_i.is_load &&
             ((is_rs1_reg && (e_from_f.d_i.rd == f_to_e.d_i.rs1)) ||
              (is_rs2_reg && (e_from_f.d_i.rd == f_to_e.d_i.rs2)));
  if (load_delay) e_to_f->target_pc = e_from_f.pc + 1;

  e_to_f->set_pc = (e_from_f.d_i.is_jalr ||
                    e_from_f.d_i.is_jal  ||
                    taken_branch         ||
                    load_delay)          && !e_cancel;
  e_to_e->cancel      = e_to_f->set_pc;
  e_to_m->cancel      = e_cancel;
  e_to_m->result      =(e_from_f.d_i.is_ret) ? (int)e_to_f->target_pc : result;
  e_to_m->rv2         = rv2;
  e_to_m->d_i         = e_from_f.d_i;
}

```

### 访存

```c

static int mem_load(
  int             *data_ram,
  b_data_address_t address,
  func3_t          msize) {
  // ...
}

static void mem_store(
  int             *data_ram,
  b_data_address_t address,
  int              rv2,
  ap_uint<2>       msize) {
  // ...
}

void mem_access(
  from_e_to_m_t  m_from_e,
  int           *data_ram,
  from_m_to_w_t *m_to_w) {
  b_data_address_t address;
  address        = m_from_e.result;
  m_to_w->cancel = m_from_e.cancel;

  if (!m_from_e.cancel) {
    m_to_w->result = (m_from_e.d_i.is_load) ? mem_load(data_ram, address, m_from_e.d_i.func3)
                                            : m_from_e.result;
    if (m_from_e.d_i.is_store)
      mem_store(data_ram, address, m_from_e.rv2, (ap_uint<2>)m_from_e.d_i.func3);
  }

  m_to_w->rd          = m_from_e.d_i.rd;
  m_to_w->is_ret      = m_from_e.d_i.is_ret;
  m_to_w->has_no_dest = m_from_e.d_i.has_no_dest;
}

```

### 回写

```c

void wb(
  from_m_to_w_t  w_from_m,
  int           *reg_file) {
  if (!w_from_m.cancel) {
    if (!w_from_m.has_no_dest)
      reg_file[w_from_m.rd] = w_from_m.result;
  }
}

```


## 六阶段多周期流水线

划分成6个阶段：fetch, decode, issue, execute, memory access, and writeback  

![6s-wait](/assets/images/2024-03-03/6s-wait.png)

> In the multicycle pipeline organization, when an instruction must stay in the same stage for multiple cycles, it sends a wait signal to the preceding stages. Each stage receives some input (e.g. the stage y receives the structure x_to_y from the stage x), processes it and sends an output (e.g. the structure y_to_z is sent to the stage z). However, if the stage has a wait input signal, it stays frozen, which means that it does not change its output at all (it does not receive nor process its input and it keeps its output unchanged). A stage waits until the wait signal it inputs is cleared (e.g. the issue stage is able to issue and sends a null wait signal to the fetch and decode stages). When a waiting stage receives a cleared wait signal, it resumes and starts processing its input. 

当某个周期由于依赖未满足需要暂停时，可以向前置的阶段发送wait信号，每个阶段在收到wait信号时都会保持输出信号不变从而部分暂停流水线。

> To allow waits from multicycle stages, each stage input and output structure contains a valid bit. While a multicycle stage is in progress, its output is invalid. The valid bit is set once the final result is ready and the wait condition is cleared.

部分暂停流水线的同时要设置valid标识告诉后续未暂停周期不要处理非法的输入

![6s-multi-wait](/assets/images/2024-03-03/6s-multi-wait.png)

* The red stages are frozen while the i_wait signal is set
* The red and green stages are frozen while the e_wait signal is set
* The red, green, and blue stages are frozen while the m_wait signal is set
* If the i_wait signal is cleared while either the e_wait or the m_wait signal is set, the red stages keep frozen
* If the i_wait signal is cleared while both the e_wait and the m_wait signals are clear, the red stages are resumed

一个阶段可能收到多个wait和resum信号，wait信号取并集，resum信号取交集


### 顶层模块

```c

static void init_reg_file(
  int   *reg_file,
  bit_t *is_reg_computed) {
  reg_num_p1_t r;
  for (r=0; r<NB_REGISTER; r++) {
    is_reg_computed[r] = 0;
    reg_file       [r] = 0;
  }
}

static void running_cond_update(
  from_m_to_w_t w_from_m,
  bit_t        *is_running) {
  *is_running = !w_from_m.is_valid ||
                !w_from_m.is_ret   ||
                 w_from_m.value != 0;
}

static void statistic_update(
  from_i_to_e_t e_from_i,
  counter_t    *nbi,
  counter_t    *nbc) {
  *nbi = *nbi + (unsigned int)(e_from_i.is_valid);
  *nbc = *nbc + 1;
}

void multicycle_pipeline_ip(
  unsigned int  start_pc,
  unsigned int  code_ram[CODE_RAM_SIZE],
  int           data_ram[DATA_RAM_SIZE],
  unsigned int *nb_instruction,
  unsigned int *nb_cycle) {
#pragma HLS INTERFACE s_axilite port=start_pc
#pragma HLS INTERFACE s_axilite port=code_ram
#pragma HLS INTERFACE s_axilite port=data_ram
#pragma HLS INTERFACE s_axilite port=nb_instruction
#pragma HLS INTERFACE s_axilite port=nb_cycle
#pragma HLS INTERFACE s_axilite port=return
#pragma HLS INLINE recursive

  int           reg_file       [NB_REGISTER];
#pragma HLS ARRAY_PARTITION variable=reg_file        dim=1 complete

  // 记录是否回写阶段将会更新寄存器
  bit_t         is_reg_computed[NB_REGISTER];
#pragma HLS ARRAY_PARTITION variable=is_reg_computed dim=1 complete

  from_f_to_f_t f_to_f;
  from_f_to_d_t f_to_d;
  from_d_to_f_t d_to_f;
  from_d_to_i_t d_to_i;
  bit_t         i_wait;
  i_safe_t      i_safe;
  from_i_to_e_t i_to_e;
  from_e_to_f_t e_to_f;
  from_e_to_m_t e_to_m;
  from_m_to_w_t m_to_w;
  bit_t         is_running;
  counter_t     nbi;
  counter_t     nbc;

  init_reg_file(reg_file, is_reg_computed);
  f_to_f.is_valid  = 1;
  f_to_f.next_pc   = start_pc;
  f_to_d.is_valid  = 0;
  d_to_f.is_valid  = 0;
  d_to_i.is_valid  = 0;
  i_to_e.is_valid  = 0;
  e_to_f.is_valid  = 0;
  e_to_m.is_valid  = 0;
  m_to_w.is_valid  = 0;
  i_wait           = 0;
  i_safe.is_full   = 0;
  nbi              = 0;
  nbc              = 0;

  do {
#pragma HLS PIPELINE II=2
#pragma HLS LATENCY max=1

    statistic_update(i_to_e, &nbi, &nbc);
    running_cond_update(m_to_w, &is_running);
    write_back(m_to_w, reg_file, is_reg_computed);
    mem_access(e_to_m, data_ram, &m_to_w);
    execute(i_to_e, &e_to_f, &e_to_m);
    issue(d_to_i, reg_file, is_reg_computed, &i_safe, &i_to_e, &i_wait);
    decode(f_to_d, i_wait, &d_to_f, &d_to_i);
    fetch(f_to_f, d_to_f, e_to_f, i_wait, code_ram, &f_to_f, &f_to_d);
  } while (is_running);

  *nb_cycle       = nbc;
  *nb_instruction = nbi;
}

```

### 取指

```c

static void decode_control(
  instruction_t      instruction,
  decoded_control_t *d_ctrl) {
  opcode_t opcode;
  opcode = (instruction >> 2);
  d_ctrl->is_branch = (opcode == BRANCH);
  d_ctrl->is_jalr   = (opcode == JALR);
  d_ctrl->is_jal    = (opcode == JAL);
}

static void stage_job(
  code_address_t     pc,
  unsigned int      *code_ram,
  instruction_t     *instruction,
  decoded_control_t *d_ctrl) {
  *instruction = code_ram[pc];
  decode_control(*instruction, d_ctrl);
}

static void set_output_to_f(
  code_address_t pc,
  from_f_to_f_t *f_to_f) {
  f_to_f->next_pc = pc + 1;
}

static void set_output_to_d (
  code_address_t    pc,
  instruction_t     instruction,
  decoded_control_t d_ctrl,
  from_f_to_d_t    *f_to_d){
  f_to_d->pc          = pc;
  f_to_d->instruction = instruction;
  f_to_d->is_branch   = d_ctrl.is_branch;
  f_to_d->is_jalr     = d_ctrl.is_jalr;
  f_to_d->is_jal      = d_ctrl.is_jal;
}

void fetch(
  from_f_to_f_t  f_from_f,
  from_d_to_f_t  f_from_d,
  from_e_to_f_t  f_from_e,
  bit_t          i_wait,
  instruction_t *code_ram,
  from_f_to_f_t *f_to_f,
  from_f_to_d_t *f_to_d) {
  bit_t             has_input;
  instruction_t     instruction;
  decoded_control_t d_ctrl;
  bit_t             is_ctrl;
  code_address_t    pc;

  if (!i_wait) {
    has_input = f_from_f.is_valid || f_from_d.is_valid || f_from_e.is_valid;
    if (has_input) {
      if (f_from_f.is_valid)
        pc = f_from_f.next_pc;
      else if (f_from_d.is_valid)
        pc = f_from_d.target_pc;
      else if (f_from_e.is_valid)
        pc = f_from_e.target_pc;

      // 非暂停且收到合法输入才会继续处理
      stage_job(pc, code_ram, &instruction, &d_ctrl);
      set_output_to_f(pc, f_to_f);
      set_output_to_d(pc, instruction, d_ctrl, f_to_d);
    }
    is_ctrl = d_ctrl.is_branch || d_ctrl.is_jalr || d_ctrl.is_jal;
    // 发生了跳转，跳转目标从d/e回传
    f_to_f->is_valid = has_input && !is_ctrl;
    f_to_d->is_valid = has_input;
  }
}

```

### 译码

```c

static void decode_instruction(
  instruction_t          instruction,
  bit_t                  is_branch,
  bit_t                  is_jalr,
  bit_t                  is_jal,
  decoded_instruction_t *d_i) {

  // ...
  
  // rs1是否有效
  d_i->is_rs1_reg = (is_not_jal   && !is_lui      &&
                     is_not_auipc && (d_i->rs1 != 0));
  // rs2是否有效
  d_i->is_rs2_reg = (!is_op_imm   && !is_load     &&
                     is_not_jal   && !is_jalr     &&
                     !is_lui      && is_not_auipc &&
                     (d_i->rs2 != 0));
}

static void decode_immediate(
  instruction_t          instruction,
  decoded_instruction_t *d_i) {
  // ...
}

static void stage_job(
  code_address_t         pc,
  instruction_t          instruction,
  bit_t                  is_branch,
  bit_t                  is_jalr,
  bit_t                  is_jal,
  decoded_instruction_t *d_i,
  code_address_t        *target_pc) {
  decode_instruction(instruction, is_branch, is_jalr, is_jal, d_i);
  decode_immediate  (instruction, d_i);
  if (d_i->is_jal)
    *target_pc = pc + (code_address_t)(d_i->imm >> 1);
}

static void set_output_to_f(
  code_address_t target_pc,
  from_d_to_f_t *d_to_f) {
  d_to_f->target_pc = target_pc;
}

static void set_output_to_i(
  code_address_t        pc,
  decoded_instruction_t d_i,
  from_d_to_i_t        *d_to_i) {
  d_to_i->pc          = pc;
  d_to_i->d_i         = d_i;
}

void decode(
  from_f_to_d_t  d_from_f,
  bit_t          i_wait,
  from_d_to_f_t *d_to_f,
  from_d_to_i_t *d_to_i) {
  decoded_instruction_t d_i;
  code_address_t        target_pc;
  if (!i_wait) {
    if (d_from_f.is_valid){
      stage_job(d_from_f.pc, d_from_f.instruction,
                d_from_f.is_branch, d_from_f.is_jalr,
                d_from_f.is_jal, &d_i, &target_pc);
      set_output_to_f(target_pc, d_to_f);
      set_output_to_i(d_from_f.pc, d_i, d_to_i);
    }

    // 无条件跳转指令
    d_to_f->is_valid = d_from_f.is_valid && d_i.is_jal;
    d_to_i->is_valid = d_from_f.is_valid;
  }
}

```

### 发射

```c

// 保持输入信号
static void save_input_from_d(
  from_d_to_i_t i_from_d,
  i_safe_t     *i_safe) {
  i_safe->pc          = i_from_d.pc;
  i_safe->d_i         = i_from_d.d_i;
}

static void stage_job(
  decoded_instruction_t d_i,
  int                  *reg_file,
  int                  *rv1,
  int                  *rv2) {
  *rv1 = reg_file[d_i.rs1];
  *rv2 = reg_file[d_i.rs2];
}

static void set_output_to_e(
  code_address_t        pc,
  decoded_instruction_t d_i,
  int                   rv1,
  int                   rv2,
  from_i_to_e_t        *i_to_e) {
  i_to_e->pc          = pc;
  i_to_e->d_i         = d_i;
  i_to_e->rv1         = rv1;
  i_to_e->rv2         = rv2;
}

void issue(
  from_d_to_i_t  i_from_d,
  int           *reg_file,
  bit_t         *is_reg_computed,
  i_safe_t      *i_safe,
  from_i_to_e_t *i_to_e,
  bit_t         *i_wait) {
  
  bit_t is_locked_1;
  bit_t is_locked_2;
  int   rv1;
  int   rv2;

  if (!(*i_wait) && !i_safe->is_full) {
    save_input_from_d(i_from_d, i_safe);
    i_safe->is_full = i_from_d.is_valid;
  }

  if (i_safe->is_full) {
    // 依赖即将在回写阶段更新的寄存器
    is_locked_1 = i_safe->d_i.is_rs1_reg &&
                  is_reg_computed[i_safe->d_i.rs1];
    is_locked_2 = i_safe->d_i.is_rs2_reg &&
                  is_reg_computed[i_safe->d_i.rs2];
    *i_wait = is_locked_1 || is_locked_2;

    // 等待数据依赖都满足后再发射指令到执行阶段
    if (!(*i_wait)) {
      stage_job(i_safe->d_i, reg_file, &rv1, &rv2);
      set_output_to_e(i_safe->pc, i_safe->d_i, rv1, rv2, i_to_e);
      // 记录回写阶段将更新寄存器
      if (!i_safe->d_i.has_no_dest)
        is_reg_computed[i_safe->d_i.rd] = 1;
    }
  }

  i_to_e->is_valid = i_safe->is_full && !(*i_wait);
  i_safe->is_full  = (*i_wait);
}

```

### 执行

```c

static void compute(
  code_address_t        pc,
  decoded_instruction_t d_i,
  int                   rv1,
  int                   rv2,
  bit_t                *bcond,
  int                  *result1,
  int                  *result2,
  code_address_t       *next_pc) {
  *bcond   = compute_branch_result(rv1, rv2, d_i.func3);
  *result1 = compute_op_result(rv1, rv2, d_i);
  *result2 = compute_result(rv1, pc, d_i);
  *next_pc = compute_next_pc(pc, d_i, rv1);
}

static void stage_job(
  code_address_t        pc,
  decoded_instruction_t d_i,
  bit_t                 bcond,
  code_address_t        next_pc,
  code_address_t       *target_pc) {
  *target_pc = (bcond || d_i.is_jalr) ? next_pc : (code_address_t)(pc + 1);
}

static void set_output_to_f(
  code_address_t target_pc,
  from_e_to_f_t *e_to_f) {
  e_to_f->target_pc = target_pc;
}

static void set_output_to_m(
  decoded_instruction_t d_i,
  int                   result1,
  int                   result2,
  code_address_t        next_pc,
  int                   rv2,
  code_address_t        target_pc,
  from_e_to_m_t        *e_to_m) {
  e_to_m->rd            = d_i.rd;
  e_to_m->has_no_dest   = d_i.has_no_dest;
  e_to_m->is_load       = d_i.is_load;
  e_to_m->is_store      = d_i.is_store;
  e_to_m->func3         = d_i.func3;
  // e_to_m->is_ret is used by running_cond_update
  e_to_m->is_ret        = d_i.is_ret;
  e_to_m->address       = result2;
  e_to_m->value         = (d_i.is_ret) ? (int)target_pc :
                          (d_i.is_jal || d_i.is_jalr || (d_i.type == U_TYPE)) ? result2 :
                          (d_i.is_store) ? rv2 : result1;
  e_to_m->target_pc     = (d_i.is_jal || d_i.is_branch) ? target_pc : next_pc;
}

void execute(
  from_i_to_e_t  e_from_i,
  from_e_to_f_t *e_to_f,
  from_e_to_m_t *e_to_m) {
  bit_t          bcond;
  int            result1;
  int            result2;
  code_address_t target_pc;
  code_address_t next_pc;

  if (e_from_i.is_valid) {
    compute(e_from_i.pc, e_from_i.d_i, e_from_i.rv1,
            e_from_i.rv2, &bcond, &result1, &result2, &next_pc);
    stage_job(e_from_i.pc, e_from_i.d_i, bcond, next_pc, &target_pc);
    set_output_to_f(target_pc, e_to_f);
    set_output_to_m(e_from_i.d_i, result1, result2, next_pc,
                    e_from_i.rv2, target_pc, e_to_m);
  }
  
  // 是否跳转
  e_to_f->is_valid   = e_from_i.is_valid      &&
                      (e_from_i.d_i.is_branch ||
                        (e_from_i.d_i.is_jalr &&
                          (!e_from_i.d_i.is_ret || (next_pc != 0))));

  e_to_m->is_valid = e_from_i.is_valid;
}

```

### 访存

```c

int mem_load(
  int             *data_ram,
  b_data_address_t address,
  func3_t          msize) {
  // ...
}

void mem_store(
  int             *data_ram,
  b_data_address_t address,
  int              rv2,
  ap_uint<2>       msize) {
  // ...
}

static void stage_job(
  bit_t            is_load,
  bit_t            is_store,
  b_data_address_t address,
  func3_t          func3,
  int             *data_ram,
  int             *value) {
  if (is_load)
    *value = mem_load(data_ram, address, func3);
  else if (is_store)
    mem_store(data_ram, address, *value, (ap_uint<2>)func3);
}

static void set_output_to_w(
  reg_num_t             rd,
  bit_t                 has_no_dest,
  bit_t                 is_ret,
  int                   value,
  from_m_to_w_t        *m_to_w) {
  m_to_w->rd          = rd;
  m_to_w->has_no_dest = has_no_dest;
  m_to_w->is_ret      = is_ret;
  m_to_w->value       = value;
}

void mem_access(
  from_e_to_m_t  m_from_e,
  int           *data_ram,
  from_m_to_w_t *m_to_w) {
  int value;
  if (m_from_e.is_valid){
    value = m_from_e.value;
    stage_job(m_from_e.is_load, m_from_e.is_store,
              m_from_e.address, m_from_e.func3, data_ram, &value);
    set_output_to_w(m_from_e.rd, m_from_e.has_no_dest,
                    m_from_e.is_ret, value, m_to_w);
  }

  m_to_w->is_valid = m_from_e.is_valid;
}

```

### 回写

```c

static void stage_job(
  bit_t     has_no_dest,
  reg_num_t rd,
  int       value,
  int      *reg_file) {
  if (!has_no_dest) reg_file[rd] = value;
}

void write_back(
  from_m_to_w_t w_from_m,
  int          *reg_file,
  bit_t        *is_reg_computed) {
  if (w_from_m.is_valid) {
    stage_job(w_from_m.has_no_dest, w_from_m.rd,
              w_from_m.value, reg_file);
    // 清除回写标识
    if (!w_from_m.has_no_dest)
      is_reg_computed[w_from_m.rd] = 0;
  }
}

```

## 多线程流水线

> At the OS level, a flow of control is a thread. The processor can be designed to host multiple threads and run them simultaneously (Simultaneous MultiThreading or SMT). Such thread dedicated slots in the processor are called harts (for HARdware Threads). 

> In order to fill the pipeline and decrease the CPI as close to 1 as possible, there are multiple techniques. The lost cycles are due to waiting conditions, i.e. dependencies between instructions. One way to recover these cycles is to eliminate the dependencies with prediction. The control flow dependencies can be eliminated through branch prediction. The data dependencies can be eliminated through value prediction.

CPI降低是因为流水线出现数据依赖时的等待，分支预测可以提高CPI

> Another possibility is to use independent instructions to fill empty pipeline slots. While an instruction is waiting for a prior result, the pipeline continues to fetch and process following instructions and make them bypass the stopped one. This is called out-of-order, or OoO computation. OoO implementation is tricky and requires costly additional logic like a register renaming unit. The reward is really only worth the complexity for speculative superscalar designs in which the pipeline stages may process multiple instructions simultaneously and the addresses for the fetch unit are provided through a branch predictor.

另一种提高效率的方式时乱序执行，一个指令由于数据依赖阻塞时继续处理与之无依赖关系的指令

![hart](/assets/images/2024-03-03/hart.png)

> A third option to fill the pipeline is to interleave instructions from multiple flows (i.e. by running multiple threads), which is called multithreading. It should be pointed out though that multithreading is a way to make the pipeline compute more but not a way to accelerate the run of a thread of computation. The pipeline is shared by the threads and each thread runs at the speed corresponding to its share (e.g. half the processor speed if there are two threads, each filling half of the pipeline slots). To handle multiple threads, a processor must be provided with multiple pc and register files (in a multithreaded OoO design implementing register renaming like SMT, the register file is shared). The pipeline stages and the computing units are shared. The inter-stage connections must specify which thread is emitting its result to the next stage (e.g. d_to_i.hart to send something from the decode stage to the issue stage). 

第三种提高效率的方式是同时处理多个独立的指令流，在一个指令流阻塞时转而处理其他指令流以充分利用流水线。多个数据流只是公用流水线和计算单元，pc和regfile是各自独立的。流水线各个阶段之间传递数据时需要指明发送线程以更新对应的pc和regfile。


### 顶层模块

![hart-conn](/assets/images/2024-03-03/hart-conn.png)

```c

typedef struct decoded_instruction_s {
  // ...
} decoded_instruction_t;

typedef struct decoded_immediate_s {
  // ...
} decoded_immediate_t;

// 存储取指阶段的状态
typedef struct f_state_s {
  code_address_t fetch_pc;
  instruction_t  instruction;
} f_state_t;

// 阶段间传递数据都需指明hart
typedef struct from_f_to_d_s {
  bit_t          is_valid;
  hart_num_t     hart;
  code_address_t fetch_pc;
  instruction_t  instruction;
} from_f_to_d_t;

// 存储译码阶段的状态
typedef struct d_state_s {
  code_address_t        fetch_pc;
  instruction_t         instruction;
  decoded_instruction_t d_i;
  code_address_t        relative_pc;
} d_state_t;

typedef struct from_d_to_f_s {
  bit_t          is_valid;
  hart_num_t     hart;
  code_address_t relative_pc;
} from_d_to_f_t;

typedef struct from_d_to_i_s {
  bit_t                 is_valid;
  hart_num_t            hart;
  code_address_t        fetch_pc;
  decoded_instruction_t d_i;
  code_address_t        relative_pc;
} from_d_to_i_t;

typedef struct i_state_s {
  code_address_t        fetch_pc;
  decoded_instruction_t d_i;
  int                   rv1;
  int                   rv2;
  code_address_t        relative_pc;
  bit_t                 wait_12;
} i_state_t;

typedef struct from_i_to_e_s {
  bit_t                 is_valid;
  hart_num_t            hart;
  code_address_t        fetch_pc;
  decoded_instruction_t d_i;
  int                   rv1;
  int                   rv2;
  code_address_t        relative_pc;
} from_i_to_e_t;

typedef struct e_state_s {
  int                   rv1;
  int                   rv2;
  code_address_t        fetch_pc;
  decoded_instruction_t d_i;
  code_address_t        relative_pc;
  code_address_t        target_pc;
  bit_t                 is_target;
} e_state_t;

typedef struct from_e_to_f_s {
  bit_t          is_valid;
  hart_num_t     hart;
  code_address_t target_pc;
} from_e_to_f_t;

typedef struct from_e_to_m_s {
  bit_t                 is_valid;
  hart_num_t            hart;
  reg_num_t             rd;
  bit_t                 has_no_dest;
  bit_t                 is_load;
  bit_t                 is_store;
  func3_t               func3;
  bit_t                 is_ret;
  b_data_address_t      address;
  int                   value;
} from_e_to_m_t;

typedef struct m_state_s {
  reg_num_t             rd;
  bit_t                 has_no_dest;
  bit_t                 is_load;
  bit_t                 is_store;
  func3_t               func3;
  bit_t                 is_ret;
  b_data_address_t      address;
  int                   value;
  hart_num_t            accessed_h;
  bit_t                 is_local;
} m_state_t;

typedef struct from_m_to_w_s {
  bit_t                 is_valid;
  hart_num_t            hart;
  reg_num_t             rd;
  bit_t                 has_no_dest;
  bit_t                 is_ret;
  int                   value;
} from_m_to_w_t;

typedef struct w_state_s{
  int                   value;
  reg_num_t             rd;
  bit_t                 has_no_dest;
  bit_t                 is_ret;
} w_state_t;

```

```c

static void init_file(
  int   reg_file       [][NB_REGISTER],
  bit_t is_reg_computed[][NB_REGISTER]) {
  hart_num_p1_t h1;
  hart_num_t    h;
  reg_num_p1_t  r1;
  reg_num_t     r;
  for (h1=0; h1<NB_HART; h1++){
#pragma HLS UNROLL
    h = h1;
    for (r1=0; r1<NB_REGISTER; r1++){
#pragma HLS UNROLL
      r = r1;
      is_reg_computed[h][r] = 0;
      // r11记录hart
      if (r == 11)
        reg_file     [h][r] = h;
      else if (r == SP)
        // 每个线程分配独立的stack
        reg_file     [h][r] = (1<<(LOG_HART_DATA_RAM_SIZE+2));
      else
        reg_file     [h][r] = 0;
    }
  }
}

// 记录线程是否已退出
static void init_exit(
  hart_set_t running_hart_set,
  bit_t     *has_exited) {
  hart_num_p1_t h1;
  hart_num_t    h;
  bit_t         h_running;
  for (h1=0; h1<NB_HART; h1++){
#pragma HLS UNROLL
    h             = h1;
    h_running     = (running_hart_set >> h);
    has_exited[h] = !h_running;
  }
}

static void running_cond_update(
  bit_t *has_exited,
  bit_t *is_running) {
  hart_num_p1_t h1;
  hart_num_t    h;
  bit_t         cond;
  cond = 0;
  for (h1=0; h1<NB_HART; h1++) {
#pragma HLS UNROLL
    h = h1;
    cond = cond | !has_exited[h];
  }

  *is_running = cond;
}

static void statistic_update(
  from_i_to_e_t e_from_i,
  counter_t    *nbi,
  counter_t    *nbc) {
  *nbi = *nbi + (unsigned int)(e_from_i.is_valid);
  *nbc = *nbc + 1;
}

// 标识hart的寄存器是否在更新中
static void lock_unlock_update(
  bit_t      is_lock,
  hart_num_t i_hart,
  reg_num_t  i_destination,
  bit_t      is_unlock,
  hart_num_t w_hart,
  reg_num_t  w_destination,
  bit_t      is_reg_computed[][NB_REGISTER]) {
  if (is_lock && !is_unlock)
    is_reg_computed[i_hart][i_destination] = 1;
  else if (is_unlock && !is_lock)
    is_reg_computed[w_hart][w_destination] = 0;
  else if (is_lock && is_unlock && 
          ((i_hart != w_hart) || (i_destination != w_destination))){
    is_reg_computed[i_hart][i_destination] = 1;
    is_reg_computed[w_hart][w_destination] = 0;
  }
}

void multihart_ip(
  unsigned int  running_hart_set,
  unsigned int  start_pc[NB_HART],
  unsigned int  code_ram[CODE_RAM_SIZE],
  int           data_ram[NB_HART][HART_DATA_RAM_SIZE],
  unsigned int *nb_instruction,
  unsigned int *nb_cycle) {
#pragma HLS INTERFACE s_axilite port=running_hart_set
#pragma HLS INTERFACE s_axilite port=start_pc
#pragma HLS INTERFACE s_axilite port=code_ram
#pragma HLS INTERFACE s_axilite port=data_ram
#pragma HLS INTERFACE s_axilite port=nb_instruction
#pragma HLS INTERFACE s_axilite port=nb_cycle
#pragma HLS INTERFACE s_axilite port=return
#pragma HLS INLINE recursive

  // 每个线程独立的寄存器
  int   reg_file               [NB_HART][NB_REGISTER];
#pragma HLS ARRAY_PARTITION variable=reg_file        dim=0 complete

  bit_t is_reg_computed        [NB_HART][NB_REGISTER];
#pragma HLS ARRAY_PARTITION variable=is_reg_computed dim=0 complete

  from_d_to_f_t f_from_d;
  from_e_to_f_t f_from_e;
  // 记录hart的state是否有效，有效状态才能被选择
  bit_t         f_state_is_full[NB_HART];
#pragma HLS ARRAY_PARTITION variable=f_state_is_full dim=1 complete
  f_state_t     f_state        [NB_HART];
#pragma HLS ARRAY_PARTITION variable=f_state         dim=1 complete

  from_f_to_d_t f_to_d;
  from_f_to_d_t d_from_f;
  // d_state_is_full[hart]会导致f_state[hart]不能被选择
  bit_t         d_state_is_full[NB_HART];
#pragma HLS ARRAY_PARTITION variable=d_state_is_full dim=1 complete
  d_state_t     d_state        [NB_HART];
#pragma HLS ARRAY_PARTITION variable=d_state         dim=1 complete

  from_d_to_f_t d_to_f;
  from_d_to_i_t d_to_i;
  from_d_to_i_t i_from_d;
  bit_t         i_state_is_full[NB_HART];
#pragma HLS ARRAY_PARTITION variable=i_state_is_full dim=1 complete
  i_state_t     i_state        [NB_HART];
#pragma HLS ARRAY_PARTITION variable=i_state         dim=1 complete

  from_i_to_e_t i_to_e;
  from_i_to_e_t e_from_i;
  bit_t         e_state_is_full[NB_HART];
#pragma HLS ARRAY_PARTITION variable=e_state_is_full dim=1 complete
  e_state_t     e_state        [NB_HART];
#pragma HLS ARRAY_PARTITION variable=e_state         dim=1 complete

  from_e_to_f_t e_to_f;
  from_e_to_m_t e_to_m;
  from_e_to_m_t m_from_e;
  bit_t         m_state_is_full[NB_HART];
#pragma HLS ARRAY_PARTITION variable=m_state_is_full dim=1 complete
  m_state_t     m_state        [NB_HART];
#pragma HLS ARRAY_PARTITION variable=m_state         dim=1 complete

  from_m_to_w_t m_to_w;
  from_m_to_w_t w_from_m;
  bit_t         w_state_is_full[NB_HART];
#pragma HLS ARRAY_PARTITION variable=w_state_is_full dim=1 complete
  w_state_t     w_state        [NB_HART];
#pragma HLS ARRAY_PARTITION variable=w_state         dim=1 complete

  // 记录hart是否已退出
  bit_t         has_exited     [NB_HART];
#pragma HLS ARRAY_PARTITION variable=has_exited      dim=1 complete

  bit_t         is_running;
  bit_t         is_lock;
  bit_t         is_unlock;
  reg_num_t     i_destination;
  reg_num_t     w_destination;
  hart_num_t    i_hart;
  hart_num_t    w_hart;
  counter_t     nbi;
  counter_t     nbc;

  init_exit   (running_hart_set, has_exited);
  init_f_state(running_hart_set, start_pc, f_state, f_state_is_full);
  init_d_state(d_state_is_full);
  init_i_state(i_state_is_full);
  init_e_state(e_state_is_full);
  init_m_state(m_state_is_full);
  init_w_state(w_state_is_full);
  init_file   (reg_file, is_reg_computed);
  f_to_d.is_valid = 0;
  d_to_f.is_valid = 0;
  d_to_i.is_valid = 0;
  i_to_e.is_valid = 0;
  e_to_f.is_valid = 0;
  e_to_m.is_valid = 0;
  m_to_w.is_valid = 0;
  nbi             = 0;
  nbc             = 0;

  do {
#pragma HLS PIPELINE II=2
#pragma HLS LATENCY max=1
    // x_from_y = y_to_x
    new_cycle(f_to_d, d_to_f, d_to_i, i_to_e, e_to_f, e_to_m,
              m_to_w, &f_from_d, &f_from_e, &d_from_f,
             &i_from_d, &e_from_i, &m_from_e, &w_from_m);
    statistic_update(e_from_i, &nbi, &nbc);
    running_cond_update(has_exited, &is_running);

    fetch(f_from_d, f_from_e, d_state_is_full,
          code_ram, f_state, &f_to_d, f_state_is_full);
    decode(d_from_f, i_state_is_full, d_state, &d_to_f,
          &d_to_i, d_state_is_full);
    issue(i_from_d, e_state_is_full, reg_file,
          is_reg_computed, i_state, &i_to_e, i_state_is_full,
         &is_lock, &i_hart, &i_destination);
    execute(e_from_i, m_state_is_full,
            e_state, &e_to_f, &e_to_m, e_state_is_full);
    mem_access(m_from_e, w_state_is_full, data_ram, m_state,
              &m_to_w, m_state_is_full);
    write_back(w_from_m, reg_file, w_state, w_state_is_full,
              &is_unlock, &w_hart, &w_destination, has_exited);

    // 标识hart的寄存器是否在更新中
    lock_unlock_update(is_lock, i_hart, i_destination,
                       is_unlock, w_hart, w_destination, is_reg_computed);
  } while (is_running);

  *nb_cycle       = nbc;
  *nb_instruction = nbi;
}

```

### 取指

```c

void init_f_state(
  hart_set_t    running_hart_set,
  unsigned int *start_pc,
  f_state_t    *f_state,
  bit_t        *f_state_is_full) {
  hart_num_p1_t h1;
  hart_num_t    h;
  bit_t         h_running;
  for (h1=0; h1<NB_HART; h1++) {
#pragma HLS UNROLL
    h                           = h1;
    h_running                   = (running_hart_set >> h);
    f_state_is_full[h]          = h_running;
    f_state        [h].fetch_pc = start_pc[h];
  }
}

static void save_input_from_d(
  from_d_to_f_t f_from_d,
  f_state_t    *f_state) {
  f_state[f_from_d.hart].fetch_pc = f_from_d.relative_pc;
}

static void save_input_from_e(
  from_e_to_f_t f_from_e,
  f_state_t    *f_state) {
  f_state[f_from_e.hart].fetch_pc = f_from_e.target_pc;
}

static void stage_job(
  hart_num_t         hart,
  f_state_t         *f_state,
  instruction_t     *code_ram) {
  f_state[hart].instruction = code_ram[f_state[hart].fetch_pc];
}

static void set_output_to_d(
  hart_num_t        hart,
  f_state_t        *f_state,
  from_f_to_d_t    *f_to_d) {
  f_to_d->hart        = hart;
  f_to_d->fetch_pc    = f_state[hart].fetch_pc;
  f_to_d->instruction = f_state[hart].instruction;
}

// 选择算法
void select_hart(
  bit_t      *f_state_is_full,
  bit_t      *d_state_is_full,
  bit_t      *is_selected,
  hart_num_t *selected_hart) {
  bit_t c[2];
  c[0] = (f_state_is_full[0] && !d_state_is_full[0]);
  c[1] = (f_state_is_full[1] && !d_state_is_full[1]);
  *selected_hart = (c[0]) ? 0 : 1;
  *is_selected   = (c[0] || c[1]);
}

void fetch(
  from_d_to_f_t  f_from_d,
  from_e_to_f_t  f_from_e,
  bit_t         *d_state_is_full,
  instruction_t *code_ram,
  f_state_t     *f_state,
  from_f_to_d_t *f_to_d,
  bit_t         *f_state_is_full) {
  bit_t      is_selected;
  hart_num_t selected_hart;
  bit_t      is_fetching;
  hart_num_t fetching_hart;

  select_hart(f_state_is_full, d_state_is_full, &is_selected,  &selected_hart);
  
  if (f_from_d.is_valid) {
    f_state_is_full[f_from_d.hart] = 1;
    save_input_from_d(f_from_d, f_state);
  }
  if (f_from_e.is_valid) {
    f_state_is_full[f_from_e.hart] = 1;
    save_input_from_e(f_from_e, f_state);
  }

  is_fetching = is_selected                                           ||
               (f_from_d.is_valid && !d_state_is_full[f_from_d.hart]) ||
               (f_from_e.is_valid && !d_state_is_full[f_from_e.hart]);
  fetching_hart = (is_selected) ? selected_hart :
                  (f_from_d.is_valid && !d_state_is_full[f_from_d.hart]) ? f_from_d.hart : 
                  f_from_e.hart;

  if (is_fetching) {
    f_state_is_full[fetching_hart] = 0;
    stage_job(fetching_hart, f_state, code_ram);
    set_output_to_d(fetching_hart, f_state, f_to_d);
  }

  f_to_d->is_valid = is_fetching;
}

```

### 译码

```c



```

### 发射

```c



```

### 执行

```c



```

### 访存

```c



```

### 回写

```c



```

