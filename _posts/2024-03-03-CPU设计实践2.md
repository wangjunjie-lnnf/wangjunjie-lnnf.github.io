---
layout: post
title:  "CPU设计实践2"
date:   2024-03-03 23:49:07 +0000
categories: jekyll
tags: hardware
---

# CPU设计实践2

此版本是使用HLS实现的riscv-32指令集

## 非流水线版本

### 顶层模块

```c
typedef struct decoded_instruction_s {
  opcode_t    opcode;
  reg_num_t   rd;
  func3_t     func3;
  reg_num_t   rs1;
  reg_num_t   rs2;
  func7_t     func7;
  type_t      type;
  immediate_t imm;
  bit_t       is_load;
  bit_t       is_store;
  bit_t       is_branch;
  bit_t       is_jalr;
  bit_t       is_op_imm;
  bit_t       is_lui;
  bit_t       is_ret;
  bit_t       is_r_type;
} decoded_instruction_t;

typedef struct decoded_immediate_s {
  bit_t       inst_31;
  ap_uint<6>  inst_30_25;
  ap_uint<4>  inst_24_21;
  bit_t       inst_20;
  ap_uint<8>  inst_19_12;
  ap_uint<4>  inst_11_8;
  bit_t       inst_7;
} decoded_immediate_t;

static void running_cond_update(
  instruction_t  instruction,
  code_address_t pc,
  bit_t         *is_running) {  
  *is_running = (instruction != RET || pc != 0);
}

static void statistic_update(
  unsigned int *nbi) {
  *nbi = *nbi + 1;
}

// cpu核
void rv32i_npp_ip(
  unsigned int  start_pc,
  unsigned int  code_ram[CODE_RAM_SIZE],
  int           data_ram[DATA_RAM_SIZE],
  unsigned int *nb_instruction) {
  // 端口定义
#pragma HLS INTERFACE s_axilite port=start_pc
#pragma HLS INTERFACE s_axilite port=code_ram
#pragma HLS INTERFACE s_axilite port=data_ram
#pragma HLS INTERFACE s_axilite port=nb_instruction
#pragma HLS INTERFACE s_axilite port=return
#pragma HLS INLINE recursive

  // 状态
  code_address_t        pc;

  int                   reg_file[NB_REGISTER];
#pragma HLS ARRAY_PARTITION variable=reg_file dim=1 complete

  instruction_t         instruction;
  bit_t                 is_running;
  unsigned int          nbi;
  decoded_instruction_t d_i;

  // reset
  for (int i=0; i<NB_REGISTER; i++) reg_file[i] = 0;
  pc  = start_pc;
  nbi = 0;

  // 循环一次表示一个时钟周期  
  do {
#pragma HLS PIPELINE II=7
    fetch(pc, code_ram, &instruction);
    decode(instruction, &d_i);
    // 执行/访存/回写/更新pc
    execute(pc, reg_file, data_ram, d_i, &pc);
    statistic_update(&nbi);
    running_cond_update(instruction, pc, &is_running);
  } while (is_running);

  *nb_instruction = nbi;
}

```

### 取指

```c

// 取指
void fetch(
  code_address_t pc,
  instruction_t *code_ram,
  instruction_t *instruction) {

  *instruction = code_ram[pc];
}

```

### 译码

```c

static void decode_instruction(
  instruction_t          instruction,
  decoded_instruction_t *d_i) {

  d_i->opcode     = (instruction >>  2);
  d_i->rd         = (instruction >>  7);
  d_i->func3      = (instruction >> 12);
  d_i->rs1        = (instruction >> 15);
  d_i->rs2        = (instruction >> 20);
  d_i->func7      = (instruction >> 25);
  d_i->is_load    = (d_i->opcode == LOAD);
  d_i->is_store   = (d_i->opcode == STORE);
  d_i->is_branch  = (d_i->opcode == BRANCH);
  d_i->is_jalr    = (d_i->opcode == JALR);
  d_i->is_ret     = (instruction == RET);
  d_i->is_lui     = (d_i->opcode == LUI);
  d_i->is_op_imm  = (d_i->opcode == OP_IMM);
  d_i->type       = type(d_i->opcode);
  d_i->is_r_type  = (d_i->type   == R_TYPE);
}

static void decode_immediate(
  instruction_t          instruction,
  decoded_instruction_t *d_i) {

  decoded_immediate_t d_imm;
  d_imm.inst_31    = (instruction >> 31);
  d_imm.inst_30_25 = (instruction >> 25);
  d_imm.inst_24_21 = (instruction >> 21);
  d_imm.inst_20    = (instruction >> 20);
  d_imm.inst_19_12 = (instruction >> 12);
  d_imm.inst_11_8  = (instruction >>  8);
  d_imm.inst_7     = (instruction >>  7);

  switch(d_i->type) {
    case UNDEFINED_TYPE: d_i->imm = 0; break;
    case R_TYPE:         d_i->imm = 0; break;
    case I_TYPE:         d_i->imm = i_immediate(d_imm); break;
    case S_TYPE:         d_i->imm = s_immediate(d_imm); break;
    case B_TYPE:         d_i->imm = b_immediate(d_imm); break;
    case U_TYPE:         d_i->imm = u_immediate(d_imm); break;
    case J_TYPE:         d_i->imm = j_immediate(d_imm); break;
    case OTHER_TYPE:     d_i->imm = 0; break;
  }
}

void decode(
  instruction_t          instruction,
  decoded_instruction_t *d_i) {
  decode_instruction(instruction, d_i);
  decode_immediate  (instruction, d_i);
}

```

### 执行

```c

static void read_reg(
  int      *reg_file,
  reg_num_t rs1,
  reg_num_t rs2,
  int      *rv1,
  int      *rv2) {
  *rv1 = reg_file[rs1];
  *rv2 = reg_file[rs2];
}

static void write_reg(
  int                  *reg_file,
  decoded_instruction_t d_i,
  int                   result) {
  if (d_i.rd != 0   &&
     !d_i.is_branch &&
     !d_i.is_store)
    reg_file[d_i.rd] = result;
}

static bit_t compute_branch_result(
  int     rv1,
  int     rv2,
  func3_t func3) {
  switch(func3){
    case BEQ : return (rv1 == rv2);
    case BNE : return (rv1 != rv2);
    case 2   :
    case 3   : return 0;
    case BLT : return (rv1 <  rv2);
    case BGE : return (rv1 >= rv2);
    case BLTU: return (unsigned int)rv1 <  (unsigned int)rv2;
    case BGEU: return (unsigned int)rv1 >= (unsigned int)rv2;
  }
  return 0;
}

static int compute_op_result(
  int                   rv1,
  int                   rv2,
  decoded_instruction_t d_i) {

  bit_t      f7_6 = d_i.func7>>5;
  ap_uint<5> shift;
  int        result;

  if (d_i.is_r_type)
    shift = rv2;
  else  // I_TYPE
    shift = d_i.rs2;

  switch(d_i.func3) {
    case ADD : if (d_i.is_r_type && f7_6)
                 result = rv1 - rv2;//SUB
               else
                 result = rv1 + rv2;
               break;
    case SLL : result = rv1 << shift;
               break;
    case SLT : result = rv1 < rv2;
               break;
    case SLTU: result = (unsigned int)rv1 < (unsigned int)rv2;
               break;
    case XOR : result = rv1 ^ rv2;
               break;
    case SRL : if (f7_6)
                 result = rv1 >> shift;//SRA
               else
                 result = (unsigned int)rv1 >> shift;
               break;
    case OR  : result = rv1 | rv2;
               break;
    case AND : result = rv1 & rv2;
               break;
  }
  return result;
}

static int compute_result(
  int                   rv1,
  int                   rv2,
  decoded_instruction_t d_i,
  code_address_t        pc) {

  int            imm12 = ((int)d_i.imm)<<12;
  code_address_t pc4   = pc<<2;
  code_address_t npc4  = pc4 + 4;
  int            result;

  switch(d_i.type) {
    case R_TYPE:
      result = compute_op_result(rv1, rv2, d_i);
      break;
    case I_TYPE:
      if (d_i.is_jalr)
        result = npc4;
      else if (d_i.is_load)
        result = rv1 + (int)d_i.imm;
      else if (d_i.is_op_imm)
        result = compute_op_result(rv1, (int)d_i.imm, d_i);
      else
        result = 0; // (d_i.opcode == SYSTEM)
      break;
    case S_TYPE:
      result = rv1 + (int)d_i.imm;
      break;
    case B_TYPE:
      result = (unsigned int)compute_branch_result(rv1, rv2, d_i.func3);
      break;
    case U_TYPE:
      if (d_i.is_lui)
        result = imm12;
      else  // d_i.opcode == AUIPC
        result = pc4 + imm12;
      break;
    case J_TYPE:
      result = npc4;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

static code_address_t compute_next_pc(
  code_address_t        pc,
  int                   rv1,
  decoded_instruction_t d_i,
  bit_t                 cond) {

  code_address_t next_pc;

  switch(d_i.type) {
    case R_TYPE:
      next_pc = (code_address_t)(pc+1);
      break;
    case I_TYPE:
      next_pc = (d_i.is_jalr) ? (code_address_t)((rv1 + ((int)d_i.imm)&0xfffffffe)>>2)
                              : (code_address_t)(pc+1);
      break;
    case S_TYPE:
      next_pc = (code_address_t)(pc+1);
      break;
    case B_TYPE:
      next_pc = (cond) ? (code_address_t)(pc+(d_i.imm>>1))
                       : (code_address_t)(pc+1);
      break;
    case U_TYPE:
      next_pc = (code_address_t)(pc+1);
      break;
    case J_TYPE:
      next_pc = (code_address_t)(pc+(d_i.imm>>1));
      break;
    default:
      next_pc = (code_address_t)(pc+1);
      break;
  }

  return next_pc;
}

static int mem_load(
  int             *data_ram,
  b_data_address_t address,
  func3_t          msize) {

  ap_uint<2>       a01 =  address;
  bit_t            a1  = (address >> 1);
  w_data_address_t a2  = (address >> 2);
  int              result;
  char             b, b0, b1, b2, b3;
  unsigned char    ub, ub0, ub1, ub2, ub3;
  short            h, h0, h1;
  unsigned short   uh, uh0, uh1;
  int              w, ib, ih;
  unsigned int     iub, iuh;

  w   = data_ram[a2];
  b0  = w;
  ub0 = b0;
  b1  = w>>8;
  ub1 = b1;
  h0  = ((ap_uint<16>)ub1<<8) | (ap_uint<16>)ub0;
  uh0 = h0;
  b2  = w>>16;
  ub2 = b2;
  b3  = w>>24;
  ub3 = b3;
  h1  = ((ap_uint<16>)ub3<<8) | (ap_uint<16>)ub2;
  uh1 = h1;

  switch(a01) {
    case 0b00: b = b0; break;
    case 0b01: b = b1; break;
    case 0b10: b = b2; break;
    case 0b11: b = b3; break;
  }

  ub  = b;
  ib  = (int)b;
  iub = (unsigned int)ub;
  h   = (a1)?h1:h0;
  uh  = h;
  ih  = (int)h;
  iuh = (unsigned int)uh;

  switch(msize) {
    case LB:
      result = ib;  break;
    case LH:
      result = ih;  break;
    case LW:
      result = w;   break;
    case 3:
      result = 0;   break;
    case LBU:
      result = iub; break;
    case LHU:
      result = iuh; break;
    case 6:
    case 7:
      result = 0;   break;
  }

  return result;
}

static void mem_store(
  int             *data_ram,
  b_data_address_t address,
  int              rv2,
  ap_uint<2>       msize) {

  h_data_address_t a1 = (address >> 1);
  w_data_address_t a2 = (address >> 2);
  char             rv2_0;
  short            rv2_01;
  rv2_0  = rv2;
  rv2_01 = rv2;

  switch(msize) {
    case SB:
      *((char*) (data_ram) + address) = rv2_0;
      break;
    case SH:
      *((short*)(data_ram) + a1)      = rv2_01;
      break;
    case SW:
      data_ram[a2]                    = rv2;
      break;
    case 3:
      break;
  }
}

void execute(
  code_address_t        pc,
  int                  *reg_file,
  int                  *data_ram,
  decoded_instruction_t d_i,
  code_address_t       *next_pc) {

  int              rv1, rv2, result;
  b_data_address_t address;

  // 读寄存器
  read_reg(reg_file, d_i.rs1, d_i.rs2, &rv1, &rv2);
  // 计算执行结果
  result  = compute_result(rv1, rv2, d_i, pc);

  // 读写内存  
  address = result;
  if (d_i.is_store)
    mem_store(data_ram, address, rv2, (ap_uint<2>)d_i.func3);
  if (d_i.is_load)
    result = mem_load(data_ram, address, d_i.func3);

  // 回写  
  write_reg(reg_file, d_i, result);
  
  // 更新pc
  *next_pc = compute_next_pc(pc, rv1, d_i, (bit_t)result);
}

```

### 测试

```c

#include <stdio.h>
#include "rv32i_npp_ip.h"

int          data_ram[DATA_RAM_SIZE];
unsigned int code_ram[CODE_RAM_SIZE] = {
#include "test_load_store_0_text.hex"
};

int main() {
  unsigned int nbi;
  int          w;

  rv32i_npp_ip(0, code_ram, data_ram, &nbi);

  printf("%d fetched and decoded instructions\n", nbi);

  printf("data memory dump (non null words)\n");

  for (int i=0; i<DATA_RAM_SIZE; i++){
    w = data_ram[i];
    if (w != 0)
      printf("m[%5x] = %16d (%8x)\n", 4*i, w, (unsigned int)w);
  }

  return 0;
}

```

### 总结

非流水线版本代码很简洁，一方面是rv32i指令集本身指令很少，另一方面HLS相对verilog表达能力很强


## 流水线版本




## 多周期流水线版本

