---
layout: post
title:  "jvm之并行gc算法"
date:   2023-03-27 09:22:07 +0000
categories: jekyll
tags: jvm gc
---

# gc

## gc相关参数

```c++

jint Threads::create_vm(JavaVMInitArgs* args, ...)
{
    Arguments::parse(args);
    {
        parse_vm_init_args(args);
        {
            parse_each_vm_init_arg(args, &scp, ...);
            {
                // 打印gc信息
                if (match_option(option, "-verbose", &tail)) {
                    if (!strcmp(tail, ":gc")) {
                        FLAG_SET_CMDLINE(bool, PrintGC, true);
                    }
                } else if (match_option(option, "-Xnoclassgc", &tail)) {
                    // 默认回收class
                    FLAG_SET_CMDLINE(bool, ClassUnloading, false);
                } else if (match_option(option, "-Xmn", &tail)) {
                    FLAG_SET_CMDLINE(uintx, MaxNewSize, ...);
                    FLAG_SET_CMDLINE(uintx, NewSize, ...);
                } else if (match_option(option, "-Xms", &tail)) {
                    FLAG_SET_CMDLINE(uintx, InitialHeapSize, ...);
                } else if (match_option(option, "-Xmx", &tail) || match_option(option, "-XX:MaxHeapSize=", &tail)) {
                    FLAG_SET_CMDLINE(uintx, MaxHeapSize, ...);
                } else if (match_option(option, "-Xss", &tail)) {
                    FLAG_SET_CMDLINE(intx, ThreadStackSize, ...);
                } else if (match_option(option, "-Xloggc:", &tail)) {
                    // 打印gc信息到指定文件
                    _gc_log_filename = strdup(tail);
                    FLAG_SET_CMDLINE(bool, PrintGC, true);
                    FLAG_SET_CMDLINE(bool, PrintGCTimeStamps, true);
                }
            }
        }
    }

    Arguments::apply_ergo();
    {
        set_ergonomics_flags();
        {
            select_gc();
            {
                if (!gc_selected()) {
                    // 设置默认gc
                    select_gc_ergonomically();
                    {
                        // 配置超过2核2G视为server
                        if (os::is_server_class_machine()) {
                            if (should_auto_select_low_pause_collector()) {
                                // 设置了cms相关参数
                                FLAG_SET_ERGO(bool, UseConcMarkSweepGC, true);
                            } else {
                                // 默认UseParallelGC
                                FLAG_SET_ERGO(bool, UseParallelGC, true);
                            }
                        }
                    }
                }
            }
        }

        set_heap_size();
        {
            julong phys_mem = MIN2(os::physical_memory(), (julong)MaxRAM);

            // MaxHeapSize默认96M
            // InitialHeapSize默认0

            // 下文中的参数全部使用默认值
            if (FLAG_IS_DEFAULT(MaxHeapSize)) {
                julong reasonable_max = (julong)((phys_mem * 25) / 100);
                const julong reasonable_min = (julong)((phys_mem * 50) / 100);

                if (reasonable_min < MaxHeapSize) {
                    reasonable_max = reasonable_min;
                } else {
                    reasonable_max = MAX2(reasonable_max, (julong)MaxHeapSize);
                }

                if (!FLAG_IS_DEFAULT(InitialHeapSize)) {
                    reasonable_max = MAX2(reasonable_max, (julong)InitialHeapSize);
                }

                // max(物理内存/4, 96M)
                FLAG_SET_ERGO(uintx, MaxHeapSize, (uintx)reasonable_max);
            }

            if (InitialHeapSize == 0 || min_heap_size() == 0) {
                // 默认OldSize=4M
                // 默认NewSize=1M
                julong reasonable_minimum = (julong)(OldSize + NewSize);
                reasonable_minimum = MIN2(reasonable_minimum, (julong)MaxHeapSize);

                julong reasonable_initial = (julong)((phys_mem * 1.5625) / 100);

                reasonable_initial = MAX3(reasonable_initial, reasonable_minimum, (julong)min_heap_size());
                reasonable_initial = MIN2(reasonable_initial, (julong)MaxHeapSize);

                // min(phys_mem * 1.5625%, MaxHeapSize)
                FLAG_SET_ERGO(uintx, InitialHeapSize, (uintx)reasonable_initial);
            }
        }
    }

    init_globals();
    {
        universe_init();
        {
            Universe::initialize_heap();
            {
                if (UseParallelGC) {
                    Universe::_collectedHeap = new ParallelScavengeHeap();
                } else if (UseG1GC) {
                    G1CollectorPolicyExt* g1p = new G1CollectorPolicyExt();
                    g1p->initialize_all();
                    Universe::_collectedHeap = new G1CollectedHeap(g1p);
                } else {
                    // 忽略UseSerialGC和UseConcMarkSweepGC
                    if (UseSerialGC) {
                        gc_policy = new MarkSweepPolicy();
                    } else if (UseConcMarkSweepGC) {

                    } else {
                        // 2核2G以下默认同UseSerialGC
                        gc_policy = new MarkSweepPolicy();
                    }

                    gc_policy->initialize_all();

                    Universe::_collectedHeap = new GenCollectedHeap(gc_policy);
                }

                // 初始化
                Universe::heap()->initialize();
            }
        }
    }
}

```

## CollectedHeap接口

```c++

class CollectedHeap {

    // 初始化
    virtual jint initialize() = 0;
    virtual void post_initialize() = 0;

    // 内存分配：核心接口，heap是为了分配内存而生
    virtual HeapWord* allocate_new_tlab(size_t size);
    virtual HeapWord* mem_allocate(size_t size, bool* gc_overhead_limit_was_exceeded) = 0;

    // 主动gc相关
    virtual void collect(GCCause::Cause cause) = 0;
    virtual void do_full_collection(bool clear_all_soft_refs) = 0;

    // heap枚举
    virtual void oop_iterate(ExtendedOopClosure* cl) = 0;
    virtual void object_iterate(ObjectClosure* cl) = 0;

    // 常用inline static工具方法
    inline static HeapWord* allocate_from_tlab(KlassHandle klass, Thread* thread, size_t size)
    {
        // 指针碰撞
        HeapWord* obj = thread->tlab().allocate(size);
        if (obj != NULL) {
            return obj;
        }

        return allocate_from_tlab_slow(klass, thread, size);
        {
            // tlab还剩很多，跳过tlab从heap里分配
            if (thread->tlab().free() > thread->tlab().refill_waste_limit()) {
                thread->tlab().record_slow_allocation(size);
                return NULL;
            }

            // 生成新的tlab并从tlab分配
            HeapWord* obj = Universe::heap()->allocate_new_tlab(new_tlab_size);
            thread->tlab().fill(obj, obj + size, new_tlab_size);
            return obj;
        }
    }

    inline static oop obj_allocate(KlassHandle klass, int size, TRAPS)
    {
        HeapWord* obj = common_mem_allocate_init(klass, size, CHECK_NULL);
        {
            // 为指定类的实例分配内存
            HeapWord* obj = common_mem_allocate_noinit(klass, size, CHECK_NULL);
            {
                // 先尝试tlab
                result = allocate_from_tlab(klass, THREAD, size);
                if (result != NULL) {
                    return result;
                }

                // 直接从heap里分配
                result = Universe::heap()->mem_allocate(size, &gc_overhead_limit_was_exceeded);
                if (result != NULL) {
                    return result;
                }

                if (!gc_overhead_limit_was_exceeded) {
                    // heap空间不足
                    report_java_out_of_memory("Java heap space");
                } else {
                    // 尝试了太多次
                    report_java_out_of_memory("GC overhead limit exceeded");
                }
            }

            init_obj(obj, size);
            {
                const size_t hs = oopDesc::header_size();
                // header之后用0填充
                Copy::fill_to_aligned_words(obj + hs, size - hs);
            }

            return obj;
        }

        post_allocation_setup_obj(klass, obj, size);
        {
            // 指定class初始化自己的实例
            post_allocation_setup_common(klass, obj_ptr);
            {
                post_allocation_setup_no_klass_install(klass, obj_ptr);
                {
                    oop obj = (oop)obj_ptr;
                    if (UseBiasedLocking && (klass() != NULL)) {
                        obj->set_mark(klass->prototype_header());
                    } else {
                        // 设置默认对象头
                        obj->set_mark(markOopDesc::prototype());
                    }
                }

                // 设置对象头中的class
                obj->release_set_klass(klass());
            }
        }

        return (oop)obj;
    }

    inline static oop array_allocate(KlassHandle klass, int size, int length, TRAPS)
    {
        HeapWord* obj = common_mem_allocate_init(klass, size, CHECK_NULL);
        post_allocation_setup_array(klass, obj, length);
        {
            post_allocation_setup_common(klass, obj_ptr);
        }

        return (oop)obj;
    }
}

class CollectorPolicy {

    virtual void initialize_alignments() = 0;
    virtual void initialize_flags();
    virtual void initialize_size_info();

    size_t _initial_heap_byte_size;
    size_t _max_heap_byte_size;
    size_t _min_heap_byte_size;

    size_t _space_alignment;
    size_t _heap_alignment;

    virtual void initialize_all() {
        initialize_alignments();
        initialize_flags();
        initialize_size_info();
    }

    virtual HeapWord* mem_allocate_work(size_t size,
                                        bool is_tlab,
                                        bool* gc_overhead_limit_was_exceeded) = 0;

}

```

## ParallelGC

### 初始化

初始化之后的heap的示意图，绿色表示已经申请了物理内存

![ps-heap](/assets/images/2023-03-27/ps-heap.png)

```c++

class ParallelScavengeHeap : public CollectedHeap {

    // 按默认行为
    jint ParallelScavengeHeap::initialize() {
        // 确定XxxNewSize、XxxOldSize、XxxHeapSize
        _collector_policy = new GenerationSizer();
        _collector_policy->initialize_all();
        {
            initialize_alignments();
            {
                // young和old之间的边界
                _space_alignment = _gen_alignment = 512 * K;

                // cardTable按page申请内存，cardTable的1字节标记heap的512字节
                _heap_alignment = compute_heap_alignment();
                {
                    return 512 * os::vm_page_size();
                }
            }

            initialize_flags();
            {
                TwoGenerationCollectorPolicy::initialize_flags();
                {
                    GenCollectorPolicy::initialize_flags();
                    {
                        CollectorPolicy::initialize_flags();
                        {
                            // InitialHeapSize和MaxHeapSize按_heap_alignment对齐
                            _min_heap_byte_size = align_size_up(_min_heap_byte_size, _heap_alignment);
                            FLAG_SET_ERGO(uintx, InitialHeapSize, align_size_up(InitialHeapSize, _heap_alignment));
                            FLAG_SET_ERGO(uintx, MaxHeapSize, align_size_up(MaxHeapSize, _heap_alignment));
                            _initial_heap_byte_size = InitialHeapSize;
                            _max_heap_byte_size = MaxHeapSize;
                        }

                        // 计算NewSize = max(NewSize, 3 * _space_alignment)

                        // 最小的young: eden + two survivors
                        uintx smallest_new_size = align_size_up(3 * _space_alignment, _gen_alignment);
                        // 最小的heap = smallest_new_size + old
                        uintx smallest_heap_size = align_size_up(smallest_new_size + _space_alignment, _heap_alignment);
                    
                        NewSize =  MAX2(smallest_new_size, (uintx)align_size_down(NewSize, _gen_alignment));
                        _initial_gen0_size = NewSize;
                    }

                    // 调节NewSize、OldSize、MaxHeapSize的关系
                    if (NewSize + OldSize > MaxHeapSize) {
                        if (_max_heap_size_cmdline) {
                            // 如果指定了MaxHeapSize则按比例减少NewSize和OldSize
                            uintx calculated_size = NewSize + OldSize;
                            double shrink_factor = (double) MaxHeapSize / calculated_size;
                            uintx smaller_new_size = align_size_down((uintx)(NewSize * shrink_factor), _gen_alignment);
                            FLAG_SET_ERGO(uintx, NewSize, MAX2(young_gen_size_lower_bound(), smaller_new_size));
                            FLAG_SET_ERGO(uintx, OldSize, MaxHeapSize - NewSize);
                        } else {
                            // 未指定MaxHeapSize则增加MaxHeapSize
                            FLAG_SET_ERGO(uintx, MaxHeapSize, align_size_up(NewSize + OldSize, _heap_alignment));
                            _max_heap_byte_size = MaxHeapSize;
                        }
                    }
                }                
            }

            initialize_size_info();
            {
                TwoGenerationCollectorPolicy::initialize_size_info();
                {
                    GenCollectorPolicy::initialize_size_info();
                    {
                        // 根据NewRatio和XxxHeapSize计算XxxNewSize
                        max_new_size = scale_by_NewRatio_aligned(_max_heap_byte_size);
                        _min_gen0_size = MAX2(scale_by_NewRatio_aligned(_min_heap_byte_size), NewSize);
                        desired_new_size = MAX2(scale_by_NewRatio_aligned(_initial_heap_byte_size), NewSize);
                    }

                    // 根据XxxNewSize和XxxHeapSize计算XxxOldSize
                    _max_gen1_size = MAX2(_max_heap_byte_size - _max_gen0_size, _gen_alignment);
                    _min_gen1_size = MAX2(_min_heap_byte_size - _min_gen0_size, _gen_alignment);
                    _initial_gen1_size = MAX2(_initial_heap_byte_size - _initial_gen0_size, _gen_alignment);
                    FLAG_SET_ERGO(uintx, OldSize, _initial_gen1_size);
                }
            }
        }

        // 使用mmap按MaxHeapSize申请线性地址空间
        const size_t heap_size = _collector_policy->max_heap_byte_size();
        ReservedSpace heap_rs = Universe::reserve_heap(heap_size, _collector_policy->heap_alignment());
        {
            // 默认不限制heap线性地址，选择UseCompressedOops时选择较大的base可以空出地址中较高的bit
            char* addr = Universe::preferred_heap_base(total_reserved, alignment, Universe::UnscaledNarrowOop);
            base = os::reserve_memory(size, NULL, alignment);
            {
                flags = MAP_PRIVATE | MAP_NORESERVE | MAP_ANONYMOUS;
                addr = (char*)::mmap(requested_addr, bytes, PROT_NONE, flags, ...);
            }
        }

        // 线性地址空间范围
        _reserved = MemRegion((HeapWord*)heap_rs.base(),
                              (HeapWord*)(heap_rs.base() + heap_rs.size()));

        // 创建cardTable: 覆盖2个region: young, old
        CardTableExtension* const barrier_set = new CardTableExtension(_reserved, 3);
        {
            _covered = new MemRegion[_max_covered_regions];
        }

        barrier_set->initialize();
        {
            // 每个card占1字节对应heap的512字节，计算需要的card数量
            _guard_index = cards_required(_whole_heap.word_size()) - 1;
            _last_valid_index = _guard_index - 1;

            // card按page取整
            _byte_map_size = compute_byte_map_size();

            // 使用mmap为cardTable申请线性地址
            ReservedSpace heap_rs(_byte_map_size, rs_align, false);

            _byte_map = (jbyte*) heap_rs.base();
            // 为方便计算byte_map_base表示从0开始card，实际[0, low_bound]之间是空的
            byte_map_base = _byte_map - (uintptr_t(low_bound) >> card_shift);

            // cardTable最后一个page
            byte* guard_card = &_byte_map[_guard_index];
            uintptr_t guard_page = align_size_down((uintptr_t)guard_card, _page_size);
            _guard_region = MemRegion((HeapWord*)guard_page, _page_size);
            // 为cardTable的最后一个page申请物理内存
            os::commit_memory_or_exit((char*)guard_page, _page_size, _page_size, ...);
        }

        _barrier_set = barrier_set;
        oopDesc::set_bs(_barrier_set);

        // 把heap分成old和young两部分
        _gens = new AdjoiningGenerations(heap_rs, _collector_policy, generation_alignment());
        {
            _virtual_spaces(old_young_rs, policy->min_gen1_size(), policy->min_gen0_size(), alignment);
            size_t init_low_byte_size = policy->initial_gen1_size();
            size_t min_low_byte_size = policy->min_gen1_size();
            size_t max_low_byte_size = policy->max_gen1_size();
            size_t init_high_byte_size = policy->initial_gen0_size();
            size_t min_high_byte_size = policy->min_gen0_size();
            size_t max_high_byte_size = policy->max_gen0_size();
            
            // 整个heap分成MaxOldSize和MaxNewSize两部分
            ReservedSpace old_rs = virtual_spaces()->reserved_space().first_part(max_low_byte_size);
            ReservedSpace heap_rs = virtual_spaces()->reserved_space().last_part(max_low_byte_size);
            ReservedSpace young_rs = heap_rs.first_part(max_high_byte_size);

            _young_gen = new PSYoungGen(init_high_byte_size,
                                        min_high_byte_size,
                                        max_high_byte_size);
            _old_gen = new PSOldGen(init_low_byte_size,
                                    min_low_byte_size,
                                    max_low_byte_size,
                                    "old", 1);

            _young_gen->initialize(young_rs, alignment);
            {
                initialize_virtual_space(rs, alignment);
                {
                    _virtual_space = new PSVirtualSpace(rs, alignment);
                    // 申请物理内存
                    virtual_space()->expand_by(_init_gen_size);
                }

                initialize_work();
                {
                    // 整个线性地址空间
                    _reserved = MemRegion((HeapWord*)virtual_space()->low_boundary(),
                                          (HeapWord*)virtual_space()->high_boundary());

                    // commited的线性地址空间
                    MemRegion cmr((HeapWord*)virtual_space()->low(),
                                  (HeapWord*)virtual_space()->high());
                    
                    // 为覆盖此区域的cardTable分配内存
                    Universe::heap()->barrier_set()->resize_covered_region(cmr);

                    _eden_space = new MutableSpace(virtual_space()->alignment());
                    _from_space = new MutableSpace(virtual_space()->alignment());
                    _to_space   = new MutableSpace(virtual_space()->alignment());

                    // 线性地址空间按比例计算eden和survivor的大小
                    max_survivor_size = size / InitialSurvivorRatio;
                    max_eden_size = size - 2 * max_survivor_size;

                    compute_initial_space_boundaries();
                    {
                        size_t size = virtual_space()->committed_size();


                        set_space_boundaries(eden_size, survivor_size);
                        {
                            // commited地址按eden/to/from的顺序排列
                            char *eden_start = virtual_space()->low();
                            char *to_start   = eden_start + eden_size;
                            char *from_start = to_start   + survivor_size;
                            char *from_end   = from_start + survivor_size;

                            MemRegion eden_mr((HeapWord*)eden_start, (HeapWord*)to_start);
                            MemRegion to_mr  ((HeapWord*)to_start, (HeapWord*)from_start);
                            MemRegion from_mr((HeapWord*)from_start, (HeapWord*)from_end);

                            eden_space()->initialize(eden_mr, true, ZapUnusedHeapArea);
                              to_space()->initialize(to_mr  , true, ZapUnusedHeapArea);
                            from_space()->initialize(from_mr, true, ZapUnusedHeapArea);
                        }
                    }
                }
            }

            _old_gen->initialize(old_rs, alignment, "old", 1);
            {
                initialize_virtual_space(rs, alignment);
                {
                    _virtual_space = new PSVirtualSpace(rs, alignment);
                    _virtual_space->expand_by(_init_gen_size);
                }

                initialize_work(perf_data_name, level);
                {
                    // 整个线性地址空间
                    MemRegion limit_reserved((HeapWord*)virtual_space()->low_boundary(), heap_word_size(_max_gen_size));
                    // 稀疏索引记录对象相对于block的offset: ((char*)obj_ptr - (char*)block_start) / 8
                    start_array()->initialize(limit_reserved);

                    // 已经commited的线性地址
                    MemRegion cmr((HeapWord*)virtual_space()->low(),
                                  (HeapWord*)virtual_space()->high());

                    // 为对应的cardTable申请内存
                    Universe::heap()->barrier_set()->resize_covered_region(cmr);

                    // 储存对象
                    _object_space = new MutableSpace(virtual_space()->alignment());
                    object_space()->initialize(cmr, ...);

                    start_array()->set_covered_region(cmr);
                }
            }
        }

        _old_gen = _gens->old_gen();
        _young_gen = _gens->young_gen();

        // 根据暂停时间收集信息动态调整heap的大小
        _size_policy = new PSAdaptiveSizePolicy(eden_capacity, initial_promo_size, ...);

        // 创建用于gc的线程池
        _gc_task_manager = GCTaskManager::create(ParallelGCThreads);
        {
            initialize();
            {
                // 创建任务队列
                GCTaskQueue* unsynchronized_queue = GCTaskQueue::create_on_c_heap();
                _queue = SynchronizedGCTaskQueue::create(unsynchronized_queue, lock());

                // 创建线程池
                _thread = NEW_C_HEAP_ARRAY(GCTaskThread*, workers(), mtGC);
                for (uint t = 0; t < workers(); t += 1) {
                    set_thread(t, GCTaskThread::create(this, t, processor_assignment[t]));
                }
            }
        }

        // 并行整理gc算法初始化
        PSParallelCompact::initialize();
        {
            MemRegion mr = heap->reserved_region();

            _mark_bitmap.initialize(mr);
            {
                // 一个bit标记8个字节
                const idx_t bits = bits_required(covered_region);
                const size_t words = bits / BitsPerWord;
                const size_t raw_bytes = words * sizeof(idx_t);
                _reserved_byte_size = align_size_up(raw_bytes, MAX2(page_sz, granularity));
                // 申请线性地址
                ReservedSpace rs(_reserved_byte_size, rs_align, rs_align > 0);
                _virtual_space = new PSVirtualSpace(rs, page_sz);
                // 申请物理内存
                _virtual_space->expand_by(_reserved_byte_size);
            }

            _summary_data.initialize(mr);
            {
                const size_t region_size = covered_region.word_size();
                initialize_region_data(region_size);
                {
                    // 使用一个RegionData描述一个512k的region，用于full-gc时并行整理
                    const size_t count = (region_size + RegionSizeOffsetMask) >> Log2RegionSize;
                    _region_vspace = create_vspace(count, sizeof(RegionData));
                }

                initialize_block_data();
                {
                    // 使用一个BlockData描述一个1k字节的block内第一个存活对象的目标地址
                    const size_t count = _region_count << Log2BlocksPerRegion;
                    _block_vspace = create_vspace(count, sizeof(BlockData));
                }
            }
        }
    }

    void ParallelScavengeHeap::post_initialize() {
        PSScavenge::initialize();
        {
            // 确当晋升阈值
            _tenuring_threshold = 7;
        }

        if (UseParallelOldGC) {
            PSParallelCompact::post_initialize();
            {
                ParCompactionManager::initialize(mark_bitmap());
                {
                    // 多出的一个给VmThread用
                    _manager_array = NEW_C_HEAP_ARRAY(ParCompactionManager*, parallel_gc_threads + 1, mtGC);

                    _region_list = NEW_C_HEAP_ARRAY(RegionTaskQueue*, parallel_gc_threads + 1, mtGC);

                    _recycled_stack_index = NEW_C_HEAP_ARRAY(uint, parallel_gc_threads, mtGC);

                    for(uint i=0; i < parallel_gc_threads + 1; i++) {
                        _region_list[i] = new RegionTaskQueue();
                        region_list(i)->initialize();
                    }

                    _stack_array = new OopTaskQueueSet(parallel_gc_threads);
                    _objarray_queues = new ObjArrayTaskQueueSet(parallel_gc_threads);
                    _region_array = new RegionTaskQueueSet(parallel_gc_threads);

                    for(uint i=0; i < parallel_gc_threads; i++) {
                        _manager_array[i] = new ParCompactionManager();
                        _stack_array->register_queue(i, _manager_array[i]->marking_stack());
                        _objarray_queues->register_queue(i, &_manager_array[i]->_objarray_stack);
                        _region_array->register_queue(i, region_list(i));
                    }

                    _manager_array[parallel_gc_threads] = new ParCompactionManager();
                }
            }
        } else {
            PSMarkSweep::initialize();
        }

        PSPromotionManager::initialize();
        {
            // 多出的一个用于平衡工作量
            _manager_array = PaddedArray<...>::create_unfreeable(ParallelGCThreads + 1);

            _stack_array_depth = new OopStarTaskQueueSet(ParallelGCThreads);
            for(uint i=0; i<ParallelGCThreads; i++) {
                stack_array_depth()->register_queue(i, _manager_array[i].claimed_stack_depth());
            }
        }
    }
}

```

### 内存分配

分配`tlab`

```c++
HeapWord* ParallelScavengeHeap::allocate_new_tlab(size_t size) {
  return young_gen()->allocate(size);
  {
    return eden_space()->cas_allocate(word_size);
    {
        // 基于cas的指针碰撞从eden分配
        do {
            HeapWord* obj = (HeapWord*)OrderAccess::load_ptr_acquire(top_addr());
            if (pointer_delta(end(), obj) >= size) {
                HeapWord* new_top = obj + size;
                HeapWord* result = (HeapWord*)Atomic::cmpxchg_ptr(new_top, top_addr(), obj);
                if (result != obj) {
                    continue;
                }
                return obj;
            } else {
                return NULL;
            }
        } while (true);
    }
  }
}
```

从heap中分配

```c++
HeapWord* ParallelScavengeHeap::mem_allocate(size_t size,
                                             bool* gc_overhead_limit_was_exceeded) {
    *gc_overhead_limit_was_exceeded = false;

    // 从eden分配内存
    HeapWord* result = young_gen()->allocate(size);
    {
        result = eden_space()->cas_allocate(word_size);
    }

    while (result == NULL) {
        // 加锁
        MutexLocker ml(Heap_lock);

        // 再次尝试eden
        result = young_gen()->allocate(size);
        if (result != NULL) {
            return result;
        }

        // 尝试从old分配
        result = mem_allocate_old_gen(size);
        {
            return old_gen()->allocate(size);
            {
                HeapWord* res = allocate_noexpand(word_size);
                {
                    // 指针碰撞
                    HeapWord* res = object_space()->allocate(word_size);
                    if (res != NULL) {
                        // 记录每个512的block内最后一个对象的块内offset
                        _start_array.allocate_block(res);
                    }
                    return res;
                }

                 if (res == NULL) {
                    res = expand_and_allocate(word_size);
                    {
                        expand(word_size*HeapWordSize);
                        {
                            // 至少扩展128k
                            size_t aligned_expand_bytes = align_size_up(MinHeapDeltaBytes, alignment);
                            expand_by(aligned_expand_bytes);
                            {
                                // commit线性内存
                                virtual_space()->expand_by(bytes);
                            }
                        }

                        return allocate_noexpand(word_size);
                    }
                }
                return res;
            }
        }

        if (result != NULL) {
            return result;
        }

        // 连续经历了3次gc依然失败
        if (gclocker_stalled_count > GCLockerRetryAllocationCount) {
            return NULL;
        }

        // 别的线程触发gc，当前线程应该尽快进入safepoint
        if (GC_locker::is_active_and_needs_gc()) {
            JavaThread* jthr = JavaThread::current();
            if (!jthr->in_critical()) {
                MutexUnlocker mul(Heap_lock);
                // 等待gc结束
                GC_locker::stall_until_clear();
                {
                    while (needs_gc()) {
                        JNICritical_lock->wait();
                    }
                }
                gclocker_stalled_count += 1;
                continue;
            }
        }


        if (result == NULL) {
            VM_ParallelGCFailedAllocation op(size, gc_count);
            {
                _result = heap->failed_mem_allocate(_word_size);
                {
                    // young-gc
                    const bool invoked_full_gc = PSScavenge::invoke();
                    HeapWord* result = young_gen()->allocate(size);

                    if (result == NULL && !invoked_full_gc) {
                        // full-gc不回收引用
                        do_full_collection(false);
                        // 从eden分配
                        result = young_gen()->allocate(size);
                    }

                    if (result == NULL) {
                        // 从old分配
                        result = old_gen()->allocate(size);
                    }

                    if (result == NULL) {
                        // full-gc回收引用
                        do_full_collection(true);
                        // 从eden分配
                        result = young_gen()->allocate(size);
                    }

                    if (result == NULL) {
                        // 从old分配
                        result = old_gen()->allocate(size);
                    }

                    return result;
                }
            }

            VMThread::execute(&op);

            // oom
            if (limit_exceeded && softrefs_clear) {
                *gc_overhead_limit_was_exceeded = true;
                size_policy()->set_gc_overhead_limit_exceeded(false);
                if (op.result() != NULL) {
                    CollectedHeap::fill_with_object(op.result(), size);
                }
                return NULL;
            }

            return op.result();
        }
    }                                         
}
```

young-gc

```c++
bool PSScavenge::invoke() {

    PSScavenge::invoke_no_policy();
    {
        // 准备工作

        // tlab空闲内存填充空对象
        heap->ensure_parsability(true);

        // 清空to_space
        young_gen->to_space()->clear(SpaceDecorator::Mangle);

        // 初始化gc_task_manager
        gc_task_manager()->release_all_resources();
        gc_task_manager()->set_active_gang();
        gc_task_manager()->task_idle_workers();
        uint active_workers = gc_task_manager()->active_workers();
        heap->set_par_threads(active_workers);

        GCTaskQueue* q = GCTaskQueue::create();

        // 多线程并发处理跨代引用
        uint stripe_total = active_workers;
        for(uint i=0; i < stripe_total; i++) {
            q->enqueue(new OldToYoungRootsTask(old_gen, old_top, i, stripe_total));
            {
                card_table->scavenge_contents_parallel(...);
                {
                    int ssize = 128;
                    jbyte* start_card = byte_for(sp->bottom());
                    jbyte* end_card   = byte_for(sp_top - 1) + 1;
                    size_t slice_width = ssize * stripe_total;
                    // 多线程扫描cardTable, card=dirty表示上次gc之后引用发生了变化
                    for (jbyte* slice = start_card; slice < end_card; slice += slice_width) {
                        jbyte* worker_start_card = slice + stripe_number * ssize;
                        jbyte* worker_end_card = worker_start_card + ssize;
                        jbyte* current_card = worker_start_card;

                        // 扫描当前128个card范围内的对象
                        while (current_card < worker_end_card) {
                            oop* p = (oop*) start_array->object_start(addr_for(first_unclean_card));
                            oop* to = (oop*)addr_for(following_clean_card);
                            while (p < to) {
                                oop m = oop(p);
                                m->push_contents(pm);
                                {
                                    klass()->oop_push_contents(pm, this);
                                    {
                                        res = PSScavenge::should_scavenge(p);
                                        {
                                            T heap_oop = oopDesc::load_heap_oop(p);
                                            return PSScavenge::is_obj_in_young(heap_oop);
                                        }

                                        if (res) {
                                            pm->claim_or_forward_depth(p);
                                            {
                                                oop o = oopDesc::load_decode_heap_oop_not_null(p);
                                                if (o->is_forwarded()) {
                                                    // 对象已经被处理，更新引用指向新地址
                                                    o = o->forwardee();
                                                    oopDesc::encode_store_heap_oop_not_null(p, o)
                                                } else {
                                                    // 加入pm的stack
                                                    push_depth(p);
                                                }
                                            }
                                        }
                                    }
                                }

                                p += m->size();
                            }

                            pm->drain_stacks_cond_depth();
                            {
                                // 递归处理所有收集到的存活的young代对象
                                process_popped_location_depth(p);
                                {
                                    PSScavenge::copy_and_push_safe_barrier<oop, false>(this, p);
                                    {
                                        if (! o->is_forwarded()) {
                                            pm->copy_to_survivor_space<promote_immediately>(o);
                                            {
                                                markOop test_mark = o->mark();
                                                uint age = test_mark->age();
                                                if (age < PSScavenge::tenuring_threshold()) {
                                                    // 没到晋升阀值直接复制到to_space
                                                    new_obj = (oop) _young_lab.allocate(new_obj_size);
                                                }

                                                // 晋升或to_space满了则从old分配内存
                                                if (new_obj == NULL) {
                                                    new_obj = (oop) _old_lab.allocate(new_obj_size);
                                                    new_obj_is_tenured = true;
                                                }

                                                // 晋升失败必须等待full-gc
                                                if (new_obj == NULL) {
                                                    _old_gen_is_full = true;
                                                    return oop_promotion_failed(o, test_mark);
                                                }

                                                // 复制数据
                                                Copy::aligned_disjoint_words((HeapWord*)o, (HeapWord*)new_obj, new_obj_size);

                                                // 标记已处理
                                                if (o->cas_forward_to(new_obj, test_mark)) {
                                                    // 递归处理
                                                    new_obj->push_contents(this);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        // 收集10类root，同上递归处理
        q->enqueue(new ScavengeRootsTask(ScavengeRootsTask::universe));
        q->enqueue(new ScavengeRootsTask(ScavengeRootsTask::jni_handles));
        // 所有java线程和VMThread线程遍历栈帧
        Threads::create_thread_roots_tasks(q);
        q->enqueue(new ScavengeRootsTask(ScavengeRootsTask::object_synchronizer));
        q->enqueue(new ScavengeRootsTask(ScavengeRootsTask::flat_profiler));
        q->enqueue(new ScavengeRootsTask(ScavengeRootsTask::management));
        q->enqueue(new ScavengeRootsTask(ScavengeRootsTask::system_dictionary));
        q->enqueue(new ScavengeRootsTask(ScavengeRootsTask::class_loader_data));
        q->enqueue(new ScavengeRootsTask(ScavengeRootsTask::jvmti));
        q->enqueue(new ScavengeRootsTask(ScavengeRootsTask::code_cache));

        // 工作量均衡: 跑的快的帮助跑的慢的
        ParallelTaskTerminator terminator(active_workers,
                    (TaskQueueSetSuper*) promotion_manager->stack_array_depth());
        for (uint j = 0; j < active_workers; j++) {
            q->enqueue(new StealTask(&terminator));
        }

        gc_task_manager()->execute_and_wait(q);

        // 清理字符串表
        PSScavengeRootsClosure root_closure(promotion_manager);
        StringTable::unlink_or_oops_do(&_is_alive_closure, &root_closure);

        // 出现过晋升失败则必须fullGc
        promotion_failure_occurred = PSPromotionManager::post_scavenge(_gc_tracer);
        if (! promotion_failure_occurred) {
            // 根据数据统计调整参数
        }

    }

}
```

full-gc

算法描述：

![ps-region](/assets/images/2023-03-27/ps-region.png)

整个heap划分成512k的region，每个region有3个重要属性
1. dest_addr: 表示此region内第一个存活对象的目标地址
2. source_region: 表示第一个把对象头复制到此region的源region
3. dest_count: 表示此region的存活对象会复制到多少其他region中，取值0/1/2，0表示在region内compact

算法的过程如下：
1. 从root开始递归标记存活对象
2. 根据收集的数据计算每个region的3个属性
    * 上图中根据标记过程中产生的bitmap可以计算每个region的dest_addr
    * 上图中region-0的source_region=region-0, dest_count=0
    * 上图中region-1的source_region=region-2, dest_count=1
    * 上图中region-2的source_region=region-4, dest_count=2
3. 从root开始，更新引用的地址
4. 开始复制数据: 重点是如何分解为多个子问题并行处理
    * 从dest_count=0的region开始处理，即region-0
    * region-0的数据复制完毕后，继续处理region-0的后续region
    * region-1数据复制完毕后，dest_count减一变成0表示region-1的数据复制完毕
    * region-2的数据复制到region-1时放不下，能放多少放多少，dest_count减一变成1表示region-2的数据未复制完
    * 此时region-1的dest_count==0，每个dest_count==0的region都可以并行处理
    * 照此逻辑直到所有存活数据复制完毕

```c++
bool PSParallelCompact::invoke_no_policy(bool maximum_heap_compaction) {
    // 准备工作
    pre_compact(&pre_gc_values);
    {
        heap->ensure_parsability(true);
    }

    gc_task_manager()->set_active_gang();
    gc_task_manager()->task_idle_workers();
    heap->set_par_threads(gc_task_manager()->active_workers());

    // 从root开始递归标记
    marking_phase(...);
    {
        GCTaskQueue* q = GCTaskQueue::create();

        // 从10类root开始递归标记
        q->enqueue(new MarkFromRootsTask(MarkFromRootsTask::universe));
        q->enqueue(new MarkFromRootsTask(MarkFromRootsTask::jni_handles));
        Threads::create_thread_roots_marking_tasks(q);
        q->enqueue(new MarkFromRootsTask(MarkFromRootsTask::object_synchronizer));
        q->enqueue(new MarkFromRootsTask(MarkFromRootsTask::flat_profiler));
        q->enqueue(new MarkFromRootsTask(MarkFromRootsTask::management));
        q->enqueue(new MarkFromRootsTask(MarkFromRootsTask::system_dictionary));
        q->enqueue(new MarkFromRootsTask(MarkFromRootsTask::class_loader_data));
        q->enqueue(new MarkFromRootsTask(MarkFromRootsTask::jvmti));
        q->enqueue(new MarkFromRootsTask(MarkFromRootsTask::code_cache));
        {
            PSParallelCompact::MarkAndPushClosure mark_and_push_closure(cm);
            {
                mark_and_push(_compaction_manager, p);
                {
                    T heap_oop = oopDesc::load_heap_oop(p);
                    if (!oopDesc::is_null(heap_oop)) {
                        oop obj = oopDesc::decode_heap_oop_not_null(heap_oop);
                        if (mark_bitmap()->is_unmarked(obj)) {
                            res = mark_obj(obj);
                            {
                                if (mark_bitmap()->mark_obj(obj, obj_size)) {
                                    _summary_data.add_obj(obj, obj_size);
                                    {
                                         if (beg_region == end_region) {
                                            _region_data[beg_region].add_live_obj(len);
                                            return;
                                        }

                                        // Middle regions--completely spanned by this object.
                                        for (size_t region = beg_region + 1; region < end_region; ++region) {
                                            // 指定region开头的一个部分对象的header和长度
                                            _region_data[region].set_partial_obj_size(RegionSize);
                                            _region_data[region].set_partial_obj_addr(addr);
                                        }

                                        // Last region.
                                        const size_t end_ofs = region_offset(addr + len - 1);
                                        // 指定region开头的一个部分对象的header和长度
                                        _region_data[end_region].set_partial_obj_size(end_ofs + 1);
                                        _region_data[end_region].set_partial_obj_addr(addr);
                                    }

                                    return true;
                                }
                            }

                            if (res) {
                                cm->push(obj);
                            }
                        }
                    }
                }
            }

            Threads::oops_do(&mark_and_push_closure, ...);

            // 递归标记
            cm->follow_marking_stacks();
            {
                // 标记oop的class对象
                PSParallelCompact::follow_klass(cm, obj->klass());
                PSParallelCompact::mark_and_push(cm, p);
            }
        }

        // 平衡工作量
        for (uint j = 0; j < active_gc_threads; j++) {
            q->enqueue(new StealMarkingTask(&terminator));
        }

        gc_task_manager()->execute_and_wait(q);

        SystemDictionary::do_unloading(is_alive_closure());
        CodeCache::do_unloading(is_alive_closure(), purged_class);
        Klass::clean_weak_klass_links(is_alive_closure());
        StringTable::unlink(is_alive_closure());
        SymbolTable::unlink();
    }

    // 汇总数据
    summary_phase(...);
    {
        // 分别计算old/eden/from/to内的对象存活情况
        summarize_spaces_quick();
        {
            for (unsigned int i = 0; i < last_space_id; ++i) {
                // 把space内的存活对象compact到space的开头
                // 以512k的region为单位，计算每个region的dest_addr和source_region
                _summary_data.summarize(..., 
                                        space->bottom(), space->top(), NULL,
                                        space->bottom(), space->end(), nta);
                {
                    size_t cur_region = addr_to_region_idx(source_beg);
                    const size_t end_region = addr_to_region_idx(region_align_up(source_end));

                    HeapWord *dest_addr = target_beg;
                    while (cur_region < end_region) {
                        // 设置region内第一个存活对象的目标复制地址
                        _region_data[cur_region].set_destination(dest_addr);

                        // 此变量表示一个region内的存活数据需要复制到除自己外的region的数量
                        // 用于控制并发：0表示只复制到自己，1表示需要复制到另一个不同的region
                        //              2表示要复制到两个连续的region
                        uint destination_count = 0;

                        HeapWord* const last_addr = dest_addr + words - 1;
                        const size_t dest_region_1 = addr_to_region_idx(dest_addr);
                        const size_t dest_region_2 = addr_to_region_idx(last_addr);

                        // 只复制到自己count=0，正常只有old的前几个区域可能是这样
                        destination_count += cur_region == dest_region_2 ? 0 : 1;
                        if (dest_region_1 != dest_region_2) {
                            // 跨越region
                            destination_count += 1;
                            _region_data[dest_region_2].set_source_region(cur_region);
                        } else if (region_offset(dest_addr) == 0) {
                            _region_data[dest_region_1].set_source_region(cur_region);
                        }

                        _region_data[cur_region].set_destination_count(destination_count);
                        ++cur_region;
                    }
                }

                _space_info[i].set_dense_prefix(space->bottom());
            }
        }

        // old已经反复compact，前半部分垃圾率很低，在允许范围内跳过回收
        summarize_space(old_space_id, maximum_compaction);
        {
            HeapWord* dense_prefix_end = compute_dense_prefix(id, maximum_compaction);
            {
                // 查找第一个有垃圾对象的region
                const RegionData* const full_cp = first_dead_space_region(beg_cp, new_top_cp);
                // 计算存活对象密度
                const double density = double(space_live) / double(space_capacity);
                // 允许最多5%的垃圾不回收
                const size_t min_percent_free = MarkSweepDeadRatio;
                // 利用正态分布预估多少个region包含5%的垃圾
                const double limiter = dead_wood_limiter(density, min_percent_free);
                const size_t dead_wood_max = space_used - space_live;
                const size_t dead_wood_limit = MIN2(size_t(space_capacity * limiter), dead_wood_max);
                const RegionData* const limit_cp = dead_wood_limit_region(full_cp, top_cp, dead_wood_limit);

                double best_ratio = 0.0;
                const RegionData* best_cp = full_cp;
                for (const RegionData* cp = full_cp; cp < limit_cp; ++cp) {
                    // 计算第一个有垃圾的region和limit之间最大回收率的位置
                    double tmp_ratio = reclaimed_ratio(cp, bottom, top, new_top);
                    if (tmp_ratio > best_ratio) {
                        best_cp = cp;
                        best_ratio = tmp_ratio;
                    }
                }

                return sd.region_to_addr(best_cp);
            }

            _space_info[id].set_dense_prefix(dense_prefix_end);
        }

        // 把eden/from的数据都挪到old
        SpaceId dst_space_id = old_space_id;
        for (unsigned int id = eden_space_id; id < last_space_id; ++id) {
            const size_t live = pointer_delta(_space_info[id].new_top(), space->bottom());
            const size_t available = pointer_delta(dst_space_end, *new_top_addr);

            if (live > 0 && live <= available) {
                // old放的下全放old，逻辑同上
                _summary_data.summarize(...);
            } else if (live > 0) {
                // old放不下：能放多少放多少
                _summary_data.summarize(...);

                // 剩余的原地compact
                _summary_data.summarize(...);
            }

        }
    }

    // 更新引用指向新地址
    adjust_roots();
    {
        Universe::oops_do(adjust_pointer_closure());
        {
            adjust_pointer(p);
            {
                // 计算gc之后的新地址
                oop new_obj = (oop)summary_data().calc_new_pointer(obj);
                {
                    RegionData* const region_ptr = addr_to_region_ptr(obj);
                    // 查找obj所在region的第一个存活对象的目标地址
                    HeapWord* result = region_ptr->destination();

                    // 计算region内每个block内第一个存活对象的目标位置，类似于稀疏索引
                    PSParallelCompact::fill_blocks(addr_to_region_idx(addr));

                    // block内第一个存活对象的offset
                    const size_t block_offset = addr_to_block_ptr(addr)->offset();
                    // 根据bitmap计算block内obj的offset
                    const ParMarkBitMap* bitmap = PSParallelCompact::mark_bitmap();
                    const size_t live = bitmap->live_words_in_range(block_align_down(addr), oop(addr));

                    result += block_offset + live;
                    return result;
                }

                // 更新引用
                oopDesc::encode_store_heap_oop_not_null(p, new_obj);
            }
        }

        JNIHandles::oops_do(adjust_pointer_closure());
        Threads::oops_do(adjust_pointer_closure(), ...);
        ObjectSynchronizer::oops_do(adjust_pointer_closure());
        FlatProfiler::oops_do(adjust_pointer_closure());
        Management::oops_do(adjust_pointer_closure());
        JvmtiExport::oops_do(adjust_pointer_closure());
        SystemDictionary::oops_do(adjust_pointer_closure());
        ClassLoaderDataGraph::oops_do(adjust_pointer_closure(), adjust_klass_closure(), true);
    }

    // 复制整理
    compact();
    {
        enqueue_region_draining_tasks(q, active_gc_threads);
        {
            for (uint j = 0; j < task_count; j++) {
                q->enqueue(new DrainStacksCompactionTask(j));
                {
                    cm->drain_region_stacks();
                    {
                        PSParallelCompact::fill_and_update_region(this, region_index);
                        {
                            MoveAndUpdateClosure closure(bitmap, cm, start_array, dest_addr, words);
                            {
                                if (destination() != source()) {
                                    // 复制数据
                                    Copy::aligned_conjoint_words(source(), destination(), words);
                                }

                                oop moved_oop = (oop) destination();
                                // 更新引用
                                moved_oop->update_contents(compaction_manager());
                            }

                            closure.set_source(first_src_addr(dest_addr, src_space_id, src_region_idx));

                            do {

                                HeapWord* const cur_addr = closure.source();
                                HeapWord* const end_addr = MIN2(sd.region_align_up(cur_addr + 1), src_space_top);
                                // 根据bitmap的指引复制存活数据
                                IterationStatus status = bitmap->iterate(&closure, cur_addr, end_addr);

                                // 重点: 控制线程安全
                                decrement_destination_counts(cm, src_space_id, src_region_idx, end_addr);
                                {
                                     for (RegionData* cur = beg; cur < end; ++cur) {
                                        // dest_count==0说明存活对象复制完毕
                                        cur->decrement_destination_count();
                                        // 已经复制完成的region可以被覆盖了
                                        if (cur < enqueue_end && cur->available() && cur->claim()) {
                                            // 放到stack上，空闲的线程可以帮忙处理
                                            cm->push_region(sd.region(cur));
                                        }
                                    }
                                }

                                src_region_idx = next_src_region(closure, src_space_id, src_space_top, end_addr);
                            } while (true);
                        }
                    }
                }
            }

            // 因为stack结构，所以倒着来
            for (unsigned int id = to_space_id; id + 1 > old_space_id; --id) {
                const size_t beg_region = sd.addr_to_region_idx(space_info->dense_prefix());
                const size_t end_region = sd.addr_to_region_idx(sd.region_align_up(new_top));
                for (size_t cur = end_region - 1; cur + 1 > beg_region; --cur) {
                    // 此处至关重要：第一批种子只能是dest_count=0的region，这样才能避免live数据在compact时被覆盖
                    if (sd.region(cur)->claim_unsafe()) {
                        ParCompactionManager::region_list_push(which++ % task_count, cur);
                    }
                }
            }
        }

        // old开头的部分垃圾少不需要移动
        enqueue_dense_prefix_tasks(q, active_gc_threads);
        {
            q->enqueue(new UpdateDensePrefixTask(SpaceId(space_id), region_index_start, region_index_end));
            {
                PSParallelCompact::update_and_deadwood_in_dense_prefix(...);
                {
                    // 活对象更新引用
                    UpdateOnlyClosure update_closure(mbm, cm, space_id);
                    // 死对象替换为空对象
                    FillClosure fill_closure(cm, space_id);
                    // 根据bitmap扫描对象
                    mark_bitmap()->iterate(&update_closure, &fill_closure, beg_addr, end_addr, dense_prefix_end);
                }
            }
        }

        // 平衡工作量
        enqueue_region_stealing_tasks(q, &terminator, active_gc_threads);
        {
            for (uint j = 0; j < parallel_gc_threads; j++) {
                q->enqueue(new StealRegionCompactionTask(terminator_ptr));
                {
                    size_t region_index = 0;
                    int random_seed = 17;

                    while(true) {
                        // 随机从别的gc线程上获取dest_count==0的region并行处理
                        if (ParCompactionManager::steal(which, &random_seed, region_index)) {
                            PSParallelCompact::fill_and_update_region(cm, region_index);
                            cm->drain_region_stacks();
                        } else {
                            if (terminator()->offer_termination()) {
                                break;
                            }
                        }
                    }
                }
            }
        }
    }

    post_compact();
}
```