---
layout: post
title:  "ast(2)"
date:   2024-05-25 07:49:07 +0000
categories: llvm
tags: llvm
---

# ast

书接上文，继续分析从`c11`源码转换为`AST`的过程

## 语法分析

此处只考虑`c11`的语法和语义

```c++

void Parser::Initialize() {
    // Sema的各种callback
    EnterScope(Scope::DeclScope);
    Actions.ActOnTranslationUnitScope(getCurScope());
    Actions.Initialize();

    // 通过preprocessor间接驱动lexer开始解析token
    ConsumeToken();
    {
        PP.Lex(Tok);
    }
}

/// Parse the first top-level declaration in a translation unit.
///
///       translation-unit:
///     [C]     external-declaration
///     [C]     translation-unit external-declaration
bool Parser::ParseFirstTopLevelDecl(DeclGroupPtrTy &Result, ...) {
    Actions.ActOnStartOfTranslationUnit();
    return ParseTopLevelDecl(Result, ...);
}

/// ParseTopLevelDecl - Parse one top-level declaration
/// top-level-declaration:
///   declaration
bool Parser::ParseTopLevelDecl(DeclGroupPtrTy &Result, ...) {
    Result = nullptr;
    // 第一个token在Initialize()获取
    switch (Tok.getKind()) {
    case ...
    case tok::eof:
        Actions.ActOnEndOfTranslationUnit();
        return true;
    case tok::identifier:
        // 旧版的c语言允许函数定义不指定返回值，默认int
        // func(int a) { return a * 2; }
        break;
    }

    // 解析__attribute((weak))等
    ParsedAttributes DeclSpecAttrs(AttrFactory);
    while (MaybeParseGNUAttributes(DeclSpecAttrs))
        ;

    // 解析外部声明
    Result = ParseExternalDeclaration(DeclAttrs, DeclSpecAttrs);
    return false;
}

/// external-declaration: [C99 6.9]
///   function-definition
///   declaration
Parser::DeclGroupPtrTy Parser::ParseExternalDeclaration(...) {
    Decl *SingleDecl = nullptr;
    switch (Tok.getKind()) {
    // 处理各种#pragma指令
    case tok::annot_pragma_xxx:
        HandlePragmaXxx();
        return nullptr;
    case tok::semi:
        // 单个分号生成空的decl
        SingleDecl = Actions.ActOnEmptyDeclaration(...);
        break;
    case tok::kw_asm: 
        // 解析嵌入式汇编
        ExprResult Result(ParseSimpleAsm(...));
        SingleDecl = Actions.ActOnFileScopeAsmDecl(Result.get(), ...);
        break;
    case tok::kw_typedef:
        return ParseDeclaration(...);
    case tok::kw_static:
        // 不确定后面是函数定义还是声明语句
        goto dont_know;
    case tok::kw_inline:
        goto dont_know;
    case tok::kw_extern:
        goto dont_know;
    default:
    // 不确定是声明语句还是函数定义
    dont_know:
        if (!SingleDecl)
            return ParseDeclarationOrFunctionDefinition(...);  
    }

    return Actions.ConvertDeclToDeclGroup(SingleDecl);
}

/// Parse either a function-definition or a declaration.  
/// We can't tell which we have until we read up to the compound-statement in function-definition.
/// 
///       function-definition: [C99 6.9.1]
///         decl-specs      declarator declaration-list[opt] compound-statement
///
///       declaration: [C99 6.7]
///         declaration-specifiers init-declarator-list[opt] ';'
Parser::DeclGroupPtrTy Parser::ParseDeclarationOrFunctionDefinition(..., ParsingDeclSpec &DS, ...) {
    /// 解析类型以及修饰符，例如以下语句`[]`内的部分
    /// [extent const int] a;
    /// [static const struct X] x;
    /// [struct X {int a}] x;
    /// [inline const int] func();
    /// [inline const int] func() {}
    /// 
    /// ParseDeclarationSpecifiers
    ///       declaration-specifiers: [C99 6.7]
    ///         storage-class-specifier declaration-specifiers[opt]
    ///         type-specifier declaration-specifiers[opt]
    /// [C99]   function-specifier declaration-specifiers[opt]
    /// [C11]   alignment-specifier declaration-specifiers[opt]
    ParseDeclarationSpecifiers(DS, ...);

    return ParseDeclGroup(DS, DeclaratorContext::File, Attrs);
    {
        // 存储解析的declarator
        ParsingDeclarator D(*this, DS, LocalAttrs, Context);
        // 解析标识符和函数形参
        ParseDeclarator(D);

        // 已解析到函数形参
        if (D.isFunctionDeclarator()) {
            if (!(
                Tok.is(tok::equal) ||           // int X()=  -> not a function def
                Tok.is(tok::comma) ||           // int X(),  -> not a function def
                Tok.is(tok::semi)  ||           // int X();  -> not a function def
                Tok.is(tok::kw_asm) ||          // int X() __asm__ -> not a function def
                Tok.is(tok::kw___attribute)     // int X() __attr__ -> not a function def
            )) {
                if (Context == DeclaratorContext::File) {
                    // 下一个token是`{`
                    if (isStartOfFunctionDefinition(D)) {
                        // 解析函数定义
                        Decl *TheDecl = ParseFunctionDefinition(D, ...);
                        return Actions.ConvertDeclToDeclGroup(TheDecl);
                    }

                    Diag(Tok, diag::err_expected_fn_body);
                    SkipUntil(tok::semi);
                    return nullptr;
                } else {
                    // 非最外层不允许定义函数
                    if (Tok.is(tok::l_brace)) {
                        Diag(Tok, diag::err_function_definition_not_allowed);
                        SkipMalformedDecl();
                        return nullptr;
                    }
                }
            }
        }

        ParseAsmAttributesAfterDeclarator(D);

        SmallVector<Decl *, 8> DeclsInGroup;
        // 解析第一个声明: 函数声明或变量声明
        Decl *FirstDecl = ParseDeclarationAfterDeclaratorAndAttributes(D, ...);
        {
            // 由Sema生成Decl
            Decl *ThisDecl = Actions.ActOnDeclarator(getCurScope(), D);

            // 解析初始值
            if (Tok.getKind() == tok::equal) {
                ConsumeToken();
                ExprResult Init = ParseInitializer();
                Actions.AddInitializerToDecl(ThisDecl, Init.get(), /*DirectInit=*/false);
            }

            Actions.FinalizeDeclaration(ThisDecl);
        }
        DeclsInGroup.push_back(FirstDecl);

        // 遇到逗号解析更多的声明: int a = 1, b = 2;
        while (TryConsumeToken(tok::comma, ...)) {
            ParseDeclarator(D);
            Decl *ThisDecl = ParseDeclarationAfterDeclarator(D);
            {
                ParseAsmAttributesAfterDeclarator(D);
                return ParseDeclarationAfterDeclaratorAndAttributes(D, ...);
            }
            DeclsInGroup.push_back(ThisDecl);
        }

        // 应该分号结尾
        ExpectAndConsumeSemi(...);

        // 由Sema处理
        return Actions.FinalizeDeclaratorGroup(getCurScope(), DS, DeclsInGroup);
    }
}

/// ParseDeclarator - Parse and verify a newly-initialized declarator.
void Parser::ParseDeclarator(Declarator &D) {
    /// ParseDeclaratorInternal - Parse a C or C++ declarator.
    ///       declarator: [C99 6.7.5] [C++ 8p4, dcl.decl]
    /// [C]     pointer[opt] direct-declarator
    ///
    ///       pointer: [C99 6.7.5]
    ///         '*' type-qualifier-list[opt]
    ///         '*' type-qualifier-list[opt] pointer
    ParseDeclaratorInternal(D, &Parser::ParseDirectDeclarator);
    {
        tok::TokenKind Kind = Tok.getKind();
        // 非指针
        if (Kind != tok::star) {
            /// 解析标识符以及函数形参
            /// int a;
            /// int a = 1;
            /// int func(int a);
            /// 
            /// ParseDirectDeclarator
            ///       direct-declarator: [C99 6.7.5]
            /// [C99]   identifier
            ///         '(' declarator ')'
            /// [GNU]   '(' attributes declarator ')'
            /// [C90]   direct-declarator '[' constant-expression[opt] ']'
            /// [C99]   direct-declarator '[' type-qual-list[opt] assign-expr[opt] ']'
            /// [C99]   direct-declarator '[' 'static' type-qual-list[opt] assign-expr ']'
            /// [C99]   direct-declarator '[' type-qual-list 'static' assign-expr ']'
            /// [C99]   direct-declarator '[' type-qual-list[opt] '*' ']'
            ///         direct-declarator '(' parameter-type-list ')'
            ///         direct-declarator '(' identifier-list[opt] ')'
            (this->*DirectDeclParser)(D);
            {
                // 解析标识符
                if (Tok.is(tok::identifier) && D.mayHaveIdentifier()) {
                    D.SetIdentifier(Tok.getIdentifierInfo(), Tok.getLocation());
                    ConsumeToken();
                    goto PastIdentifier;
                }

            PastIdentifier:
                if (Tok.is(tok::l_paren)) {
                    // 检查小括号是否配对
                    BalancedDelimiterTracker T(*this, tok::l_paren);
                    T.consumeOpen();

                    // 解析形参
                    Actions.ActOnStartFunctionDeclarationDeclarator(D, ...);
                    ParseFunctionDeclarator(D, attrs, T, IsAmbiguous);
                    {
                        // 解析形参
                        // Build up an array of information about the parsed arguments.
                        SmallVector<DeclaratorChunk::ParamInfo, 16> ParamInfo;
                        if (Tok.isNot(tok::r_paren)) {
                            ///    parameter-type-list: [C99 6.7.5]
                            ///      parameter-list
                            ///      parameter-list ',' '...'
                            ///    parameter-list: [C99 6.7.5]
                            ///      parameter-declaration
                            ///      parameter-list ',' parameter-declaration
                            ///    parameter-declaration: [C99 6.7.5]
                            ///      declaration-specifiers declarator
                            ParseParameterDeclarationClause(D, ParamInfo, ...);
                            {
                                do {
                                    DeclSpec DS(AttrFactory);
                                    ParseDeclarationSpecifiers(DS, ...);

                                    Declarator ParmDeclarator(DS, ...);
                                    ParseDeclarator(ParmDeclarator);

                                    MaybeParseGNUAttributes(ParmDeclarator);

                                    IdentifierInfo *ParmII = ParmDeclarator.getIdentifier();

                                    Decl *Param = Actions.ActOnParamDeclarator(..., ParmDeclarator, ...);

                                    ParamInfo.push_back(DeclaratorChunk::ParamInfo(ParmII, Param, ...));
                                } while (TryConsumeToken(tok::comma))
                            }
                        }
                            
                        // If we have the closing ')', eat it.
                        Tracker.consumeClose();

                        D.AddTypeInfo(DeclaratorChunk::getFunction(...));
                    }
                    Actions.ActOnFinishFunctionDeclarationDeclarator(D);
                } 
            }
            return;
        }

        ConsumeToken();  // Eat the *

        // 解析指针类型
        DeclSpec DS(AttrFactory);

        /// 解析指针之后的修饰符， 例如: `int * [const] a;`中的const
        /// ParseTypeQualifierListOpt
        ///          type-qualifier-list: [C99 6.7.5]
        ///            type-qualifier
        ParseTypeQualifierListOpt(DS, ...);

        // 递归处理剩余部分
        ParseDeclaratorInternal(D, DirectDeclParser);

        // Remember that we parsed a pointer type, and remember the type-quals.
        D.AddTypeInfo(DeclaratorChunk::getPointer(DS.getTypeQualifiers(), ...), ...);
    }
}

/// 解析函数体的组合语句
///       function-definition: [C99 6.9.1]
///         decl-specs      declarator declaration-list[opt] compound-statement
/// [C90] function-definition: [C99 6.7.1] - implicit int result
/// [C90]   decl-specs[opt] declarator declaration-list[opt] compound-statement
Decl *Parser::ParseFunctionDefinition(ParsingDeclarator &D, ...) {
    // If we didn't find the '{', bail out.
    if (Tok.isNot(tok::l_brace))
        return nullptr;

    ParseScope BodyScope(this, ...);

    // 由Sema生成函数定义
    Decl *Res = Actions.ActOnStartOfFunctionDef(getCurScope(), D, ...);
    return ParseFunctionStatementBody(Res, BodyScope);
    {
        StmtResult FnBody(ParseCompoundStatementBody());
        {
            BalancedDelimiterTracker T(*this, tok::l_brace);
            T.consumeOpen();

            // Parse any pragmas at the beginning of the compound statement.
            ParseCompoundStatementLeadingPragmas();
            Actions.ActOnAfterCompoundStatementLeadingPragmas();

            StmtVector Stmts;
            while (Tok.isNot(tok::r_brace) && Tok.isNot(tok::eof)) {
                StmtResult R = ParseStatementOrDeclaration(Stmts, SubStmtCtx);
                Stmts.push_back(R.get());
            }

            T.consumeClose()
            return Actions.ActOnCompoundStmt(Stmts, ...);
        }

        BodyScope.Exit();
        return Actions.ActOnFinishFunctionBody(Decl, FnBody.get());
    }
}

/// ParseStatementOrDeclaration - Read 'statement' or 'declaration'.
///       StatementOrDeclaration:
///         statement
///         declaration
///
///       statement:
///         labeled-statement
///         compound-statement
///         expression-statement
///         selection-statement
///         iteration-statement
///         jump-statement
/// [GNU]   asm-statement
///
///       labeled-statement:
///         identifier ':' statement
///         'case' constant-expression ':' statement
///         'default' ':' statement
///
///       selection-statement:
///         if-statement
///         switch-statement
///
///       iteration-statement:
///         while-statement
///         do-statement
///         for-statement
///
///       expression-statement:
///         expression[opt] ';'
///
///       jump-statement:
///         'goto' identifier ';'
///         'continue' ';'
///         'break' ';'
///         'return' expression[opt] ';'
/// [GNU]   'goto' '*' expression ';'
///
StmtResult Parser::ParseStatementOrDeclaration(StmtVector &Stmts, ...) {
    StmtResult Res = ParseStatementOrDeclarationAfterAttributes(Stmts, ...);
    return Actions.ActOnAttributedStmt(Attrs, Res.get());
}

StmtResult Parser::ParseStatementOrDeclarationAfterAttributes(StmtVector &Stmts, ...) {
    tok::TokenKind Kind  = Tok.getKind();
    switch (Kind) {
    case tok::identifier:
    ParseIdentifier: {
        Token Next = NextToken();
        if (Next.is(tok::colon)) {
            // 解析label: identifier ':' statement
            return ParseLabeledStatement(Attrs, StmtCtx);
        }

        // 非label那就是表达式语句
        // func(2);
        // a + b;
        [[fallthrough]];
    }
    default: 
        // 如果token是类型修饰符则是声明语句
        if (isDeclarationStatement()) {
            DeclGroupPtrTy Decl = ParseDeclaration(DeclaratorContext::Block, ...);
            {
                ///       simple-declaration: [C99 6.7: declaration] 
                ///         declaration-specifiers init-declarator-list[opt] ';'
                return ParseSimpleDeclaration(Context, ...);
                {
                    ParsingDeclSpec DS(*this);
                    ParseDeclarationSpecifiers(DS, ...);

                    // C99 6.7.2.3p6: Handle "struct-or-union identifier;", "enum { X };"
                    if (Tok.is(tok::semi)) {
                        // 记录定义的匿名的struct/union/enum
                        RecordDecl *AnonRecord = nullptr;
                        Decl *TheDecl = Actions.ParsedFreeStandingDeclSpec(..., AnonRecord);
                        
                        Actions.ActOnDefinedDeclarationSpecifier(TheDecl, ...);
                        
                        // struct { int a } x;
                        if (AnonRecord) {
                            Decl* decls[] = {AnonRecord, TheDecl};
                            return Actions.BuildDeclaratorGroup(decls);
                        }

                        // struct X x;
                        return Actions.ConvertDeclToDeclGroup(TheDecl);
                    }
                }
            }

            return Actions.ActOnDeclStmt(Decl, DeclStart, DeclEnd);
        }

        // eg: func(2);
        return ParseExprStatement(StmtCtx);
    case tok::kw_case:                // C99 6.8.1: labeled-statement
        return ParseCaseStatement(StmtCtx);
    case tok::kw_default:             // C99 6.8.1: labeled-statement
        return ParseDefaultStatement(StmtCtx);
    case tok::l_brace:                // C99 6.8.2: compound-statement
        return ParseCompoundStatement();
    case tok::semi:                   // C99 6.8.3p3: expression[opt] ';'
        return Actions.ActOnNullStmt(ConsumeToken(), ...); 
    case tok::kw_if:                  // C99 6.8.4.1: if-statement
        return ParseIfStatement(TrailingElseLoc);
    case tok::kw_switch:              // C99 6.8.4.2: switch-statement
        return ParseSwitchStatement(TrailingElseLoc);
    case tok::kw_while:               // C99 6.8.5.1: while-statement
        return ParseWhileStatement(TrailingElseLoc);
    case tok::kw_do:                  // C99 6.8.5.2: do-statement
        Res = ParseDoStatement();
        break;
    case tok::kw_for:                 // C99 6.8.5.3: for-statement
        return ParseForStatement(TrailingElseLoc);
    case tok::kw_goto:                // C99 6.8.6.1: goto-statement
        Res = ParseGotoStatement();
        break;
    case tok::kw_continue:            // C99 6.8.6.2: continue-statement
        Res = ParseContinueStatement();
        break;
    case tok::kw_break:               // C99 6.8.6.3: break-statement
        Res = ParseBreakStatement();
        break;
    case tok::kw_return:              // C99 6.8.6.4: return-statement
        Res = ParseReturnStatement();
        break;   
    case tok::kw_asm:                 // 嵌入式汇编
        Res = ParseAsmStatement(...);
        break;
    }

    ExpectAndConsume(tok::semi, ...);
    return Res;
}

// 以if为例分析语句解析过程
/// ParseIfStatement
///       if-statement: [C99 6.8.4.1]
///         'if' '(' expression ')' statement
///         'if' '(' expression ')' statement 'else' statement
StmtResult Parser::ParseIfStatement(...) {
    if (Tok.isNot(tok::l_paren)) {
        return StmtError();
    }

    ParseScope IfScope(this, ...);

    // Parse the condition.
    Sema::ConditionResult Cond;
    ParseParenExprOrCondition(..., Cond, ...);
    {
        BalancedDelimiterTracker T(*this, tok::l_paren);
        T.consumeOpen();

        ExprResult CondExpr = ParseExpression();
        Cond = Actions.ActOnCondition(...);

        T.consumeClose();
    }

    // 进入新的作用域解析then
    ParseScope InnerScope(this, ...);
    StmtResult ThenStmt = ParseStatement(...);
    InnerScope.Exit();

    StmtResult ElseStmt;
    if (Tok.is(tok::kw_else)) {
        ConsumeToken();

        ParseScope InnerScope(this, ...);
        ElseStmt = ParseStatement();
        InnerScope.Exit();
    }

    IfScope.Exit();

    return Actions.ActOnIfStmt(...);
}

/// 表达式按优先级从高到低排序
///       multiplicative-expression: [C99 6.5.5]
///     Note: in C++, apply pm-expression instead of cast-expression
///         cast-expression
///         multiplicative-expression '*' cast-expression
///         multiplicative-expression '/' cast-expression
///         multiplicative-expression '%' cast-expression
///
///       additive-expression: [C99 6.5.6]
///         multiplicative-expression
///         additive-expression '+' multiplicative-expression
///         additive-expression '-' multiplicative-expression
///
///       shift-expression: [C99 6.5.7]
///         additive-expression
///         shift-expression '<<' additive-expression
///         shift-expression '>>' additive-expression
///
///       compare-expression: [C++20 expr.spaceship]
///         shift-expression
///         compare-expression '<=>' shift-expression
///
///       relational-expression: [C99 6.5.8]
///         compare-expression
///         relational-expression '<' compare-expression
///         relational-expression '>' compare-expression
///         relational-expression '<=' compare-expression
///         relational-expression '>=' compare-expression
///
///       equality-expression: [C99 6.5.9]
///         relational-expression
///         equality-expression '==' relational-expression
///         equality-expression '!=' relational-expression
///
///       AND-expression: [C99 6.5.10]
///         equality-expression
///         AND-expression '&' equality-expression
///
///       exclusive-OR-expression: [C99 6.5.11]
///         AND-expression
///         exclusive-OR-expression '^' AND-expression
///
///       inclusive-OR-expression: [C99 6.5.12]
///         exclusive-OR-expression
///         inclusive-OR-expression '|' exclusive-OR-expression
///
///       logical-AND-expression: [C99 6.5.13]
///         inclusive-OR-expression
///         logical-AND-expression '&&' inclusive-OR-expression
///
///       logical-OR-expression: [C99 6.5.14]
///         logical-AND-expression
///         logical-OR-expression '||' logical-AND-expression
///
///       conditional-expression: [C99 6.5.15]
///         logical-OR-expression
///         logical-OR-expression '?' expression ':' conditional-expression
/// [GNU]   logical-OR-expression '?' ':' conditional-expression
///
///       assignment-expression: [C99 6.5.16]
///         conditional-expression
///         unary-expression assignment-operator assignment-expression
///
///       assignment-operator: one of
///         = *= /= %= += -= <<= >>= &= ^= |=
///
///       expression: [C99 6.5.17]
///         assignment-expression ...[opt]
///         expression ',' assignment-expression ...[opt]
ExprResult Parser::ParseExpression(...) {
    ExprResult LHS(ParseAssignmentExpression(isTypeCast));
    return ParseRHSOfBinaryExpression(LHS, prec::Comma);
}

StmtResult Parser::ParseStatement(...) {
    StmtResult Res;

    // We may get back a null statement if we found a #pragma. 
    // Keep going until we get an actual statement.
    StmtVector Stmts;
    do {
        Res = ParseStatementOrDeclaration(Stmts, ...);
    } while (!Res.isInvalid() && !Res.get());

    return Res;
}

```

## 语义分析

```c++

// 定义声明
Decl *Sema::ActOnDeclarator(Scope *S, Declarator &D) {
    Decl *Dcl = HandleDeclarator(S, D, MultiTemplateParamsArg());
    {
        // 查找作用域内是否定义过
        DeclarationNameInfo NameInfo = GetNameForDeclarator(D);
        LookupResult Previous(*this, NameInfo, ...);
        LookupName(Previous, S, ...);

        TypeSourceInfo *TInfo = GetTypeForDeclarator(D);
        DeclContext *DC = CurContext;

        NamedDecl *New;
        if (D.getDeclSpec().getStorageClassSpec() == DeclSpec::SCS_typedef) {
            New = ActOnTypedefDeclarator(S, D, DC, TInfo, Previous);
        } else if (R->isFunctionType()) {
            New = ActOnFunctionDeclarator(S, D, DC, TInfo, Previous, ...);
        } else {
            New = ActOnVariableDeclarator(S, D, DC, TInfo, Previous, ...);
        }

        // 加入作用域的符号表
        PushOnScopeChains(New, S);

        return New;
    }

    return Dcl;
}

// 变量声明
NamedDecl *Sema::ActOnVariableDeclarator(Scope *S, Declarator &D, ...) {
    QualType R = TInfo->getType();
    DeclarationName Name = GetNameForDeclarator(D).getName();
    IdentifierInfo *II = Name.getAsIdentifierInfo();

    DeclSpec::SCS SCSpec = D.getDeclSpec().getStorageClassSpec();
    StorageClass SC = StorageClassSpecToVarDeclStorageClass(D.getDeclSpec());

    VarDecl *NewVD = VarDecl::Create(Context, DC, ..., II, R, TInfo, SC);

    // 检查声明语句是否符合语义

    return NewVD;
}

// 函数声明
NamedDecl* Sema::ActOnFunctionDeclarator(Scope *S, Declarator &D, ...) {
    // Copy the parameter declarations from the declarator D to the function declaration NewFD
    SmallVector<ParmVarDecl*, 16> Params;

    FunctionDecl *NewFD = CreateNewFunctionDecl(*this, D, DC, R, TInfo, SC, ...);
    NewFD->setParams(Params);

    // Handle attributes.
    ProcessDeclAttributes(S, NewFD, D);

    ProcessPragmaWeak(S, NewFD);

    // 各种语义检查

    return NewFD;
}

// 函数定义
Decl * Sema::ActOnStartOfFunctionDef(Scope *FnBodyScope, Declarator &D, ...) {
    Decl *DP = HandleDeclarator(ParentScope, D, TemplateParameterLists);
    Decl *Dcl = ActOnStartOfFunctionDef(FnBodyScope, DP, SkipBody, BodyKind);
    {
        FunctionDecl *FD = cast<FunctionDecl>(D);
        
        // Enter a new function scope
        PushFunctionScope();

        ...

        return D;
    }

    return dcl;
}

Decl *Sema::ActOnFinishFunctionBody(Decl *dcl, Stmt *Body, ...) {
    FunctionScopeInfo *FSI = getCurFunction();
    FunctionDecl *FD = dcl->getAsFunction();

    FD->setBody(Body);

    PopFunctionScopeInfo(ActivePolicy, dcl);

    return dcl;
}

```

## 核心数据结构

`AST`叫抽象语法树，顾名思义应该是个树形结构

`Decl`的树形结构如下：clang/AST/DeclNodes.inc

```td

class DeclNode<DeclNode base, string diagSpelling = "", bit abstract = 0>
    : ASTNode, AttrSubject {
  DeclNode Base = base;
  bit Abstract = abstract;
  string DiagSpelling = diagSpelling;
}

def Decl : DeclNode<?, "", 1>;
def TranslationUnit : DeclNode<Decl>, DeclContext;
def Named : DeclNode<Decl, "named declarations", 1>;
  def Label : DeclNode<Named, "labels">;
  def Type : DeclNode<Named, "types", 1>;
    def TypedefName : DeclNode<Type, "typedefs", 1>;
      def Typedef : DeclNode<TypedefName>;
    def Tag : DeclNode<Type, "tag types", 1>, DeclContext;
      def Enum : DeclNode<Tag, "enums">;
      def Record : DeclNode<Tag, "structs, unions, classes">;
  def Value : DeclNode<Named, "value declarations", 1>;
    def EnumConstant : DeclNode<Value, "enumerators">;
    def Declarator : DeclNode<Value, "declarators", 1>;
      def Function : DeclNode<Declarator, "functions">, DeclContext;
      def Var : DeclNode<Declarator, "variables">;
        def ParmVar : DeclNode<Var, "parameters">;
def FileScopeAsm : DeclNode<Decl>;
def TopLevelStmt : DeclNode<Decl>;

```

`Stmt`和`Expr`的树形结构如下：clang/AST/StmtNodes.inc

```td

class StmtNode<StmtNode base, bit abstract = 0> : ASTNode, AttrSubject {
	StmtNode Base = base;
  bit Abstract = abstract;
}

// Statements
def Stmt : StmtNode<?, 1>;
def NullStmt : StmtNode<Stmt>;
def CompoundStmt : StmtNode<Stmt>;
def IfStmt : StmtNode<Stmt>;
def SwitchStmt : StmtNode<Stmt>;
def WhileStmt : StmtNode<Stmt>;
def DoStmt : StmtNode<Stmt>;
def ForStmt : StmtNode<Stmt>;
def GotoStmt : StmtNode<Stmt>;
def IndirectGotoStmt : StmtNode<Stmt>;
def ContinueStmt : StmtNode<Stmt>;
def BreakStmt : StmtNode<Stmt>;
def ReturnStmt : StmtNode<Stmt>;
def DeclStmt  : StmtNode<Stmt>;
def SwitchCase : StmtNode<Stmt, 1>;
def CaseStmt : StmtNode<SwitchCase>;
def DefaultStmt : StmtNode<SwitchCase>;

// Statements that might produce a value
def ValueStmt : StmtNode<Stmt, 1>;
def LabelStmt : StmtNode<ValueStmt>;
def AttributedStmt : StmtNode<ValueStmt>;

// Asm statements
def AsmStmt : StmtNode<Stmt, 1>;
def GCCAsmStmt : StmtNode<AsmStmt>;

// Expressions
def Expr : StmtNode<ValueStmt, 1>;
def PredefinedExpr : StmtNode<Expr>;
def DeclRefExpr : StmtNode<Expr>;
def IntegerLiteral : StmtNode<Expr>;
def StringLiteral : StmtNode<Expr>;
def CharacterLiteral : StmtNode<Expr>;
def ParenExpr : StmtNode<Expr>;
def UnaryOperator : StmtNode<Expr>;
def OffsetOfExpr : StmtNode<Expr>;
def ArraySubscriptExpr : StmtNode<Expr>;
def CallExpr : StmtNode<Expr>;
def CastExpr : StmtNode<Expr, 1>;
def BinaryOperator : StmtNode<Expr>;
def CompoundAssignOperator : StmtNode<BinaryOperator>;
def AbstractConditionalOperator : StmtNode<Expr, 1>;
def ConditionalOperator : StmtNode<AbstractConditionalOperator>;
def BinaryConditionalOperator : StmtNode<AbstractConditionalOperator>;
def ImplicitCastExpr : StmtNode<CastExpr>;
def ExplicitCastExpr : StmtNode<CastExpr, 1>;
def CStyleCastExpr : StmtNode<ExplicitCastExpr>;
def CompoundLiteralExpr : StmtNode<Expr>;
def ExtVectorElementExpr : StmtNode<Expr>;
def InitListExpr : StmtNode<Expr>;
def ImplicitValueInitExpr : StmtNode<Expr>;
def NoInitExpr : StmtNode<Expr>;
def ArrayInitLoopExpr : StmtNode<Expr>;
def ArrayInitIndexExpr : StmtNode<Expr>;
def ParenListExpr : StmtNode<Expr>;
def VAArgExpr : StmtNode<Expr>;
def GenericSelectionExpr : StmtNode<Expr>;
def PseudoObjectExpr : StmtNode<Expr>;
def SourceLocExpr : StmtNode<Expr>;

// Wrapper expressions
def FullExpr : StmtNode<Expr, 1>;
def ConstantExpr : StmtNode<FullExpr>;

// Atomic expressions
def AtomicExpr : StmtNode<Expr>;

// GNU Extensions.
def AddrLabelExpr : StmtNode<Expr>;
def StmtExpr : StmtNode<Expr>;
def ChooseExpr : StmtNode<Expr>;
def GNUNullExpr : StmtNode<Expr>;

```

核心数据结构:

```c++

class alignas(void *) Stmt {
public:
    enum Kind {
        #define STMT(CLASS, PARENT) CLASS##Class,
        #define ABSTRACT_STMT(STMT)
        #include "clang/AST/StmtNodes.inc"
    };


}

```


## demo

示例程序如下:

```c

#include<stdio.h>

int func(int i) 
{
    if (i == 0 || i == 1)
    {
        return 1;
    } 
    else if (i >= 2) {
        return func(i - 1) + func(i - 2);
    }

    return -1;
}

int main(int argc, char** argv) 
{
    int n = argc;
    if (n > 2)
    {
        return -1;
    }

    char* param0 = argv[1];
    if (param0 == 0)
    {
        return -2;
    }

    int s = 0;
    char c;
    int i = 0;
    while ((c = param0[i++]) != '\0')
    {
        if (c < '0' || c > '9')
        {
            return -3;
        }
        
        s *= 10;
        s += c - '0';
    }

    printf("param = %d\n", s);
    
    int total = func(s);

    printf("total = %d\n", total);

    return 0;
}

```

执行指令`clang -emit-ast demo/main.c -o demo/main.ast`产生的`AST`如下

```ast

// 忽略`#include<stdio.h>`的输出

|-FunctionDecl 0x55555571d5c0 <demo/main.c:3:1, line:14:1> line:3:5 used func 'int (int)'
| |-ParmVarDecl 0x55555571d528 <col:10, col:14> col:14 used i 'int'
| `-CompoundStmt 0x55555571e700 <line:4:1, line:14:1>
|   |-IfStmt 0x55555571da90 <line:5:5, line:11:5> has_else
|   | |-BinaryOperator 0x55555571d760 <line:5:9, col:24> 'int' '||'
|   | | |-BinaryOperator 0x55555571d6c8 <col:9, col:14> 'int' '=='
|   | | | |-ImplicitCastExpr 0x55555571d6b0 <col:9> 'int' <LValueToRValue>
|   | | | | `-DeclRefExpr 0x55555571d670 <col:9> 'int' lvalue ParmVar 0x55555571d528 'i' 'int'
|   | | | `-IntegerLiteral 0x55555571d690 <col:14> 'int' 0
|   | | `-BinaryOperator 0x55555571d740 <col:19, col:24> 'int' '=='
|   | |   |-ImplicitCastExpr 0x55555571d728 <col:19> 'int' <LValueToRValue>
|   | |   | `-DeclRefExpr 0x55555571d6e8 <col:19> 'int' lvalue ParmVar 0x55555571d528 'i' 'int'
|   | |   `-IntegerLiteral 0x55555571d708 <col:24> 'int' 1
|   | |-CompoundStmt 0x55555571d7b0 <line:6:5, line:8:5>
|   | | `-ReturnStmt 0x55555571d7a0 <line:7:9, col:16>
|   | |   `-IntegerLiteral 0x55555571d780 <col:16> 'int' 1
|   | `-IfStmt 0x55555571da70 <line:9:10, line:11:5>
|   |   |-BinaryOperator 0x55555571d820 <line:9:14, col:19> 'int' '>='
|   |   | |-ImplicitCastExpr 0x55555571d808 <col:14> 'int' <LValueToRValue>
|   |   | | `-DeclRefExpr 0x55555571d7c8 <col:14> 'int' lvalue ParmVar 0x55555571d528 'i' 'int'
|   |   | `-IntegerLiteral 0x55555571d7e8 <col:19> 'int' 2
|   |   `-CompoundStmt 0x55555571da58 <col:22, line:11:5>
|   |     `-ReturnStmt 0x55555571da48 <line:10:9, col:40>
|   |       `-BinaryOperator 0x55555571da28 <col:16, col:40> 'int' '+'
|   |         |-CallExpr 0x55555571d928 <col:16, col:26> 'int'
|   |         | |-ImplicitCastExpr 0x55555571d910 <col:16> 'int (*)(int)' <FunctionToPointerDecay>
|   |         | | `-DeclRefExpr 0x55555571d840 <col:16> 'int (int)' Function 0x55555571d5c0 'func' 'int (int)'
|   |         | `-BinaryOperator 0x55555571d8b8 <col:21, col:25> 'int' '-'
|   |         |   |-ImplicitCastExpr 0x55555571d8a0 <col:21> 'int' <LValueToRValue>
|   |         |   | `-DeclRefExpr 0x55555571d860 <col:21> 'int' lvalue ParmVar 0x55555571d528 'i' 'int'
|   |         |   `-IntegerLiteral 0x55555571d880 <col:25> 'int' 1
|   |         `-CallExpr 0x55555571da00 <col:30, col:40> 'int'
|   |           |-ImplicitCastExpr 0x55555571d9e8 <col:30> 'int (*)(int)' <FunctionToPointerDecay>
|   |           | `-DeclRefExpr 0x55555571d950 <col:30> 'int (int)' Function 0x55555571d5c0 'func' 'int (int)'
|   |           `-BinaryOperator 0x55555571d9c8 <col:35, col:39> 'int' '-'
|   |             |-ImplicitCastExpr 0x55555571d9b0 <col:35> 'int' <LValueToRValue>
|   |             | `-DeclRefExpr 0x55555571d970 <col:35> 'int' lvalue ParmVar 0x55555571d528 'i' 'int'
|   |             `-IntegerLiteral 0x55555571d990 <col:39> 'int' 2
|   `-ReturnStmt 0x55555571daf8 <line:13:5, col:13>
|     `-UnaryOperator 0x55555571dae0 <col:12, col:13> 'int' prefix '-'
|       `-IntegerLiteral 0x55555571dac0 <col:13> 'int' 1
`-FunctionDecl 0x55555571e898 <line:16:1, line:51:1> line:16:5 main 'int (int, char **)'
  |-ParmVarDecl 0x55555571e738 <col:10, col:14> col:14 used argc 'int'
  |-ParmVarDecl 0x55555571e7b8 <col:20, col:27> col:27 used argv 'char **'
  `-CompoundStmt 0x55555571f808 <line:17:1, line:51:1>
    |-DeclStmt 0x55555571ea08 <line:18:5, col:17>
    | `-VarDecl 0x55555571e968 <col:5, col:13> col:9 used n 'int' cinit
    |   `-ImplicitCastExpr 0x55555571e9f0 <col:13> 'int' <LValueToRValue>
    |     `-DeclRefExpr 0x55555571e9d0 <col:13> 'int' lvalue ParmVar 0x55555571e738 'argc' 'int'
    |-IfStmt 0x55555571eaf8 <line:19:5, line:22:5>
    | |-BinaryOperator 0x55555571ea78 <line:19:9, col:13> 'int' '>'
    | | |-ImplicitCastExpr 0x55555571ea60 <col:9> 'int' <LValueToRValue>
    | | | `-DeclRefExpr 0x55555571ea20 <col:9> 'int' lvalue Var 0x55555571e968 'n' 'int'
    | | `-IntegerLiteral 0x55555571ea40 <col:13> 'int' 2
    | `-CompoundStmt 0x55555571eae0 <line:20:5, line:22:5>
    |   `-ReturnStmt 0x55555571ead0 <line:21:9, col:17>
    |     `-UnaryOperator 0x55555571eab8 <col:16, col:17> 'int' prefix '-'
    |       `-IntegerLiteral 0x55555571ea98 <col:17> 'int' 1
    |-DeclStmt 0x55555571ec28 <line:24:5, col:27>
    | `-VarDecl 0x55555571eb30 <col:5, col:26> col:11 used param0 'char *' cinit
    |   `-ImplicitCastExpr 0x55555571ec10 <col:20, col:26> 'char *' <LValueToRValue>
    |     `-ArraySubscriptExpr 0x55555571ebf0 <col:20, col:26> 'char *' lvalue
    |       |-ImplicitCastExpr 0x55555571ebd8 <col:20> 'char **' <LValueToRValue>
    |       | `-DeclRefExpr 0x55555571eb98 <col:20> 'char **' lvalue ParmVar 0x55555571e7b8 'argv' 'char **'
    |       `-IntegerLiteral 0x55555571ebb8 <col:25> 'int' 1
    |-IfStmt 0x55555571ed30 <line:25:5, line:28:5>
    | |-BinaryOperator 0x55555571ecb0 <line:25:9, col:19> 'int' '=='
    | | |-ImplicitCastExpr 0x55555571ec80 <col:9> 'char *' <LValueToRValue>
    | | | `-DeclRefExpr 0x55555571ec40 <col:9> 'char *' lvalue Var 0x55555571eb30 'param0' 'char *'
    | | `-ImplicitCastExpr 0x55555571ec98 <col:19> 'char *' <NullToPointer>
    | |   `-IntegerLiteral 0x55555571ec60 <col:19> 'int' 0
    | `-CompoundStmt 0x55555571ed18 <line:26:5, line:28:5>
    |   `-ReturnStmt 0x55555571ed08 <line:27:9, col:17>
    |     `-UnaryOperator 0x55555571ecf0 <col:16, col:17> 'int' prefix '-'
    |       `-IntegerLiteral 0x55555571ecd0 <col:17> 'int' 2
    |-DeclStmt 0x55555571edf0 <line:30:5, col:14>
    | `-VarDecl 0x55555571ed68 <col:5, col:13> col:9 used s 'int' cinit
    |   `-IntegerLiteral 0x55555571edd0 <col:13> 'int' 0
    |-DeclStmt 0x55555571ee80 <line:31:5, col:11>
    | `-VarDecl 0x55555571ee18 <col:5, col:10> col:10 used c 'char'
    |-DeclStmt 0x55555571ef38 <line:32:5, col:14>
    | `-VarDecl 0x55555571eeb0 <col:5, col:13> col:9 used i 'int' cinit
    |   `-IntegerLiteral 0x55555571ef18 <col:13> 'int' 0
    |-WhileStmt 0x55555571f3c8 <line:33:5, line:42:5>
    | |-BinaryOperator 0x55555571f088 <line:33:12, col:33> 'int' '!='
    | | |-ImplicitCastExpr 0x55555571f070 <col:12, col:28> 'int' <IntegralCast>
    | | | `-ParenExpr 0x55555571f038 <col:12, col:28> 'char'
    | | |   `-BinaryOperator 0x55555571f018 <col:13, col:27> 'char' '='
    | | |     |-DeclRefExpr 0x55555571ef50 <col:13> 'char' lvalue Var 0x55555571ee18 'c' 'char'
    | | |     `-ImplicitCastExpr 0x55555571f000 <col:17, col:27> 'char' <LValueToRValue>
    | | |       `-ArraySubscriptExpr 0x55555571efe0 <col:17, col:27> 'char' lvalue
    | | |         |-ImplicitCastExpr 0x55555571efc8 <col:17> 'char *' <LValueToRValue>
    | | |         | `-DeclRefExpr 0x55555571ef70 <col:17> 'char *' lvalue Var 0x55555571eb30 'param0' 'char *'
    | | |         `-UnaryOperator 0x55555571efb0 <col:24, col:25> 'int' postfix '++'
    | | |           `-DeclRefExpr 0x55555571ef90 <col:24> 'int' lvalue Var 0x55555571eeb0 'i' 'int'
    | | `-CharacterLiteral 0x55555571f058 <col:33> 'int' 0
    | `-CompoundStmt 0x55555571f3a0 <line:34:5, line:42:5>
    |   |-IfStmt 0x55555571f238 <line:35:9, line:38:9>
    |   | |-BinaryOperator 0x55555571f1b8 <line:35:13, col:28> 'int' '||'
    |   | | |-BinaryOperator 0x55555571f110 <col:13, col:17> 'int' '<'
    |   | | | |-ImplicitCastExpr 0x55555571f0f8 <col:13> 'int' <IntegralCast>
    |   | | | | `-ImplicitCastExpr 0x55555571f0e0 <col:13> 'char' <LValueToRValue>
    |   | | | |   `-DeclRefExpr 0x55555571f0a8 <col:13> 'char' lvalue Var 0x55555571ee18 'c' 'char'
    |   | | | `-CharacterLiteral 0x55555571f0c8 <col:17> 'int' 48
    |   | | `-BinaryOperator 0x55555571f198 <col:24, col:28> 'int' '>'
    |   | |   |-ImplicitCastExpr 0x55555571f180 <col:24> 'int' <IntegralCast>
    |   | |   | `-ImplicitCastExpr 0x55555571f168 <col:24> 'char' <LValueToRValue>
    |   | |   |   `-DeclRefExpr 0x55555571f130 <col:24> 'char' lvalue Var 0x55555571ee18 'c' 'char'
    |   | |   `-CharacterLiteral 0x55555571f150 <col:28> 'int' 57
    |   | `-CompoundStmt 0x55555571f220 <line:36:9, line:38:9>
    |   |   `-ReturnStmt 0x55555571f210 <line:37:13, col:21>
    |   |     `-UnaryOperator 0x55555571f1f8 <col:20, col:21> 'int' prefix '-'
    |   |       `-IntegerLiteral 0x55555571f1d8 <col:21> 'int' 3
    |   |-CompoundAssignOperator 0x55555571f298 <line:40:9, col:14> 'int' '*=' ComputeLHSTy='int' ComputeResultTy='int'
    |   | |-DeclRefExpr 0x55555571f258 <col:9> 'int' lvalue Var 0x55555571ed68 's' 'int'
    |   | `-IntegerLiteral 0x55555571f278 <col:14> 'int' 10
    |   `-CompoundAssignOperator 0x55555571f370 <line:41:9, col:18> 'int' '+=' ComputeLHSTy='int' ComputeResultTy='int'
    |     |-DeclRefExpr 0x55555571f2c8 <col:9> 'int' lvalue Var 0x55555571ed68 's' 'int'
    |     `-BinaryOperator 0x55555571f350 <col:14, col:18> 'int' '-'
    |       |-ImplicitCastExpr 0x55555571f338 <col:14> 'int' <IntegralCast>
    |       | `-ImplicitCastExpr 0x55555571f320 <col:14> 'char' <LValueToRValue>
    |       |   `-DeclRefExpr 0x55555571f2e8 <col:14> 'char' lvalue Var 0x55555571ee18 'c' 'char'
    |       `-CharacterLiteral 0x55555571f308 <col:18> 'int' 48
    |-CallExpr 0x55555571f4f8 <line:44:5, col:29> 'int'
    | |-ImplicitCastExpr 0x55555571f4e0 <col:5> 'int (*)(const char *, ...)' <FunctionToPointerDecay>
    | | `-DeclRefExpr 0x55555571f3e8 <col:5> 'int (const char *, ...)' Function 0x555555707118 'printf' 'int (const char *, ...)'
    | |-ImplicitCastExpr 0x55555571f540 <col:12> 'const char *' <NoOp>
    | | `-ImplicitCastExpr 0x55555571f528 <col:12> 'char *' <ArrayToPointerDecay>
    | |   `-StringLiteral 0x55555571f450 <col:12> 'char[12]' lvalue "param = %d\n"
    | `-ImplicitCastExpr 0x55555571f558 <col:28> 'int' <LValueToRValue>
    |   `-DeclRefExpr 0x55555571f478 <col:28> 'int' lvalue Var 0x55555571ed68 's' 'int'
    |-DeclStmt 0x55555571f688 <line:46:5, col:24>
    | `-VarDecl 0x55555571f588 <col:5, col:23> col:9 used total 'int' cinit
    |   `-CallExpr 0x55555571f648 <col:17, col:23> 'int'
    |     |-ImplicitCastExpr 0x55555571f630 <col:17> 'int (*)(int)' <FunctionToPointerDecay>
    |     | `-DeclRefExpr 0x55555571f5f0 <col:17> 'int (int)' Function 0x55555571d5c0 'func' 'int (int)'
    |     `-ImplicitCastExpr 0x55555571f670 <col:22> 'int' <LValueToRValue>
    |       `-DeclRefExpr 0x55555571f610 <col:22> 'int' lvalue Var 0x55555571ed68 's' 'int'
    |-CallExpr 0x55555571f760 <line:48:5, col:33> 'int'
    | |-ImplicitCastExpr 0x55555571f748 <col:5> 'int (*)(const char *, ...)' <FunctionToPointerDecay>
    | | `-DeclRefExpr 0x55555571f6a0 <col:5> 'int (const char *, ...)' Function 0x555555707118 'printf' 'int (const char *, ...)'
    | |-ImplicitCastExpr 0x55555571f7a8 <col:12> 'const char *' <NoOp>
    | | `-ImplicitCastExpr 0x55555571f790 <col:12> 'char *' <ArrayToPointerDecay>
    | |   `-StringLiteral 0x55555571f6c0 <col:12> 'char[12]' lvalue "total = %d\n"
    | `-ImplicitCastExpr 0x55555571f7c0 <col:28> 'int' <LValueToRValue>
    |   `-DeclRefExpr 0x55555571f710 <col:28> 'int' lvalue Var 0x55555571f588 'total' 'int'
    `-ReturnStmt 0x55555571f7f8 <line:50:5, col:12>
      `-IntegerLiteral 0x55555571f7d8 <col:12> 'int' 0

```
