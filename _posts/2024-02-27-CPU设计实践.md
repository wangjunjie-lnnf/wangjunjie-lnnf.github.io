---
layout: post
title:  "CPU设计实践"
date:   2024-02-27 01:49:07 +0000
categories: jekyll
tags: hardware
---

# CPU设计实践

## 面向硬件电路的设计思维方式

> 面向硬件电路的设计思维方式的核心实际上就是“`数据通路（Datapath）＋ 控制逻辑（ControlLogic）`”。

> 一个电路是你看得见摸得着的一个物体，比如，你看到一块电路板上面有一个个电子器件以及连接这些器件的导线，这些器件和导线就构成了一个电路。芯片内部也类似，既有器件也有导线，只不过物理尺寸小一些而已。电路中这些器件之间传递的是什么？电磁信号。当我们把这些电磁信号离散化之后，可以进一步认为这些器件之间传递的是数据。数据从一个电路系统的输人端传人，经由各个通路完成各种处理之后，最终从电路系统的输出端传输出来，电路系统中这些数据流经的通路就是数据通路。

> 数据通路的一个突出特点是：如果实现了它，它就—直在那里，不会消失；如果没有实现它，它就一直不存在，也不会凭空出现。打个比方，家里既要有卧室也要有厨房，你在卧室睡觉的时候，厨房始终存在，不是你要做饭的时候临时出现的。回到电路设计，当你设计一个CPU的ALU时，不是在遇到加法指令时就调用一个加法器来处理下，遇到移位指令时就调用一个移位器来处理一下。ALU要支持加法指令和移位指令的处理，ALU里就既要有加法器，也要有移位器。做加法指令的时候，流人ALU的数据要流到加法器，加法器处理完的输出流到ALU的输出；做移位指令的时候，流人ALU的数据要流到移位器，移位器处理完的输出流到ALU的输出。这时候你的设计里面就出现了下面条路径：“ALU人口→加法器人口→加法器出口→ALU出口”和“ALU人口→移位器人口→移器出口→ALU出口”。那么问题又来了：如何保证处理加法指令的时候让数据只走法器的这条路径,处理移位指令的时候让数据只走移位器的这条路径呢？你肯定想到在路径上加开关，这个思路是对的，不过在这种CMOS电路上，通常很难实现电路的物理开关。我们变通一下，用逻辑开关来解决这个问题。我们可以在“加法器出口→ALU出口”和“移位器出口→ALU出口”这个位置加一个功能为“二选一”的选择器。它选哪—个输出取决于指令的类型：当遇到加法指令时，这个选择器输出选择的是加法出口传过来的值；当遇到移位指令时，这个选择器输出选择的是移位器出口传过来的值。

例如以下C函数，`op == 0`时`r = a - b`是不会执行的

```c
int alu(int a, int b, int op) {
    int r;

    if (op == 0) {
        r = a + b;
    } else {
        r = a - b;
    }

    return r;
}
```

等价的verilog代码如下，加和减都会执行，只是输出之前通过`mux`选其一

```verilog

module alu(
    input wire[31:0] a,
    input wire[31:0] b,
    input wire op,
    output wire[32:0] r
);

    wire[32:0] add;
    wire[32:0] sub;

    assign add = a + b;
    assign sub = a - b;

    assign r = op == 0 ? add : sub;

endmodule

```

> 进行电路设计时，数据通路是基础，控制逻辑是基于数据通路的。数据通路就像人体的骨酪、肌肉、呼吸系统、血液循环系统、消化系统，而控制逻辑就人体的神经系统，它由—个中枢（大脑）连接身体的各个部位。在设计电路系统的时候，只确定了数据通路，才能在控制逻辑设计中考虑该如何控制这个通路上各个多路选择器选择信号、各个存储器件写入的使能信号。


### 计算机体系结构

> 冯·诺依曼结构也称普林斯顿结构，是一种将程序指令存储器和数据存储器合并在一起的存储器结构。程序指令存储地址和数据存储地址指向同一个存储器的不同物理位置，因此程序指令和数据的宽度相同，如英特尔公司的8086中央处理器的程序指令和数据都是16位宽。数学家冯·诺依曼提出了计算机制造的三个基本原则，即采用二进制逻辑、程序存储执行以及计算机由五个部分组成（运算器、控制器、存储器、输入设备、输出设备），这套理论被称为冯·诺依曼体系结构。

> 现代计算机发展所遵循的基本结构形式始终是冯·诺依曼机结构。这种结构特点是“程序存储，共享数据，顺序执行”，需要CPU从存储器取出指令和数据进行相应的计算。

> 在冯·诺依曼机结构中，指令和数据存储在同一个存储器中，形成系统对存储器的过分依赖。于是后来有了改进的哈佛结构。哈佛结构的计算机分为三大部件：（1）CPU；（2）程序存储器；（3）数据存储器。它的特点是将程序指令和数据分开存储，由于数据存储器与程序存储器采用不同的总线，因而较大的提高了存储器的带宽，使之数字信号处理性能更加优越。

> 哈佛结构处理器有两个明显的特点：使用两个独立的存储器模块，分别存储指令和数据，每个存储模块都不允许指令和数据并存；使用独立的两条总线，分别作为CPU与每个存储器之间的专用通信路径，而这两条总线之间毫无关联。

![data-path-1](/assets/images/2024-02-27/data-path-1.png)

根据上文描述，我们可以画出一个简单的数据流图：从指令存储取指令；读寄存器；读数据存储；写数据存储；写寄存器；取下一条指令。

**CPU可以看作一个复杂的FSM，数据和寄存器存储其状态，指令可以看作此FSM的输入，取指令和执行指令可以看作一个复杂的组合电路，组合电路根据当前的状态（读寄存器、读数据）处理输入的指令，然后更新状态（写寄存器、写内存），最后根据状态决定其输出。**


### 流水线

![pipeline](/assets/images/2024-02-27/pipeline.png)

组合逻辑的耗时会直接影响时钟周期，缩短周期的方法是把一个复杂的组合电路切分成多个步骤，相邻的两个步骤之间通过DFF存储要传递的数据，这就是流水线的原型。

![data-path-2](/assets/images/2024-02-27/data-path-2.png)

上图是一个经典的5级流水线，包含：取指；解码；执行；访存；回写。从此图可以看出，**同一个信号可以同时输入多个组件，多个信号输入同一个组件的同一个端口时需要一个`mux`来选择一个信号**。


## 案例

此文将使用Verilog实现mips32指令集，以此探索cpu的设计思路，只是学习思路，不纠结具体的指令格式等细节，最终的目标是riscv。

### mips32指令集

![mips-inst-format](/assets/images/2024-02-27/mips-inst-format.png)

> mips32所有指令长度均为32比特。除个别指令外，所有指令的格式均为立即数型（I-Type），跳转型（J-Type）和寄存器型（R-Type）三种类型中的一种。

常用指令如下：

* 算术运算指令

| 指令名称格式 | 指令功能简述 |
| - | - |
ADD[UI] rd, rs, rt/immediate  | 加法
SUB[U] rd, rs, rt  | 减法
SLT[UI] rd, rs, rt/immediate  | 比较大小：less then
DIV[U] rs, rt      | 除法
MULT[U] rs, rt     | 乘法

* 逻辑运算指令

| 指令名称格式 | 指令功能简述 |
| - | - |
AND[I] rd, rs, rt/immediate | 与
NOR rd, rs, rt              | 非
OR[I] rd, rs, rt/immediate  | 或
XOR[I] rd, rs, rt/immediate | 异或
LUI rt, immediate   | rt = immediate << 16

* 移位指令

| 指令名称格式 | 指令功能简述 |
| - | - |
SLL[V] rd, rt, sa/rs      | 逻辑左移
SRA[V] rd, rt, sa/rs      | 算术右移
SRL[V] rd, rt, sa/rs      | 逻辑右移

* 分支跳转指令

| 指令名称格式 | 指令功能简述 |
| - | - |
BEQ/BNE rs, rt, offset      | 相等跳转
BGTZ/BLTZ rs, rt, offset    | 大小跳转
J target        | 无条件跳转 pc <- (pc+4)[31,28] || (target << 2)
JAL target      | 函数调用
JR rs           | 无条件跳转: pc <- rs
JALR [rd,] rs   | 函数调用: rd <- returnAddr

* 数据移动指令

| 指令名称格式 | 指令功能简述 |
| - | - |
MFHI rd | Move From HI
MFLO rd | Move From LO
MTHI rs | Move To HI
MTLO rs | Move To LO

* 内存指令

| 指令名称格式 | 指令功能简述 |
| - | - |
L[BH][U] rt, offset(base)   | load [byte/half] [unsinged]
LW[LR] rt, offset(base)     | (非对齐地址) load word
S[BHW] rt, offset(base)     | store [byte/half/word]     

* 系统调用指令

| 指令名称格式 | 指令功能简述 |
| - | - |
| SYSCALL   | 系统调用


* 特权指令

| 指令名称格式 | 指令功能简述 |
| - | - |
ERET    | 异常handler返回
MFC0    | move from cp0寄存器
MTC0    | move to cp0寄存器


### 流水线框架

![pipeline-framework](/assets/images/2024-02-27/pipeline-framework.png)






