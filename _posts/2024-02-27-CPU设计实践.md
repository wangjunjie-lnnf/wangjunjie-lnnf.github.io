---
layout: post
title:  "CPU设计实践"
date:   2024-02-27 01:49:07 +0000
categories: jekyll
tags: hardware
---

# CPU设计实践

## 面向硬件电路的设计思维方式

> 面向硬件电路的设计思维方式的核心实际上就是“`数据通路（Datapath）＋ 控制逻辑（ControlLogic）`”。

> 一个电路是你看得见摸得着的一个物体，比如，你看到一块电路板上面有一个个电子器件以及连接这些器件的导线，这些器件和导线就构成了一个电路。芯片内部也类似，既有器件也有导线，只不过物理尺寸小一些而已。电路中这些器件之间传递的是什么？电磁信号。当我们把这些电磁信号离散化之后，可以进一步认为这些器件之间传递的是数据。数据从一个电路系统的输人端传人，经由各个通路完成各种处理之后，最终从电路系统的输出端传输出来，电路系统中这些数据流经的通路就是数据通路。

> 数据通路的一个突出特点是：如果实现了它，它就—直在那里，不会消失；如果没有实现它，它就一直不存在，也不会凭空出现。打个比方，家里既要有卧室也要有厨房，你在卧室睡觉的时候，厨房始终存在，不是你要做饭的时候临时出现的。回到电路设计，当你设计一个CPU的ALU时，不是在遇到加法指令时就调用一个加法器来处理下，遇到移位指令时就调用一个移位器来处理一下。ALU要支持加法指令和移位指令的处理，ALU里就既要有加法器，也要有移位器。做加法指令的时候，流人ALU的数据要流到加法器，加法器处理完的输出流到ALU的输出；做移位指令的时候，流人ALU的数据要流到移位器，移位器处理完的输出流到ALU的输出。这时候你的设计里面就出现了下面条路径：“ALU人口→加法器人口→加法器出口→ALU出口”和“ALU人口→移位器人口→移器出口→ALU出口”。那么问题又来了：如何保证处理加法指令的时候让数据只走法器的这条路径,处理移位指令的时候让数据只走移位器的这条路径呢？你肯定想到在路径上加开关，这个思路是对的，不过在这种CMOS电路上，通常很难实现电路的物理开关。我们变通一下，用逻辑开关来解决这个问题。我们可以在“加法器出口→ALU出口”和“移位器出口→ALU出口”这个位置加一个功能为“二选一”的选择器。它选哪—个输出取决于指令的类型：当遇到加法指令时，这个选择器输出选择的是加法出口传过来的值；当遇到移位指令时，这个选择器输出选择的是移位器出口传过来的值。

例如以下C函数，`op == 0`时`r = a - b`是不会执行的

```c
int alu(int a, int b, int op) {
    int r;

    if (op == 0) {
        r = a + b;
    } else {
        r = a - b;
    }

    return r;
}
```

等价的verilog代码如下，加和减都会执行，只是输出之前通过`mux`选其一

```verilog

module alu(
    input wire[31:0] a,
    input wire[31:0] b,
    input wire op,
    output wire[32:0] r
);

    wire[32:0] add;
    wire[32:0] sub;

    assign add = a + b;
    assign sub = a - b;

    assign r = op == 0 ? add : sub;

endmodule

```

> 进行电路设计时，数据通路是基础，控制逻辑是基于数据通路的。数据通路就像人体的骨酪、肌肉、呼吸系统、血液循环系统、消化系统，而控制逻辑就人体的神经系统，它由—个中枢（大脑）连接身体的各个部位。在设计电路系统的时候，只确定了数据通路，才能在控制逻辑设计中考虑该如何控制这个通路上各个多路选择器选择信号、各个存储器件写入的使能信号。


### 计算机体系结构

> 冯·诺依曼结构也称普林斯顿结构，是一种将程序指令存储器和数据存储器合并在一起的存储器结构。程序指令存储地址和数据存储地址指向同一个存储器的不同物理位置，因此程序指令和数据的宽度相同，如英特尔公司的8086中央处理器的程序指令和数据都是16位宽。数学家冯·诺依曼提出了计算机制造的三个基本原则，即采用二进制逻辑、程序存储执行以及计算机由五个部分组成（运算器、控制器、存储器、输入设备、输出设备），这套理论被称为冯·诺依曼体系结构。

> 现代计算机发展所遵循的基本结构形式始终是冯·诺依曼机结构。这种结构特点是“程序存储，共享数据，顺序执行”，需要CPU从存储器取出指令和数据进行相应的计算。

> 在冯·诺依曼机结构中，指令和数据存储在同一个存储器中，形成系统对存储器的过分依赖。于是后来有了改进的哈佛结构。哈佛结构的计算机分为三大部件：（1）CPU；（2）程序存储器；（3）数据存储器。它的特点是将程序指令和数据分开存储，由于数据存储器与程序存储器采用不同的总线，因而较大的提高了存储器的带宽，使之数字信号处理性能更加优越。

> 哈佛结构处理器有两个明显的特点：使用两个独立的存储器模块，分别存储指令和数据，每个存储模块都不允许指令和数据并存；使用独立的两条总线，分别作为CPU与每个存储器之间的专用通信路径，而这两条总线之间毫无关联。

![data-path-1](/assets/images/2024-02-27/data-path-1.png)

根据上文描述，我们可以画出一个简单的数据流图：从指令存储取指令；读寄存器；读数据存储；写数据存储；写寄存器；取下一条指令。

**CPU可以看作一个复杂的FSM，数据和寄存器存储其状态，指令可以看作此FSM的输入，取指令和执行指令可以看作一个复杂的组合电路，组合电路根据当前的状态（读寄存器、读数据）处理输入的指令，然后更新状态（写寄存器、写内存），最后根据状态决定其输出。**


### 流水线

![pipeline](/assets/images/2024-02-27/pipeline.png)

组合逻辑的耗时会直接影响时钟周期，缩短周期的方法是把一个复杂的组合电路切分成多个步骤，相邻的两个步骤之间通过DFF存储要传递的数据，这就是流水线的原型。

![data-path-2](/assets/images/2024-02-27/data-path-2.png)

上图是一个经典的5级流水线，包含：取指；解码；执行；访存；回写。从此图可以看出，**同一个信号可以同时输入多个组件，多个信号输入同一个组件的同一个端口时需要一个`mux`来选择一个信号**。


## 案例背景

此文将使用Verilog实现mips32指令集，以此探索cpu的设计思路，只是学习思路，不纠结具体的指令格式等细节，最终的目标是riscv。

### mips32指令集

![mips-inst-format](/assets/images/2024-02-27/mips-inst-format.png)

> mips32所有指令长度均为32比特。除个别指令外，所有指令的格式均为立即数型（I-Type），跳转型（J-Type）和寄存器型（R-Type）三种类型中的一种。

常用指令如下：

* 算术运算指令

| 指令名称格式 | 指令功能简述 |
| - | - |
ADD[UI] rd, rs, rt/immediate  | 加法
SUB[U] rd, rs, rt  | 减法
SLT[UI] rd, rs, rt/immediate  | 比较大小：less then
DIV[U] rs, rt      | 除法
MULT[U] rs, rt     | 乘法

* 逻辑运算指令

| 指令名称格式 | 指令功能简述 |
| - | - |
AND[I] rd, rs, rt/immediate | 与
NOR rd, rs, rt              | 非
OR[I] rd, rs, rt/immediate  | 或
XOR[I] rd, rs, rt/immediate | 异或
LUI rt, immediate   | rt = immediate << 16

* 移位指令

| 指令名称格式 | 指令功能简述 |
| - | - |
SLL[V] rd, rt, sa/rs      | 逻辑左移
SRA[V] rd, rt, sa/rs      | 算术右移
SRL[V] rd, rt, sa/rs      | 逻辑右移

* 分支跳转指令

| 指令名称格式 | 指令功能简述 |
| - | - |
BEQ/BNE rs, rt, offset      | 相等跳转
BGTZ/BLTZ rs, rt, offset    | 大小跳转
J target        | 无条件跳转 pc <- (pc+4)[31,28] || (target << 2)
JAL target      | 函数调用
JR rs           | 无条件跳转: pc <- rs
JALR [rd,] rs   | 函数调用: rd <- returnAddr

* 数据移动指令

| 指令名称格式 | 指令功能简述 |
| - | - |
MFHI rd | Move From HI
MFLO rd | Move From LO
MTHI rs | Move To HI
MTLO rs | Move To LO

* 内存指令

| 指令名称格式 | 指令功能简述 |
| - | - |
L[BH][U] rt, offset(base)   | load [byte/half] [unsinged]
LW[LR] rt, offset(base)     | (非对齐地址) load word
S[BHW] rt, offset(base)     | store [byte/half/word]     

* 系统调用指令

| 指令名称格式 | 指令功能简述 |
| - | - |
| SYSCALL   | 系统调用


* 特权指令

| 指令名称格式 | 指令功能简述 |
| - | - |
ERET    | 异常handler返回
MFC0    | move from cp0寄存器
MTC0    | move to cp0寄存器


### 数据流

![data-path-2](/assets/images/2024-02-27/data-path-2.png)

上图mips32的5级流水线数据流图：包括正向的数据流和逆向的数据流。  

正向的数据流：  
1. 取指阶段向解码阶段传递指令
2. 解码阶段向执行阶段传递指令类别和操作数
3. 执行阶段向访存阶段传递读写内存地址和数据
4. 访存阶段向回写阶段透传执行阶段传递的写寄存器和数据

逆向的数据流：  
1. 译码阶段向取指阶段传递跳转目标信息
2. 执行阶段向译码阶段传递写寄存器和数据，解决`read after write`问题
3. 访存阶段向译码阶段传递写寄存器和数据，解决`read after write`问题


## 实现

### 顶层结构

最顶层是由cpu/rom/ram组成的soc

```verilog

module openmips_min_sopc (

	input wire				clk,
	input wire				rst
	
);

	// ...
	
	//assign int = {5'b00000, timer_int, gpio_int, uart_int};
	assign int = {5'b00000, timer_int};

	// cpu核
 	openmips openmips0(
		.clk(clk),
		.rst(rst),
	
		// 取指令
		.rom_addr_o(inst_addr),
		.rom_data_i(inst),
		.rom_ce_o(rom_ce),

		// 处理中断
    	.int_i(int),

		// 读写内存数据
		.ram_we_o(mem_we_i),
		.ram_addr_o(mem_addr_i),
		.ram_sel_o(mem_sel_i),
		.ram_data_o(mem_data_i),
		.ram_data_i(mem_data_o),
		.ram_ce_o(mem_ce_i),
		
		// 触发时钟中断
		.timer_int_o(timer_int)	
	);
	
	// 存储指令
	inst_rom inst_rom0(
		.ce(rom_ce),
		.addr(inst_addr),
		.inst(inst)	
	);

	// 存储数据
	data_ram data_ram0(
		.clk(clk),
		.ce(mem_ce_i),
		.we(mem_we_i),
		.addr(mem_addr_i),
		.sel(mem_sel_i),
		.data_i(mem_data_i),
		.data_o(mem_data_o)	
	);

endmodule

```

cpu外部依赖包括指令rom和数据ram，读指令和读数据都是组合电路！！！

```verilog

module inst_rom (

	input wire							ce,
	input wire[`InstAddrBus]			addr,
	output reg[`InstBus]				inst
	
);

	reg[`InstBus]  inst_mem[0:`InstMemNum-1];

	// 从文件加载指令到rom，不可综合
	initial $readmemh ("inst_rom.data", inst_mem);

	// 组合电路读指令
	always @ (*) begin
		if (ce == `ChipDisable) begin
			inst <= `ZeroWord;
		end else begin
			// 限制bit以免越界
			inst <= inst_mem[addr[`InstMemNumLog2+1:2]];
		end
	end

endmodule

```

```verilog

module data_ram (

	input wire							clk,
	input wire							ce,
	input wire							we,
	input wire[`DataAddrBus]			addr,
	input wire[3:0]						sel,
	input wire[`DataBus]				data_i,
	output reg[`DataBus]				data_o
	
);

	// 拆分成4个字节数组以简化非对齐读写
	reg[`ByteWidth]  data_mem0[0:`DataMemNum-1];
	reg[`ByteWidth]  data_mem1[0:`DataMemNum-1];
	reg[`ByteWidth]  data_mem2[0:`DataMemNum-1];
	reg[`ByteWidth]  data_mem3[0:`DataMemNum-1];

	// 写
	always @ (posedge clk) begin
		if (ce == `ChipDisable) begin
			// data_o <= ZeroWord;
		end else if(we == `WriteEnable) begin
			if (sel[3] == 1'b1) begin
		      	data_mem3[addr[`DataMemNumLog2+1:2]] <= data_i[31:24];
		    end
			if (sel[2] == 1'b1) begin
		      	data_mem2[addr[`DataMemNumLog2+1:2]] <= data_i[23:16];
		    end
		    if (sel[1] == 1'b1) begin
		      	data_mem1[addr[`DataMemNumLog2+1:2]] <= data_i[15:8];
		    end
			if (sel[0] == 1'b1) begin
		      	data_mem0[addr[`DataMemNumLog2+1:2]] <= data_i[7:0];
		    end			   	    
		end
	end
	
	// 读：组合电路
	always @ (*) begin
		if (ce == `ChipDisable) begin
			data_o <= `ZeroWord;
	  	end else if(we == `WriteDisable) begin
		    data_o <= {data_mem3[addr[`DataMemNumLog2+1:2]],
		               data_mem2[addr[`DataMemNumLog2+1:2]],
		               data_mem1[addr[`DataMemNumLog2+1:2]],
		               data_mem0[addr[`DataMemNumLog2+1:2]]};
		end else begin
			data_o <= `ZeroWord;
		end
	end		

endmodule

```

### cpu内部状态

cpu内部状态包括：  
1. 程序计数器`pc`
2. 寄存器文件`regfile`
3. 支持原子操作`ll（link load）/sc（store condition）`指令的`LLbit`寄存器
4. 存储乘法和除法结果的`hilo`寄存器
5. 协处理器`cp0`的寄存器

```verilog

module pc_reg (

	input wire				      clk,
	input wire					  rst,

	// 来自控制模块的信息
	// 流水线暂停：暂停更新pc
	input wire[5:0]               stall,

	// 异常处理：跳转到异常处理程序
	input wire                    flush,
	input wire[`RegBus]           new_pc,

	// 来自译码阶段的分支跳转信息
	input wire                    branch_flag_i,
	input wire[`RegBus]           branch_target_address_i,
	
	output reg[`InstAddrBus]	  pc,
	output reg                    ce
	
);

	always @ (posedge clk) begin
		if (ce == `ChipDisable) begin
            // 从0地址取第一条指令
			pc <= 32'h00000000;
		end else begin
            // 发生异常需要清空流水线
			if(flush == 1'b1) begin
                // 跳转到异常处理程序
				pc <= new_pc;
			end else if(stall[0] == `NoStop) begin
				if(branch_flag_i == `Branch) begin
                    // 上一条是分支指令，从跳转地址取下一条指令
					pc <= branch_target_address_i;
				end else begin
                    // 非分支指令顺序取指令
		  		    pc <= pc + 4'h4;
		  	    end
			end
		end
	end

	// ...

endmodule

```

```verilog

module regfile (

	input wire							clk,
	input wire							rst,
	
	// 写端口
	input wire							we,
	input wire[`RegAddrBus]				waddr,
	input wire[`RegBus]					wdata,
	
	// 读端口1
	input wire							re1,
	input wire[`RegAddrBus]			  	raddr1,
	output reg[`RegBus]           		rdata1,
	
	// 读端口2
	input wire							re2,
	input wire[`RegAddrBus]			  	raddr2,
	output reg[`RegBus]           		rdata2
	
);

	reg[`RegBus]  regs[0:`RegNum-1];

	// 写端口
	always @ (posedge clk) begin
		if (rst == `RstDisable) begin
			if((we == `WriteEnable) && (waddr != `RegNumLog2'h0)) begin
				regs[waddr] <= wdata;
			end
		end
	end
	
	always @ (*) begin
		if(rst == `RstEnable) begin
			rdata1 <= `ZeroWord;
		end else if(raddr1 == `RegNumLog2'h0) begin
			rdata1 <= `ZeroWord;
		end else if((raddr1 == waddr) && 
					(we == `WriteEnable) && 
					(re1 == `ReadEnable)) begin
			// 处理read-after-write问题
			// 回写阶段向译码阶段传递写寄存器和数据
			rdata1 <= wdata;
		end else if(re1 == `ReadEnable) begin
			rdata1 <= regs[raddr1];
		end else begin
			rdata1 <= `ZeroWord;
		end
	end

	// ...

endmodule

```

`LLbit`寄存器用于支持实现原子操作

```verilog

module LLbit_reg(

	input wire						clk,
	input wire						rst,
	
	input wire                    	flush,
	
	// 写端口
	input wire						LLbit_i,
	input wire                    	we,
	
	// 读端口
	output reg                    	LLbit_o
	
);

	always @ (posedge clk) begin
		if (rst == `RstEnable) begin
			LLbit_o <= 1'b0;
		end else if((flush == 1'b1)) begin
			LLbit_o <= 1'b0;
		end else if((we == `WriteEnable)) begin
			LLbit_o <= LLbit_i;
		end
	end

endmodule

```

`hilo`寄存器用于存储乘法和除法的结果

```verilog

module hilo_reg (

	input wire						clk,
	input wire						rst,
	
	// 写端口
	input wire						we,
	input wire[`RegBus]				hi_i,
	input wire[`RegBus]				lo_i,
	
	// 读端口
	output reg[`RegBus]           	hi_o,
	output reg[`RegBus]           	lo_o
	
);

	always @ (posedge clk) begin
		if (rst == `RstEnable) begin
			hi_o <= `ZeroWord;
			lo_o <= `ZeroWord;
		end else if((we == `WriteEnable)) begin
			hi_o <= hi_i;
			lo_o <= lo_i;
		end
	end

endmodule

```

cp0寄存器主要包括：  
1. count: 处理器周期计数
2. compare: 定时中断控制
3. status: 处理器状态和控制寄存器
4. cause: 保存上一次异常原因
5. epc: 保存上一次异常时的程序计数器

---

下图为状态寄存器status的结构
![reg-status](/assets/images/2024-02-27/reg-status.png)

* **IM7-IM0** 表示是否屏蔽相应中断（Interrupt Mask），0表示屏蔽，1表示不屏蔽， MIPS处理器可以有8个中断源，对应`IM`字段的8位，其中6个中断源是处理器外部硬件中断，另外2个是软件中断，中断是否能够被处理器响应是由`Status`寄存器与`Cause`寄存器共同决定的，如果`Status`寄存器的`IM`字段与`Cause`寄存器的`IP`字段的相应位都为1，而且 `Status`寄存器的`IE`字段也为1时，处理器才响应相应中断。

* **UM** 表示是否为用户模式（User Mode），为1表示处理器运行在内核模式，为0表示处理器运行在用户模式。 

* **EXL** 表示是否处于异常级（Exception Level），当异常发生时，会设置本字段为1，表示处理器处于异常级，此时处理器会进入内核模式下工作，并且禁止中断。

* **IE** 表示是否使能中断（Interrupt Enable），这是全局中断使能标志位。为1表示中断使能，为0表示中断禁止。

---

下图为异常原因寄存器cause的结构
![reg-cause](/assets/images/2024-02-27/reg-cause.png)

* **BD** 当发生异常的指令处于分支延迟槽（Branch DelaySlot）时，该字段被置为1。

* **IP** 中断挂起（Interrupt Pending）字段，相应位用来指明外部硬件中断是否发生，IP[2:7]标识0-5号硬件中断，IP[0:1]标识0-1号软件中断

* **ExcCode** 用来记录异常类型：0标识中断；8标识syscall

```verilog

module cp0_reg (

	input wire						clk,
	input wire						rst,
	
	// 读写寄存器
	input wire                    	we_i,
	input wire[4:0]               	waddr_i,
	input wire[4:0]               	raddr_i,
	input wire[`RegBus]           	data_i,
	
	input wire[31:0]              	excepttype_i,
	input wire[5:0]               	int_i,
	input wire[`RegBus]           	current_inst_addr_i,
	input wire                    	is_in_delayslot_i,
	
	output reg[`RegBus]           	data_o,
	output reg[`RegBus]           	count_o,
	output reg[`RegBus]           	compare_o,
	output reg[`RegBus]           	status_o,
	output reg[`RegBus]           	cause_o,
	output reg[`RegBus]           	epc_o,
	output reg[`RegBus]           	config_o,
	output reg[`RegBus]           	prid_o,
	
	output reg                   	timer_int_o    
	
);

	always @ (posedge clk) begin
		if(rst == `RstEnable) begin
			count_o <= `ZeroWord;
			compare_o <= `ZeroWord;
			// status寄存器的CU为0001，表示协处理器CP0存在
			status_o <= 32'b00010000000000000000000000000000;
			cause_o <= `ZeroWord;
			epc_o <= `ZeroWord;
			// config寄存器的BE为1，表示Big-Endian；MT为00，表示没有MMU
			config_o <= 32'b00000000000000001000000000000000;
			prid_o <= 32'b00000000010011000000000100000010;
      		timer_int_o <= `InterruptNotAssert;
		end else begin
			// count寄存器用于时钟周期计数
			count_o <= count_o + 1 ;
			cause_o[15:10] <= int_i;
		
			// compare用于设置时钟中断的频率
			if(compare_o != `ZeroWord && count_o == compare_o) begin
				timer_int_o <= `InterruptAssert;
			end
			
			// 写寄存器
			if(we_i == `WriteEnable) begin
				case (waddr_i) 
					`CP0_REG_COUNT:		begin
						count_o <= data_i;
					end
					`CP0_REG_COMPARE:	begin
						compare_o <= data_i;
						// count_o <= `ZeroWord;
            			timer_int_o <= `InterruptNotAssert;
					end
					// ...
					`CP0_REG_STATUS:	begin
						status_o <= data_i;
					end
					`CP0_REG_CAUSE:	begin
					  	// cause寄存器只有IP[1:0]、IV、WP字段是可写的
						cause_o[9:8] <= data_i[9:8];
						cause_o[23] <= data_i[23];
						cause_o[22] <= data_i[22];
					end					
				endcase  //case addr_i
			end

			// 处理中断和异常
			case (excepttype_i)
				// 中断
				32'h00000001:		begin
					if(is_in_delayslot_i == `InDelaySlot) begin
						epc_o <= current_inst_addr_i - 4;
						// 异常发生在分支延迟槽
						cause_o[31] <= 1'b1;
					end else begin
						epc_o <= current_inst_addr_i;
						cause_o[31] <= 1'b0;
					end
					// 进入内核模式
					status_o[1] <= 1'b1;
					// 异常类型为中断
					cause_o[6:2] <= 5'b00000;
				end
				// 系统调用syscall
				32'h00000008:		begin
					if(status_o[1] == 1'b0) begin
						if(is_in_delayslot_i == `InDelaySlot) begin
							epc_o <= current_inst_addr_i - 4 ;
							// 异常发生在分支延迟槽
							cause_o[31] <= 1'b1;
						end else begin
							epc_o <= current_inst_addr_i;
							cause_o[31] <= 1'b0;
						end
					end
					// 进入内核模式
					status_o[1] <= 1'b1;
					// 异常类型为syscall
					cause_o[6:2] <= 5'b01000;			
				end
				
				// ...

				// 异常返回: eret，切换到用户级				
				32'h0000000e:   begin
					status_o[1] <= 1'b0;
				end
				default:		begin
				end
			endcase			
			
		end    // if
	end      // always
			
	// 读寄存器
	always @ (*) begin
		if(rst == `RstEnable) begin
			data_o <= `ZeroWord;
		end else begin
			case (raddr_i) 
				`CP0_REG_STATUS:	begin
					data_o <= status_o ;
				end
				`CP0_REG_CAUSE:	begin
					data_o <= cause_o ;
				end
				// ...
				default: 	begin
				end			
			endcase  //case addr_i			
		end    // if
	end      // always

endmodule

```

### 取指

![fetch](/assets/images/2024-02-27/fetch.png)

```verilog

module if_id (

	input wire						clk,
	input wire						rst,

	// 来自控制模块的信息
	input wire[5:0]               	stall,	
	input wire                    	flush,

	input wire[`InstAddrBus]		if_pc,
	input wire[`InstBus]          	if_inst,
	output reg[`InstAddrBus]      	id_pc,
	output reg[`InstBus]          	id_inst  
	
);

	always @ (posedge clk) begin
		if (rst == `RstEnable) begin
			id_pc <= `ZeroWord;
			id_inst <= `ZeroWord;
		end else if(flush == 1'b1 ) begin
			id_pc <= `ZeroWord;
			id_inst <= `ZeroWord;					
		end else if(stall[1] == `Stop && stall[2] == `NoStop) begin
			// 停止更新pc即暂停流水线
			id_pc <= `ZeroWord;
			id_inst <= `ZeroWord;	
		end else if(stall[1] == `NoStop) begin
			// 传递数据给译码阶段
			id_pc <= if_pc;
			id_inst <= if_inst;
		end
	end

endmodule

```

### 译码

```verilog

module id (

	input wire						rst,
	input wire[`InstAddrBus]		pc_i,
	input wire[`InstBus]          	inst_i,

	// 处于执行阶段的指令的一些信息，用于解决load相关
	input wire[`AluOpBus]			ex_aluop_i,

	// 处于执行阶段的指令要写入的目的寄存器信息
	input wire						ex_wreg_i,
	input wire[`RegBus]				ex_wdata_i,
	input wire[`RegAddrBus]       	ex_wd_i,
	
	// 处于访存阶段的指令要写入的目的寄存器信息
	input wire						mem_wreg_i,
	input wire[`RegBus]				mem_wdata_i,
	input wire[`RegAddrBus]       	mem_wd_i,
	
	// 寄存器值
	input wire[`RegBus]           	reg1_data_i,
	input wire[`RegBus]           	reg2_data_i,

	// 如果上一条指令是转移指令，那么下一条指令在译码的时候is_in_delayslot为true
	input wire                    	is_in_delayslot_i,

	// 送到regfile的地址信息
	output reg                    	reg1_read_o,
	output reg                    	reg2_read_o,     
	output reg[`RegAddrBus]       	reg1_addr_o,
	output reg[`RegAddrBus]       	reg2_addr_o, 	      
	
	// 送到执行阶段的信息
	output reg[`AluOpBus]         	aluop_o,
	output reg[`AluSelBus]        	alusel_o,
	output reg[`RegBus]           	reg1_o,
	output reg[`RegBus]           	reg2_o,
	output reg[`RegAddrBus]       	wd_o,
	output reg                    	wreg_o,
	output wire[`RegBus]          	inst_o,

	output reg                    	next_inst_in_delayslot_o,
	
	// 传递给取指阶段更改pc
	output reg                    	branch_flag_o,
	output reg[`RegBus]           	branch_target_address_o,

	output reg[`RegBus]           	link_addr_o,
	output reg                    	is_in_delayslot_o,

	output wire[31:0]             	excepttype_o,
	output wire[`RegBus]          	current_inst_address_o,
	
	// 当前指令依赖上一条load指令的结果时需要暂停流水线
	output wire                   	stallreq	
);

	wire[5:0] op = inst_i[31:26];
	wire[4:0] op2 = inst_i[10:6];
	wire[5:0] op3 = inst_i[5:0];
	wire[4:0] op4 = inst_i[20:16];
	reg[`RegBus]	imm;
	reg instvalid;
	wire[`RegBus] pc_plus_8;
	wire[`RegBus] pc_plus_4;
	wire[`RegBus] imm_sll2_signedext;  

	reg stallreq_for_reg1_loadrelate;
	reg stallreq_for_reg2_loadrelate;
	wire pre_inst_is_load;
	reg excepttype_is_syscall;
	reg excepttype_is_eret;
	
	assign pc_plus_8 = pc_i + 8;
	assign pc_plus_4 = pc_i + 4;
	assign imm_sll2_signedext = {{14{inst_i[15]}}, inst_i[15:0], 2'b00 }; 

	// read-after-write优化: 暂停流水线
	assign stallreq = stallreq_for_reg1_loadrelate | stallreq_for_reg2_loadrelate;

	assign pre_inst_is_load = ((ex_aluop_i == `EXE_LB_OP)  || 
							   (ex_aluop_i == `EXE_LBU_OP) ||
							   (ex_aluop_i == `EXE_LH_OP)  ||
							   (ex_aluop_i == `EXE_LHU_OP) ||
							   (ex_aluop_i == `EXE_LW_OP)  ||
							   (ex_aluop_i == `EXE_LWR_OP) ||
							   (ex_aluop_i == `EXE_LWL_OP) ||
							   (ex_aluop_i == `EXE_LL_OP)  ||
							   (ex_aluop_i == `EXE_SC_OP)) ? 1'b1 : 1'b0;

	assign inst_o = inst_i;

	// exception_type的低8-bit留给外部中断，第9-bit表示是否是syscall指令
	// 第10-bit表示是否是无效指令，第11-bit表示是否是trap指令
	assign excepttype_o = {19'b0, excepttype_is_eret, 2'b0, instvalid, excepttype_is_syscall, 8'b0};
	// assign excepttye_is_trapinst = 1'b0;
  
	assign current_inst_address_o = pc_i;
    
	// 译码电路是组合电路
	always @ (*) begin	
		// reset设置所有输出信号的默认值
		if (rst == `RstEnable) begin
			// ...						
	  	end else begin
			aluop_o <= `EXE_NOP_OP;
			alusel_o <= `EXE_RES_NOP;
			wd_o <= inst_i[15:11];
			wreg_o <= `WriteDisable;
			instvalid <= `InstInvalid;	   
			reg1_read_o <= 1'b0;
			reg2_read_o <= 1'b0;
			reg1_addr_o <= inst_i[25:21];
			reg2_addr_o <= inst_i[20:16];		
			imm <= `ZeroWord;
			link_addr_o <= `ZeroWord;
			branch_target_address_o <= `ZeroWord;
			branch_flag_o <= `NotBranch;	
			next_inst_in_delayslot_o <= `NotInDelaySlot;
			excepttype_is_syscall <= `False_v;	
			excepttype_is_eret <= `False_v;					 			
		  
		  	// 按指令规范译码
		  	case (op)
		    	`EXE_SPECIAL_INST:	begin
					case (op2)
						5'b00000:	begin
							case (op3)
								// 逻辑指令
								`EXE_OR:	begin
									wreg_o <= `WriteEnable;		
									aluop_o <= `EXE_OR_OP;
									alusel_o <= `EXE_RES_LOGIC; 	
									reg1_read_o <= 1'b1;	
									reg2_read_o <= 1'b1;
									instvalid <= `InstValid;	
								end  

								// ...

								// 移位指令
								`EXE_SLLV: 	begin
									wreg_o <= `WriteEnable;		
									aluop_o <= `EXE_SLL_OP;
									alusel_o <= `EXE_RES_SHIFT;		
									reg1_read_o <= 1'b1;	
									reg2_read_o <= 1'b1;
									instvalid <= `InstValid;	
								end 
								
								// ...

								// move指令
								`EXE_MOVN: 	begin
									aluop_o <= `EXE_MOVN_OP;
									alusel_o <= `EXE_RES_MOVE;   
									reg1_read_o <= 1'b1;	
									reg2_read_o <= 1'b1;
									instvalid <= `InstValid;
									if(reg2_o != `ZeroWord) begin
										wreg_o <= `WriteEnable;
									end else begin
										wreg_o <= `WriteDisable;
									end
								end

								// ...

								// 算术指令							
								`EXE_ADD: 	begin
									wreg_o <= `WriteEnable;		
									aluop_o <= `EXE_ADD_OP;
									alusel_o <= `EXE_RES_ARITHMETIC;		
									reg1_read_o <= 1'b1;	
									reg2_read_o <= 1'b1;
									instvalid <= `InstValid;	
								end

								// ...

								// 分支跳转指令	
								`EXE_JR: 	begin
									wreg_o <= `WriteDisable;		
									aluop_o <= `EXE_JR_OP;
									alusel_o <= `EXE_RES_JUMP_BRANCH;   
									reg1_read_o <= 1'b1;	
									reg2_read_o <= 1'b0;
									link_addr_o <= `ZeroWord;
									
									branch_target_address_o <= reg1_o;
									branch_flag_o <= `Branch;
							
									next_inst_in_delayslot_o <= `InDelaySlot;
									instvalid <= `InstValid;	
								end

								// ...										

								default:	begin
								end
							endcase
						end
						default: 	begin
						end
					endcase	
          			
					case (op3)

						// ...
						
						`EXE_SYSCALL: begin
							wreg_o <= `WriteDisable;		
							aluop_o <= `EXE_SYSCALL_OP;
							alusel_o <= `EXE_RES_NOP;   
							reg1_read_o <= 1'b0;	
							reg2_read_o <= 1'b0;
							instvalid <= `InstValid; 
							excepttype_is_syscall <= `True_v;
						end							 																					
						default: begin
						end	
					endcase									
				end	

				// 带立即数的指令								  
				`EXE_ORI:			begin
					wreg_o <= `WriteEnable;		
					aluop_o <= `EXE_OR_OP;
					alusel_o <= `EXE_RES_LOGIC; 
					reg1_read_o <= 1'b1;	
					reg2_read_o <= 1'b0;	  	
					imm <= {16'h0, inst_i[15:0]};		
					wd_o <= inst_i[20:16];
					instvalid <= `InstValid;	
				end
				
				// ...

				// 分支指令
				`EXE_J:			begin
					wreg_o <= `WriteDisable;		
					aluop_o <= `EXE_J_OP;
					alusel_o <= `EXE_RES_JUMP_BRANCH; 
					reg1_read_o <= 1'b0;	
					reg2_read_o <= 1'b0;
					link_addr_o <= `ZeroWord;
					branch_target_address_o <= {pc_plus_4[31:28], inst_i[25:0], 2'b00};
					branch_flag_o <= `Branch;
					next_inst_in_delayslot_o <= `InDelaySlot;		  	
					instvalid <= `InstValid;	
				end

				// 条件跳转
				`EXE_BEQ:			begin
					wreg_o <= `WriteDisable;		
					aluop_o <= `EXE_BEQ_OP;
					alusel_o <= `EXE_RES_JUMP_BRANCH; 
					reg1_read_o <= 1'b1;	
					reg2_read_o <= 1'b1;
					instvalid <= `InstValid;	
					if(reg1_o == reg2_o) begin
						branch_target_address_o <= pc_plus_4 + imm_sll2_signedext;
						branch_flag_o <= `Branch;
						next_inst_in_delayslot_o <= `InDelaySlot;		  	
					end
				end
				
				// ...

				// load指令
				`EXE_LB:			begin
					wreg_o <= `WriteEnable;		
					aluop_o <= `EXE_LB_OP;
					alusel_o <= `EXE_RES_LOAD_STORE; 
					reg1_read_o <= 1'b1;	
					reg2_read_o <= 1'b0;	  	
					wd_o <= inst_i[20:16]; 
					instvalid <= `InstValid;	
				end

				// store指令	
				`EXE_SB:			begin
					wreg_o <= `WriteDisable;		
					aluop_o <= `EXE_SB_OP;
					reg1_read_o <= 1'b1;	
					reg2_read_o <= 1'b1; 
					instvalid <= `InstValid;	
					alusel_o <= `EXE_RES_LOAD_STORE; 
				end

				// ...
				
				`EXE_SC:			begin
					wreg_o <= `WriteEnable;		
					aluop_o <= `EXE_SC_OP;
					alusel_o <= `EXE_RES_LOAD_STORE; 
					reg1_read_o <= 1'b1;	
					reg2_read_o <= 1'b1;	  	
					wd_o <= inst_i[20:16]; 
					instvalid <= `InstValid;	
					alusel_o <= `EXE_RES_LOAD_STORE; 
				end								
				`EXE_REGIMM_INST:	begin
					case (op4)
						`EXE_BGEZ:	begin
							wreg_o <= `WriteDisable;		
							aluop_o <= `EXE_BGEZ_OP;
							alusel_o <= `EXE_RES_JUMP_BRANCH; 
							reg1_read_o <= 1'b1;	
							reg2_read_o <= 1'b0;
							instvalid <= `InstValid;	
							if(reg1_o[31] == 1'b0) begin
								branch_target_address_o <= pc_plus_4 + imm_sll2_signedext;
								branch_flag_o <= `Branch;
								next_inst_in_delayslot_o <= `InDelaySlot;		  	
							end
						end

						// ...
										
						default:	begin
						end
					endcase
				end								
				`EXE_SPECIAL2_INST:	begin
					case ( op3 )
						`EXE_CLZ:		begin
							wreg_o <= `WriteEnable;		
							aluop_o <= `EXE_CLZ_OP;
		  					alusel_o <= `EXE_RES_ARITHMETIC; 
							reg1_read_o <= 1'b1;	
							reg2_read_o <= 1'b0;	  	
							instvalid <= `InstValid;	
						end

						// ...
										
						default:	begin
						end
					endcase      //EXE_SPECIAL_INST2 case
				end																		  	
				default:			begin
				end
			endcase		  // case op
		  
			// ...

			if(inst_i == `EXE_ERET) begin
				wreg_o <= `WriteDisable;		
				aluop_o <= `EXE_ERET_OP;
				alusel_o <= `EXE_RES_NOP;   
				reg1_read_o <= 1'b0;	
				reg2_read_o <= 1'b0;
				instvalid <= `InstValid; 
				excepttype_is_eret <= `True_v;				
			end else if(inst_i[31:21] == 11'b01000000000 && 
						inst_i[10:0] == 11'b00000000000) begin
				aluop_o <= `EXE_MFC0_OP;
				alusel_o <= `EXE_RES_MOVE;
				wd_o <= inst_i[20:16];
				wreg_o <= `WriteEnable;
				instvalid <= `InstValid;	   
				reg1_read_o <= 1'b0;
				reg2_read_o <= 1'b0;		
			end else if(inst_i[31:21] == 11'b01000000100 && 
						inst_i[10:0] == 11'b00000000000) begin
				aluop_o <= `EXE_MTC0_OP;
				alusel_o <= `EXE_RES_NOP;
				wreg_o <= `WriteDisable;
				instvalid <= `InstValid;	   
				reg1_read_o <= 1'b1;
				reg1_addr_o <= inst_i[20:16];
				reg2_read_o <= 1'b0;					
			end
		  
		end       // if
	end         // always
	
	// 计算操作数
	always @ (*) begin
		stallreq_for_reg1_loadrelate <= `NoStop;	
		if(rst == `RstEnable) begin
			reg1_o <= `ZeroWord;	
		end else if(pre_inst_is_load == 1'b1 && 
					ex_wd_i == reg1_addr_o && 
					reg1_read_o == 1'b1 ) begin
			// read-after-write优化: 暂停流水线等待load的结果
		  	stallreq_for_reg1_loadrelate <= `Stop;							
		end else if((reg1_read_o == 1'b1) && 
					(ex_wreg_i == 1'b1) && 
					(ex_wd_i == reg1_addr_o)) begin
			// read-after-write优化: 读取执行阶段的寄存器值
			reg1_o <= ex_wdata_i; 
		end else if((reg1_read_o == 1'b1) && 
					(mem_wreg_i == 1'b1) && 
					(mem_wd_i == reg1_addr_o)) begin
			reg1_o <= mem_wdata_i; 			
		end else if(reg1_read_o == 1'b1) begin
			reg1_o <= reg1_data_i;
		end else if(reg1_read_o == 1'b0) begin
			reg1_o <= imm;
		end else begin
			reg1_o <= `ZeroWord;
		end
	end
	
	// ...

	always @ (*) begin
		if(rst == `RstEnable) begin
			is_in_delayslot_o <= `NotInDelaySlot;
		end else begin
		  	is_in_delayslot_o <= is_in_delayslot_i;		
	  	end
	end

endmodule

```

```verilog

module id_ex (

	input wire						clk,
	input wire						rst,

	// 来自控制模块的信息
	input wire[5:0]					stall,
	input wire                   	flush,
	
	// 从译码阶段传递的信息
	input wire[`AluOpBus]         	id_aluop,
	input wire[`AluSelBus]        	id_alusel,
	input wire[`RegBus]           	id_reg1,
	input wire[`RegBus]           	id_reg2,
	input wire[`RegAddrBus]       	id_wd,
	input wire                    	id_wreg,
	input wire[`RegBus]           	id_link_address,
	input wire                    	id_is_in_delayslot,
	input wire                    	next_inst_in_delayslot_i,		
	input wire[`RegBus]           	id_inst,		
	input wire[`RegBus]           	id_current_inst_address,
	input wire[31:0]              	id_excepttype,
	
	// 传递到执行阶段的信息
	output reg[`AluOpBus]         	ex_aluop,
	output reg[`AluSelBus]        	ex_alusel,
	output reg[`RegBus]           	ex_reg1,
	output reg[`RegBus]           	ex_reg2,
	output reg[`RegAddrBus]       	ex_wd,
	output reg                    	ex_wreg,
	output reg[`RegBus]           	ex_link_address,
  	output reg                    	ex_is_in_delayslot,
	output reg                    	is_in_delayslot_o,
	output reg[`RegBus]           	ex_inst,
	output reg[31:0]              	ex_excepttype,
	output reg[`RegBus]          	ex_current_inst_address	
	
);

	always @ (posedge clk) begin
		if (rst == `RstEnable) begin
			// ...
		end else if(flush == 1'b1 ) begin
			// ...		    
		end else if(stall[2] == `Stop && stall[3] == `NoStop) begin
			// 译码阶段暂停则插入nop指令
			ex_aluop <= `EXE_NOP_OP;
			ex_alusel <= `EXE_RES_NOP;
			ex_reg1 <= `ZeroWord;
			ex_reg2 <= `ZeroWord;
			ex_wd <= `NOPRegAddr;
			ex_wreg <= `WriteDisable;	
			ex_link_address <= `ZeroWord;
			ex_is_in_delayslot <= `NotInDelaySlot;
			ex_inst <= `ZeroWord;			
			ex_excepttype <= `ZeroWord;
			ex_current_inst_address <= `ZeroWord;	
		end else if(stall[2] == `NoStop) begin		
			ex_aluop <= id_aluop;
			ex_alusel <= id_alusel;
			ex_reg1 <= id_reg1;
			ex_reg2 <= id_reg2;
			ex_wd <= id_wd;
			ex_wreg <= id_wreg;		
			ex_link_address <= id_link_address;
			ex_is_in_delayslot <= id_is_in_delayslot;
			is_in_delayslot_o <= next_inst_in_delayslot_i;
			ex_inst <= id_inst;			
			ex_excepttype <= id_excepttype;
			ex_current_inst_address <= id_current_inst_address;		
		end
	end
	
endmodule

```

### 执行

```verilog

module ex (

	input wire						rst,
	
	// 送到执行阶段的信息
	input wire[`AluOpBus]         	aluop_i,
	input wire[`AluSelBus]        	alusel_i,
	input wire[`RegBus]           	reg1_i,
	input wire[`RegBus]           	reg2_i,
	input wire[`RegAddrBus]       	wd_i,
	input wire                    	wreg_i,
	input wire[`RegBus]           	inst_i,
	input wire[31:0]              	excepttype_i,
	input wire[`RegBus]          	current_inst_address_i,
	
	// HI、LO寄存器的值
	input wire[`RegBus]           	hi_i,
	input wire[`RegBus]           	lo_i,

	// 回写阶段的指令是否要写HI、LO，用于检测HI、LO的数据相关
	input wire[`RegBus]           	wb_hi_i,
	input wire[`RegBus]           	wb_lo_i,
	input wire                    	wb_whilo_i,
	
	// 访存阶段的指令是否要写HI、LO，用于检测HI、LO的数据相关
	input wire[`RegBus]           	mem_hi_i,
	input wire[`RegBus]           	mem_lo_i,
	input wire                    	mem_whilo_i,

	input wire[`DoubleRegBus]     	hilo_temp_i,
	input wire[1:0]               	cnt_i,

	// 与除法模块相连
	input wire[`DoubleRegBus]     	div_result_i,
	input wire                    	div_ready_i,

	// 是否转移、以及link address
	input wire[`RegBus]           	link_address_i,
	input wire                    	is_in_delayslot_i,	

	// 访存阶段的指令是否要写CP0，用来检测数据相关
  	input wire                    	mem_cp0_reg_we,
	input wire[4:0]               	mem_cp0_reg_write_addr,
	input wire[`RegBus]           	mem_cp0_reg_data,
	
	// 回写阶段的指令是否要写CP0，用来检测数据相关
  	input wire                    	wb_cp0_reg_we,
	input wire[4:0]               	wb_cp0_reg_write_addr,
	input wire[`RegBus]           	wb_cp0_reg_data,

	// 与CP0相连，读取其中CP0寄存器的值
	input wire[`RegBus]           	cp0_reg_data_i,
	output reg[4:0]               	cp0_reg_read_addr_o,

	// 向下一流水级传递，用于写CP0中的寄存器
	output reg                    	cp0_reg_we_o,
	output reg[4:0]               	cp0_reg_write_addr_o,
	output reg[`RegBus]           	cp0_reg_data_o,
	
	output reg[`RegAddrBus]       	wd_o,
	output reg                    	wreg_o,
	output reg[`RegBus]				wdata_o,

	output reg[`RegBus]           	hi_o,
	output reg[`RegBus]           	lo_o,
	output reg                    	whilo_o,
	
	output reg[`DoubleRegBus]     	hilo_temp_o,
	output reg[1:0]               	cnt_o,

	output reg[`RegBus]           	div_opdata1_o,
	output reg[`RegBus]           	div_opdata2_o,
	output reg                    	div_start_o,
	output reg                    	signed_div_o,

	// 下面新增的几个输出是为加载、存储指令准备的
	output wire[`AluOpBus]        	aluop_o,
	output wire[`RegBus]          	mem_addr_o,
	output wire[`RegBus]          	reg2_o,
	
	output wire[31:0]             	excepttype_o,
	output wire                   	is_in_delayslot_o,
	output wire[`RegBus]          	current_inst_address_o,	

	output reg						stallreq       			
	
);

	// aluop_o传递到访存阶段，用于加载、存储指令
	assign aluop_o = aluop_i;
  
	// mem_addr传递到访存阶段，是加载、存储指令对应的存储器地址
	assign mem_addr_o = reg1_i + {{16{inst_i[15]}}, inst_i[15:0]};

	// 将两个操作数也传递到访存阶段，也是为记载、存储指令准备的
	assign reg2_o = reg2_i;
 
  	assign excepttype_o = {excepttype_i[31:12], ovassert, trapassert, excepttype_i[9:8], 8'h00};
  
	assign is_in_delayslot_o = is_in_delayslot_i;
	assign current_inst_address_o = current_inst_address_i;

	// 计算逻辑操作
	always @ (*) begin
		if(rst == `RstEnable) begin
			logicout <= `ZeroWord;
		end else begin
			case (aluop_i)
				`EXE_OR_OP:			begin
					logicout <= reg1_i | reg2_i;
				end
				// ...
				default:			begin
					logicout <= `ZeroWord;
				end
			endcase
		end    // if
	end      // always

	// 计算移位操作
	always @ (*) begin
		if(rst == `RstEnable) begin
			shiftres <= `ZeroWord;
		end else begin
			case (aluop_i)
				`EXE_SLL_OP:		begin
					shiftres <= reg2_i << reg1_i[4:0] ;
				end
				// ...
				default:			begin
					shiftres <= `ZeroWord;
				end
			endcase
		end    // if
	end      // always

	// 计算加减
	assign result_sum = reg1_i + reg2_i_mux;										 

	// 计算乘法
  	assign hilo_temp = opdata1_mult * opdata2_mult;																				

	// ...

	always @ (*) begin
		stallreq = stallreq_for_madd_msub || stallreq_for_div;
	end

	// 选择执行结果
	always @ (*) begin
		wd_o <= wd_i;
		
		case ( alusel_i ) 
			`EXE_RES_LOGIC:		begin
				wdata_o <= logicout;
			end
			`EXE_RES_SHIFT:		begin
				wdata_o <= shiftres;
			end	 	
			`EXE_RES_MOVE:		begin
				wdata_o <= moveres;
			end	 	
			`EXE_RES_ARITHMETIC:	begin
				wdata_o <= arithmeticres;
			end
			`EXE_RES_MUL:			begin
				wdata_o <= mulres[31:0];
			end	 	
			`EXE_RES_JUMP_BRANCH:	begin
				wdata_o <= link_address_i;
			end	 	
			default:				begin
				wdata_o <= `ZeroWord;
			end
		endcase
	end		

	// ...

	// 写cp0寄存器
	always @ (*) begin
		if(rst == `RstEnable) begin
			cp0_reg_write_addr_o <= 5'b00000;
			cp0_reg_we_o <= `WriteDisable;
			cp0_reg_data_o <= `ZeroWord;
		end else if(aluop_i == `EXE_MTC0_OP) begin
			cp0_reg_write_addr_o <= inst_i[15:11];
			cp0_reg_we_o <= `WriteEnable;
			cp0_reg_data_o <= reg1_i;
	  end else begin
			cp0_reg_write_addr_o <= 5'b00000;
			cp0_reg_we_o <= `WriteDisable;
			cp0_reg_data_o <= `ZeroWord;
		end				
	end		

endmodule

```

```verilog

module ex_mem (

	input wire						clk,
	input wire						rst,

	// 来自控制模块的信息
	input wire[5:0]					stall,	
	input wire                   	flush,
	
	// 来自执行阶段的信息	
	input wire[`RegAddrBus]       	ex_wd,
	input wire                    	ex_wreg,
	input wire[`RegBus]				ex_wdata, 	
	input wire[`RegBus]           	ex_hi,
	input wire[`RegBus]           	ex_lo,
	input wire                    	ex_whilo, 	

	// 为实现加载、访存指令而添加
	input wire[`AluOpBus]        	ex_aluop,
	input wire[`RegBus]          	ex_mem_addr,
	input wire[`RegBus]          	ex_reg2,

	input wire[`DoubleRegBus]     	hilo_i,	
	input wire[1:0]               	cnt_i,	

	input wire                   	ex_cp0_reg_we,
	input wire[4:0]              	ex_cp0_reg_write_addr,
	input wire[`RegBus]          	ex_cp0_reg_data,	

  	input wire[31:0]             	ex_excepttype,
	input wire                   	ex_is_in_delayslot,
	input wire[`RegBus]          	ex_current_inst_address,
	
	// 送到访存阶段的信息
	output reg[`RegAddrBus]      	mem_wd,
	output reg                   	mem_wreg,
	output reg[`RegBus]				mem_wdata,
	output reg[`RegBus]          	mem_hi,
	output reg[`RegBus]          	mem_lo,
	output reg                   	mem_whilo,

  	// 为实现加载、访存指令而添加
  	output reg[`AluOpBus]        	mem_aluop,
	output reg[`RegBus]          	mem_mem_addr,
	output reg[`RegBus]          	mem_reg2,
	
	output reg                   	mem_cp0_reg_we,
	output reg[4:0]              	mem_cp0_reg_write_addr,
	output reg[`RegBus]          	mem_cp0_reg_data,
	
	output reg[31:0]            	mem_excepttype,
  	output reg                  	mem_is_in_delayslot,
	output reg[`RegBus]         	mem_current_inst_address,
		
	output reg[`DoubleRegBus]    	hilo_o,
	output reg[1:0]              	cnt_o	
	
);

	always @ (posedge clk) begin
		if(rst == `RstEnable) begin
			// ...
		end else if(flush == 1'b1 ) begin
			// ...	    	    				
		end else if(stall[3] == `Stop && stall[4] == `NoStop) begin
			// 流水线暂停插入nop
			mem_wd <= `NOPRegAddr;
			mem_wreg <= `WriteDisable;
			mem_wdata <= `ZeroWord;
			mem_hi <= `ZeroWord;
			mem_lo <= `ZeroWord;
			mem_whilo <= `WriteDisable;
			hilo_o <= hilo_i;
			cnt_o <= cnt_i;	
			mem_aluop <= `EXE_NOP_OP;
			mem_mem_addr <= `ZeroWord;
			mem_reg2 <= `ZeroWord;		
			mem_cp0_reg_we <= `WriteDisable;
			mem_cp0_reg_write_addr <= 5'b00000;
			mem_cp0_reg_data <= `ZeroWord;	
			mem_excepttype <= `ZeroWord;
			mem_is_in_delayslot <= `NotInDelaySlot;
	    	mem_current_inst_address <= `ZeroWord;						  				    
		end else if(stall[3] == `NoStop) begin
			mem_wd <= ex_wd;
			mem_wreg <= ex_wreg;
			mem_wdata <= ex_wdata;	
			mem_hi <= ex_hi;
			mem_lo <= ex_lo;
			mem_whilo <= ex_whilo;	
			hilo_o <= {`ZeroWord, `ZeroWord};
			cnt_o <= 2'b00;	
			mem_aluop <= ex_aluop;
			mem_mem_addr <= ex_mem_addr;
			mem_reg2 <= ex_reg2;
			mem_cp0_reg_we <= ex_cp0_reg_we;
			mem_cp0_reg_write_addr <= ex_cp0_reg_write_addr;
			mem_cp0_reg_data <= ex_cp0_reg_data;	
			mem_excepttype <= ex_excepttype;
			mem_is_in_delayslot <= ex_is_in_delayslot;
	    	mem_current_inst_address <= ex_current_inst_address;						
		end else begin
	    	hilo_o <= hilo_i;
			cnt_o <= cnt_i;											
		end    // if
	end      // always		

endmodule

```

### 访存

```verilog

module mem (

	input wire						rst,
	
	// 来自执行阶段的信息	
	input wire[`RegAddrBus]       	wd_i,
	input wire                    	wreg_i,
	input wire[`RegBus]				wdata_i,
	input wire[`RegBus]           	hi_i,
	input wire[`RegBus]           	lo_i,
	input wire                    	whilo_i,	

  	input wire[`AluOpBus]        	aluop_i,
	input wire[`RegBus]          	mem_addr_i,
	input wire[`RegBus]          	reg2_i,
	
	// 来自memory的信息
	input wire[`RegBus]          	mem_data_i,

	// LLbit_i是LLbit寄存器的值
	input wire                  	LLbit_i,
	// 但不一定是最新值，回写阶段可能要写LLbit，所以还要进一步判断
	input wire                  	wb_LLbit_we_i,
	input wire                  	wb_LLbit_value_i,

	// 协处理器CP0的写信号
	input wire                   	cp0_reg_we_i,
	input wire[4:0]              	cp0_reg_write_addr_i,
	input wire[`RegBus]          	cp0_reg_data_i,
	
	input wire[31:0]             	excepttype_i,
	input wire                   	is_in_delayslot_i,
	input wire[`RegBus]          	current_inst_address_i,	
	
	// CP0的各个寄存器的值，但不一定是最新的值，要防止回写阶段指令写CP0
	input wire[`RegBus]          	cp0_status_i,
	input wire[`RegBus]          	cp0_cause_i,
	input wire[`RegBus]          	cp0_epc_i,

	// 回写阶段的指令是否要写CP0，用来检测数据相关
  	input wire                   	wb_cp0_reg_we,
	input wire[4:0]              	wb_cp0_reg_write_addr,
	input wire[`RegBus]          	wb_cp0_reg_data,
	
	// 送到回写阶段的信息
	output reg[`RegAddrBus]      	wd_o,
	output reg                   	wreg_o,
	output reg[`RegBus]				wdata_o,
	output reg[`RegBus]          	hi_o,
	output reg[`RegBus]          	lo_o,
	output reg                   	whilo_o,

	output reg                   	LLbit_we_o,
	output reg                   	LLbit_value_o,

	output reg                   	cp0_reg_we_o,
	output reg[4:0]              	cp0_reg_write_addr_o,
	output reg[`RegBus]          	cp0_reg_data_o,
	
	// 送到memory的信息
	output reg[`RegBus]          	mem_addr_o,
	output wire						mem_we_o,
	output reg[3:0]              	mem_sel_o,
	output reg[`RegBus]          	mem_data_o,
	output reg                   	mem_ce_o,
	
	output reg[31:0]             	excepttype_o,
	output wire[`RegBus]          	cp0_epc_o,
	output wire                  	is_in_delayslot_o,
	
	output wire[`RegBus]         	current_inst_address_o		
	
);

  	reg LLbit;
	wire[`RegBus] 		zero32;
	reg[`RegBus]        cp0_status;
	reg[`RegBus]        cp0_cause;
	reg[`RegBus]        cp0_epc;	
	reg                 mem_we;

	assign mem_we_o = mem_we & (~(|excepttype_o));
	assign zero32 = `ZeroWord;

	assign is_in_delayslot_o = is_in_delayslot_i;
	assign current_inst_address_o = current_inst_address_i;
	assign cp0_epc_o = cp0_epc;

	always @ (*) begin
		if(rst == `RstEnable) begin
			// ...       
		end else begin
		 	wd_o <= wd_i;
			wreg_o <= wreg_i;
			wdata_o <= wdata_i;
			hi_o <= hi_i;
			lo_o <= lo_i;
			whilo_o <= whilo_i;		
			mem_we <= `WriteDisable;
			mem_addr_o <= `ZeroWord;
			mem_sel_o <= 4'b1111;
			mem_ce_o <= `ChipDisable;
			LLbit_we_o <= 1'b0;
			LLbit_value_o <= 1'b0;		
			cp0_reg_we_o <= cp0_reg_we_i;
			cp0_reg_write_addr_o <= cp0_reg_write_addr_i;
			cp0_reg_data_o <= cp0_reg_data_i;	

			// store-load指令
			case (aluop_i)
				`EXE_LW_OP:		begin
					mem_addr_o <= mem_addr_i;
					mem_we <= `WriteDisable;
					wdata_o <= mem_data_i;
					mem_sel_o <= 4'b1111;		
					mem_ce_o <= `ChipEnable;
				end
				`EXE_SW_OP:		begin
					mem_addr_o <= mem_addr_i;
					mem_we <= `WriteEnable;
					mem_data_o <= reg2_i;
					mem_sel_o <= 4'b1111;			
					mem_ce_o <= `ChipEnable;
				end
				// 条件存储
				`EXE_SC_OP:		begin
					if(LLbit == 1'b1) begin
						LLbit_we_o <= 1'b1;
						LLbit_value_o <= 1'b0;
						mem_addr_o <= mem_addr_i;
						mem_we <= `WriteEnable;
						mem_data_o <= reg2_i;
						wdata_o <= 32'b1;
						mem_sel_o <= 4'b1111;		
						mem_ce_o <= `ChipEnable;				
					end else begin
						wdata_o <= 32'b0;
					end
				end				
				default:		begin
          			// 什么也不做
				end
			endcase							
		end    // if
	end      // always

	always @ (*) begin
		if(rst == `RstEnable) begin
			cp0_status <= `ZeroWord;
		end else if((wb_cp0_reg_we == `WriteEnable) && 
					(wb_cp0_reg_write_addr == `CP0_REG_STATUS )) begin
			cp0_status <= wb_cp0_reg_data;
		end else begin
		  	cp0_status <= cp0_status_i;
		end
	end
	
	always @ (*) begin
		if(rst == `RstEnable) begin
			cp0_epc <= `ZeroWord;
		end else if((wb_cp0_reg_we == `WriteEnable) && 
					(wb_cp0_reg_write_addr == `CP0_REG_EPC )) begin
			cp0_epc <= wb_cp0_reg_data;
		end else begin
		  	cp0_epc <= cp0_epc_i;
		end
	end

  always @ (*) begin
		if(rst == `RstEnable) begin
			cp0_cause <= `ZeroWord;
		end else if((wb_cp0_reg_we == `WriteEnable) && 
					(wb_cp0_reg_write_addr == `CP0_REG_CAUSE )) begin
			cp0_cause[9:8] <= wb_cp0_reg_data[9:8];
			cp0_cause[22] <= wb_cp0_reg_data[22];
			cp0_cause[23] <= wb_cp0_reg_data[23];
		end else begin
		  	cp0_cause <= cp0_cause_i;
		end
	end

	always @ (*) begin
		if(rst == `RstEnable) begin
			excepttype_o <= `ZeroWord;
		end else begin
			excepttype_o <= `ZeroWord;
			
			if(current_inst_address_i != `ZeroWord) begin
				if(((cp0_cause[15:8] & (cp0_status[15:8])) != 8'h00) && 
				   (cp0_status[1] == 1'b0) && 
				   (cp0_status[0] == 1'b1)) begin
					excepttype_o <= 32'h00000001;    // interrupt
				end else if(excepttype_i[8] == 1'b1) begin
			  		excepttype_o <= 32'h00000008;    // syscall
				end else if(excepttype_i[9] == 1'b1) begin
					excepttype_o <= 32'h0000000a;    // inst_invalid
				end else if(excepttype_i[10] ==1'b1) begin
					excepttype_o <= 32'h0000000d;    // trap
				end else if(excepttype_i[11] == 1'b1) begin  // overflow
					excepttype_o <= 32'h0000000c;
				end else if(excepttype_i[12] == 1'b1) begin  // 返回指令
					excepttype_o <= 32'h0000000e;
				end
			end
				
		end
	end			

endmodule

```

```verilog

module mem_wb (

	input wire						clk,
	input wire						rst,
	
  	// 来自控制模块的信息	
	input wire[5:0]             	stall,	
  	input wire                  	flush,	
	// 来自访存阶段的信息		
	input wire[`RegAddrBus]     	mem_wd,
	input wire                  	mem_wreg,
	input wire[`RegBus]				mem_wdata,
	input wire[`RegBus]         	mem_hi,
	input wire[`RegBus]         	mem_lo,
	input wire                  	mem_whilo,	
		
	input wire                  	mem_LLbit_we,
	input wire                  	mem_LLbit_value,	

	input wire                   	mem_cp0_reg_we,
	input wire[4:0]              	mem_cp0_reg_write_addr,
	input wire[`RegBus]          	mem_cp0_reg_data,			

	// 送到回写阶段的信息
	output reg[`RegAddrBus]      	wb_wd,
	output reg                   	wb_wreg,
	output reg[`RegBus]			 	wb_wdata,
	output reg[`RegBus]          	wb_hi,
	output reg[`RegBus]          	wb_lo,
	output reg                   	wb_whilo,

	output reg                  	wb_LLbit_we,
	output reg                  	wb_LLbit_value,

	output reg                   	wb_cp0_reg_we,
	output reg[4:0]              	wb_cp0_reg_write_addr,
	output reg[`RegBus]          	wb_cp0_reg_data								       
	
);

	always @ (posedge clk) begin
		if(rst == `RstEnable) begin
			// ...			
		end else if(flush == 1'b1 ) begin
			// ...			  				  	  	
		end else if(stall[4] == `Stop && stall[5] == `NoStop) begin
			// 流水线暂停
			wb_wd <= `NOPRegAddr;
			wb_wreg <= `WriteDisable;
			wb_wdata <= `ZeroWord;
			wb_hi <= `ZeroWord;
			wb_lo <= `ZeroWord;
			wb_whilo <= `WriteDisable;	
			wb_LLbit_we <= 1'b0;
			wb_LLbit_value <= 1'b0;	
			wb_cp0_reg_we <= `WriteDisable;
			wb_cp0_reg_write_addr <= 5'b00000;
			wb_cp0_reg_data <= `ZeroWord;					  		  	  	  
		end else if(stall[4] == `NoStop) begin
			wb_wd <= mem_wd;
			wb_wreg <= mem_wreg;
			wb_wdata <= mem_wdata;
			wb_hi <= mem_hi;
			wb_lo <= mem_lo;
			wb_whilo <= mem_whilo;		
			wb_LLbit_we <= mem_LLbit_we;
			wb_LLbit_value <= mem_LLbit_value;		
			wb_cp0_reg_we <= mem_cp0_reg_we;
			wb_cp0_reg_write_addr <= mem_cp0_reg_write_addr;
			wb_cp0_reg_data <= mem_cp0_reg_data;			  		
		end    // if
	end      // always

endmodule

```

### 回写

把访存阶段的输出信号连接到regfile的写端口即实现回写

### 控制模块

```verilog

module ctrl (

	input wire					 rst,

	input wire[31:0]             excepttype_i,
	input wire[`RegBus]          cp0_epc_i,

	input wire                   stallreq_from_id,

  	// 来自执行阶段的暂停请求
	input wire                   stallreq_from_ex,

	output reg[`RegBus]          new_pc,
	output reg                   flush,	
	output reg[5:0]              stall       
	
);

	always @ (*) begin
		if(rst == `RstEnable) begin
			stall <= 6'b000000;
			flush <= 1'b0;
			new_pc <= `ZeroWord;
		end else if(excepttype_i != `ZeroWord) begin
			flush <= 1'b1;
			stall <= 6'b000000;

			// 跳转到异常handler
			case (excepttype_i)
				32'h00000001:		begin   //interrupt
					new_pc <= 32'h00000020;
				end
				32'h00000008:		begin   //syscall
					new_pc <= 32'h00000040;
				end
				32'h0000000a:		begin   //inst_invalid
					new_pc <= 32'h00000040;
				end
				32'h0000000d:		begin   //trap
					new_pc <= 32'h00000040;
				end
				32'h0000000c:		begin   //ov
					new_pc <= 32'h00000040;
				end
				32'h0000000e:		begin   //eret
					// 返回异常之前的pc
					new_pc <= cp0_epc_i;
				end
				default	: begin
				end
			endcase 						
		end else if(stallreq_from_ex == `Stop) begin
			stall <= 6'b001111;
			flush <= 1'b0;		
		end else if(stallreq_from_id == `Stop) begin
			stall <= 6'b000111;	
			flush <= 1'b0;		
		end else begin
			stall <= 6'b000000;
			flush <= 1'b0;
			new_pc <= `ZeroWord;		
		end    // if
	end      // always
			
endmodule

```

### 组装流水线

```verilog

module openmips(

	input wire						clk,
	input wire						rst,
	
	// 触发的硬件中断
  	input wire[5:0]                	int_i,
  
	// 从rom取指令
	input wire[`RegBus]           	rom_data_i,
	output wire[`RegBus]           	rom_addr_o,
	output wire                    	rom_ce_o,
	
  	// 读写ram
	input wire[`RegBus]           	ram_data_i,
	output wire[`RegBus]           	ram_addr_o,
	output wire[`RegBus]           	ram_data_o,
	output wire                    	ram_we_o,
	output wire[3:0]               	ram_sel_o,
	output wire[3:0]               	ram_ce_o,
	
	// 触发时钟中断
	output wire                    	timer_int_o
	
);

	wire[`InstAddrBus] pc;
	wire[`InstAddrBus] id_pc_i;
	wire[`InstBus] id_inst_i;
	
	// 连接译码阶段ID模块的输出与ID/EX模块的输入
	wire[`AluOpBus] id_aluop_o;
	wire[`AluSelBus] id_alusel_o;
	wire[`RegBus] id_reg1_o;
	wire[`RegBus] id_reg2_o;
	wire id_wreg_o;
	wire[`RegAddrBus] id_wd_o;
	wire id_is_in_delayslot_o;
	wire[`RegBus] id_link_address_o;	
	wire[`RegBus] id_inst_o;
	wire[31:0] id_excepttype_o;
	wire[`RegBus] id_current_inst_address_o;
	
	// 连接ID/EX模块的输出与执行阶段EX模块的输入
	wire[`AluOpBus] ex_aluop_i;
	wire[`AluSelBus] ex_alusel_i;
	wire[`RegBus] ex_reg1_i;
	wire[`RegBus] ex_reg2_i;
	wire ex_wreg_i;
	wire[`RegAddrBus] ex_wd_i;
	wire ex_is_in_delayslot_i;	
	wire[`RegBus] ex_link_address_i;	
	wire[`RegBus] ex_inst_i;
	wire[31:0] ex_excepttype_i;	
	wire[`RegBus] ex_current_inst_address_i;	
	
	// 连接执行阶段EX模块的输出与EX/MEM模块的输入
	wire ex_wreg_o;
	wire[`RegAddrBus] ex_wd_o;
	wire[`RegBus] ex_wdata_o;
	wire[`RegBus] ex_hi_o;
	wire[`RegBus] ex_lo_o;
	wire ex_whilo_o;
	wire[`AluOpBus] ex_aluop_o;
	wire[`RegBus] ex_mem_addr_o;
	wire[`RegBus] ex_reg2_o;
	wire ex_cp0_reg_we_o;
	wire[4:0] ex_cp0_reg_write_addr_o;
	wire[`RegBus] ex_cp0_reg_data_o; 	
	wire[31:0] ex_excepttype_o;
	wire[`RegBus] ex_current_inst_address_o;
	wire ex_is_in_delayslot_o;

	// 连接EX/MEM模块的输出与访存阶段MEM模块的输入
	wire mem_wreg_i;
	wire[`RegAddrBus] mem_wd_i;
	wire[`RegBus] mem_wdata_i;
	wire[`RegBus] mem_hi_i;
	wire[`RegBus] mem_lo_i;
	wire mem_whilo_i;		
	wire[`AluOpBus] mem_aluop_i;
	wire[`RegBus] mem_mem_addr_i;
	wire[`RegBus] mem_reg2_i;		
	wire mem_cp0_reg_we_i;
	wire[4:0] mem_cp0_reg_write_addr_i;
	wire[`RegBus] mem_cp0_reg_data_i;	
	wire[31:0] mem_excepttype_i;	
	wire mem_is_in_delayslot_i;
	wire[`RegBus] mem_current_inst_address_i;	

	// 连接访存阶段MEM模块的输出与MEM/WB模块的输入
	wire mem_wreg_o;
	wire[`RegAddrBus] mem_wd_o;
	wire[`RegBus] mem_wdata_o;
	wire[`RegBus] mem_hi_o;
	wire[`RegBus] mem_lo_o;
	wire mem_whilo_o;	
	wire mem_LLbit_value_o;
	wire mem_LLbit_we_o;
	wire mem_cp0_reg_we_o;
	wire[4:0] mem_cp0_reg_write_addr_o;
	wire[`RegBus] mem_cp0_reg_data_o;	
	wire[31:0] mem_excepttype_o;
	wire mem_is_in_delayslot_o;
	wire[`RegBus] mem_current_inst_address_o;			
	
	// 连接MEM/WB模块的输出与回写阶段的输入	
	wire wb_wreg_i;
	wire[`RegAddrBus] wb_wd_i;
	wire[`RegBus] wb_wdata_i;
	wire[`RegBus] wb_hi_i;
	wire[`RegBus] wb_lo_i;
	wire wb_whilo_i;	
	wire wb_LLbit_value_i;
	wire wb_LLbit_we_i;	
	wire wb_cp0_reg_we_i;
	wire[4:0] wb_cp0_reg_write_addr_i;
	wire[`RegBus] wb_cp0_reg_data_i;		
	wire[31:0] wb_excepttype_i;
	wire wb_is_in_delayslot_i;
	wire[`RegBus] wb_current_inst_address_i;
	
	// 连接译码阶段ID模块与通用寄存器Regfile模块
	wire reg1_read;
	wire reg2_read;
	wire[`RegBus] reg1_data;
	wire[`RegBus] reg2_data;
	wire[`RegAddrBus] reg1_addr;
	wire[`RegAddrBus] reg2_addr;

	// 连接执行阶段与hilo模块的输出，读取HI、LO寄存器
	wire[`RegBus] 	hi;
	wire[`RegBus]   lo;

  	// 连接执行阶段与ex_reg模块，用于多周期的MADD、MADDU、MSUB、MSUBU指令
	wire[`DoubleRegBus] hilo_temp_o;
	wire[1:0] cnt_o;
	
	wire[`DoubleRegBus] hilo_temp_i;
	wire[1:0] cnt_i;

	wire[`DoubleRegBus] div_result;
	wire div_ready;
	wire[`RegBus] div_opdata1;
	wire[`RegBus] div_opdata2;
	wire div_start;
	wire div_annul;
	wire signed_div;

	wire is_in_delayslot_i;
	wire is_in_delayslot_o;
	wire next_inst_in_delayslot_o;
	wire id_branch_flag_o;
	wire[`RegBus] branch_target_address;

	wire[5:0] stall;
	wire stallreq_from_id;	
	wire stallreq_from_ex;

	wire LLbit_o;

	wire[`RegBus] cp0_data_o;
	wire[4:0] cp0_raddr_i;
	
	wire flush;
	wire[`RegBus] new_pc;

	wire[`RegBus] cp0_count;
	wire[`RegBus] cp0_compare;
	wire[`RegBus] cp0_status;
	wire[`RegBus] cp0_cause;
	wire[`RegBus] cp0_epc;
	wire[`RegBus] cp0_config;
	wire[`RegBus] cp0_prid; 

	wire[`RegBus] latest_epc;
	
	// pc_reg例化
	pc_reg pc_reg0(
		.clk(clk),
		.rst(rst),
		.stall(stall),
		.flush(flush),
	  	.new_pc(new_pc),
		// 来自译码阶段的分支指令
		.branch_flag_i(id_branch_flag_o),
		.branch_target_address_i(branch_target_address),		
		.pc(pc),
		.ce(rom_ce_o)
	);
	
	// 发送pc给rom
	assign rom_addr_o = pc;

	// IF/ID模块例化
	if_id if_id0(
		.clk(clk),
		.rst(rst),
		.stall(stall),
		.flush(flush),
		.if_pc(pc),
		// rom响应的指令
		.if_inst(rom_data_i),
		.id_pc(id_pc_i),
		.id_inst(id_inst_i)      	
	);
	
	// 译码阶段ID模块
	id id0(
		.rst(rst),
		.pc_i(id_pc_i),
		.inst_i(id_inst_i),

		// 上一条指令的类型，用于判断是否load
  		.ex_aluop_i(ex_aluop_o),

		// regfile响应的寄存器值
		.reg1_data_i(reg1_data),
		.reg2_data_i(reg2_data),

	  	// read-after-write: 处于执行阶段的指令要写入的目的寄存器信息
		.ex_wreg_i(ex_wreg_o),
		.ex_wdata_i(ex_wdata_o),
		.ex_wd_i(ex_wd_o),

	  	// read-after-write: 处于访存阶段的指令要写入的目的寄存器信息
		.mem_wreg_i(mem_wreg_o),
		.mem_wdata_i(mem_wdata_o),
		.mem_wd_i(mem_wd_o),

		// 分支指令的下一条指令是延迟槽
	  	.is_in_delayslot_i(is_in_delayslot_i),

		// 送到regfile的请求信息
		.reg1_read_o(reg1_read),
		.reg2_read_o(reg2_read), 	  
		.reg1_addr_o(reg1_addr),
		.reg2_addr_o(reg2_addr), 
	  
		// 送到ID/EX模块的信息
		.aluop_o(id_aluop_o),
		.alusel_o(id_alusel_o),
		.reg1_o(id_reg1_o),
		.reg2_o(id_reg2_o),
		.wd_o(id_wd_o),
		.wreg_o(id_wreg_o),
		.excepttype_o(id_excepttype_o),
		.inst_o(id_inst_o),

		// 发送到取指阶段更改pc
	 	.next_inst_in_delayslot_o(next_inst_in_delayslot_o),	
		.branch_flag_o(id_branch_flag_o),
		.branch_target_address_o(branch_target_address),       
		.link_addr_o(id_link_address_o),
		
		.is_in_delayslot_o(id_is_in_delayslot_o),
		.current_inst_address_o(id_current_inst_address_o),
		
		// 译码阶段请求暂停流水线
		.stallreq(stallreq_from_id)		
	);

  	// 通用寄存器Regfile例化
	regfile regfile1(
		.clk (clk),
		.rst (rst),
		.we	(wb_wreg_i),
		.waddr (wb_wd_i),
		.wdata (wb_wdata_i),
		.re1 (reg1_read),
		.raddr1 (reg1_addr),
		.rdata1 (reg1_data),
		.re2 (reg2_read),
		.raddr2 (reg2_addr),
		.rdata2 (reg2_data)
	);

	// ID/EX模块
	id_ex id_ex0(
		.clk(clk),
		.rst(rst),
		
		.stall(stall),
		.flush(flush),
		
		// 从译码阶段ID模块传递的信息
		.id_aluop(id_aluop_o),
		.id_alusel(id_alusel_o),
		.id_reg1(id_reg1_o),
		.id_reg2(id_reg2_o),
		.id_wd(id_wd_o),
		.id_wreg(id_wreg_o),
		.id_link_address(id_link_address_o),
		.id_is_in_delayslot(id_is_in_delayslot_o),
		.next_inst_in_delayslot_i(next_inst_in_delayslot_o),		
		.id_inst(id_inst_o),		
		.id_excepttype(id_excepttype_o),
		.id_current_inst_address(id_current_inst_address_o),
	
		// 传递到执行阶段EX模块的信息
		.ex_aluop(ex_aluop_i),
		.ex_alusel(ex_alusel_i),
		.ex_reg1(ex_reg1_i),
		.ex_reg2(ex_reg2_i),
		.ex_wd(ex_wd_i),
		.ex_wreg(ex_wreg_i),
		.ex_link_address(ex_link_address_i),
  		.ex_is_in_delayslot(ex_is_in_delayslot_i),
		.is_in_delayslot_o(is_in_delayslot_i),
		.ex_inst(ex_inst_i),
		.ex_excepttype(ex_excepttype_i),
		.ex_current_inst_address(ex_current_inst_address_i)		
	);		
	
	// EX模块
	ex ex0(
		.rst(rst),
	
		// 送到执行阶段EX模块的信息
		.aluop_i(ex_aluop_i),
		.alusel_i(ex_alusel_i),
		.reg1_i(ex_reg1_i),
		.reg2_i(ex_reg2_i),
		.wd_i(ex_wd_i),
		.wreg_i(ex_wreg_i),
		.hi_i(hi),
		.lo_i(lo),
		.inst_i(ex_inst_i),

		.wb_hi_i(wb_hi_i),
		.wb_lo_i(wb_lo_i),
		.wb_whilo_i(wb_whilo_i),
		.mem_hi_i(mem_hi_o),
		.mem_lo_i(mem_lo_o),
		.mem_whilo_i(mem_whilo_o),

		.hilo_temp_i(hilo_temp_i),
		.cnt_i(cnt_i),

		.div_result_i(div_result),
		.div_ready_i(div_ready), 

	  	.link_address_i(ex_link_address_i),
		.is_in_delayslot_i(ex_is_in_delayslot_i),	  
		
		.excepttype_i(ex_excepttype_i),
		.current_inst_address_i(ex_current_inst_address_i),

		// 访存阶段的指令是否要写CP0，用来检测数据相关
  		.mem_cp0_reg_we(mem_cp0_reg_we_o),
		.mem_cp0_reg_write_addr(mem_cp0_reg_write_addr_o),
		.mem_cp0_reg_data(mem_cp0_reg_data_o),
	
		// 回写阶段的指令是否要写CP0，用来检测数据相关
  		.wb_cp0_reg_we(wb_cp0_reg_we_i),
		.wb_cp0_reg_write_addr(wb_cp0_reg_write_addr_i),
		.wb_cp0_reg_data(wb_cp0_reg_data_i),

		.cp0_reg_data_i(cp0_data_o),
		.cp0_reg_read_addr_o(cp0_raddr_i),
		
		// 向下一流水级传递，用于写CP0中的寄存器
		.cp0_reg_we_o(ex_cp0_reg_we_o),
		.cp0_reg_write_addr_o(ex_cp0_reg_write_addr_o),
		.cp0_reg_data_o(ex_cp0_reg_data_o),	  
			  
	  	// EX模块的输出到EX/MEM模块信息
		.wd_o(ex_wd_o),
		.wreg_o(ex_wreg_o),
		.wdata_o(ex_wdata_o),

		.hi_o(ex_hi_o),
		.lo_o(ex_lo_o),
		.whilo_o(ex_whilo_o),

		.hilo_temp_o(hilo_temp_o),
		.cnt_o(cnt_o),

		.div_opdata1_o(div_opdata1),
		.div_opdata2_o(div_opdata2),
		.div_start_o(div_start),
		.signed_div_o(signed_div),	

		.aluop_o(ex_aluop_o),
		.mem_addr_o(ex_mem_addr_o),
		.reg2_o(ex_reg2_o),
		
		.excepttype_o(ex_excepttype_o),
		.is_in_delayslot_o(ex_is_in_delayslot_o),
		.current_inst_address_o(ex_current_inst_address_o),	
		
		// 流水线暂停请求
		.stallreq(stallreq_from_ex)
	);

	// EX/MEM模块
	ex_mem ex_mem0(
		.clk(clk),
		.rst(rst),
	  
		.stall(stall),
		.flush(flush),
	  
		// 来自执行阶段EX模块的信息	
		.ex_wd(ex_wd_o),
		.ex_wreg(ex_wreg_o),
		.ex_wdata(ex_wdata_o),
		.ex_hi(ex_hi_o),
		.ex_lo(ex_lo_o),
		.ex_whilo(ex_whilo_o),		

  		.ex_aluop(ex_aluop_o),
		.ex_mem_addr(ex_mem_addr_o),
		.ex_reg2(ex_reg2_o),			
	
		.ex_cp0_reg_we(ex_cp0_reg_we_o),
		.ex_cp0_reg_write_addr(ex_cp0_reg_write_addr_o),
		.ex_cp0_reg_data(ex_cp0_reg_data_o),	

    	.ex_excepttype(ex_excepttype_o),
		.ex_is_in_delayslot(ex_is_in_delayslot_o),
		.ex_current_inst_address(ex_current_inst_address_o),	

		.hilo_i(hilo_temp_o),
		.cnt_i(cnt_o),	

		// 送到访存阶段MEM模块的信息
		.mem_wd(mem_wd_i),
		.mem_wreg(mem_wreg_i),
		.mem_wdata(mem_wdata_i),
		.mem_hi(mem_hi_i),
		.mem_lo(mem_lo_i),
		.mem_whilo(mem_whilo_i),
	
		.mem_cp0_reg_we(mem_cp0_reg_we_i),
		.mem_cp0_reg_write_addr(mem_cp0_reg_write_addr_i),
		.mem_cp0_reg_data(mem_cp0_reg_data_i),

  		.mem_aluop(mem_aluop_i),
		.mem_mem_addr(mem_mem_addr_i),
		.mem_reg2(mem_reg2_i),
		
		.mem_excepttype(mem_excepttype_i),
  		.mem_is_in_delayslot(mem_is_in_delayslot_i),
		.mem_current_inst_address(mem_current_inst_address_i),
				
		.hilo_o(hilo_temp_i),
		.cnt_o(cnt_i)			       	
	);
	
  	// MEM模块例化
	mem mem0(
		.rst(rst),
	
		// 来自EX/MEM模块的信息	
		.wd_i(mem_wd_i),
		.wreg_i(mem_wreg_i),
		.wdata_i(mem_wdata_i),
		.hi_i(mem_hi_i),
		.lo_i(mem_lo_i),
		.whilo_i(mem_whilo_i),		

  		.aluop_i(mem_aluop_i),
		.mem_addr_i(mem_mem_addr_i),
		.reg2_i(mem_reg2_i),
	
		// 来自memory的信息
		.mem_data_i(ram_data_i),

		// LLbit_i是LLbit寄存器的值
		.LLbit_i(LLbit_o),
		// 但不一定是最新值，回写阶段可能要写LLbit，所以还要进一步判断
		.wb_LLbit_we_i(wb_LLbit_we_i),
		.wb_LLbit_value_i(wb_LLbit_value_i),

		.cp0_reg_we_i(mem_cp0_reg_we_i),
		.cp0_reg_write_addr_i(mem_cp0_reg_write_addr_i),
		.cp0_reg_data_i(mem_cp0_reg_data_i),

    	.excepttype_i(mem_excepttype_i),
		.is_in_delayslot_i(mem_is_in_delayslot_i),
		.current_inst_address_i(mem_current_inst_address_i),	
		
		.cp0_status_i(cp0_status),
		.cp0_cause_i(cp0_cause),
		.cp0_epc_i(cp0_epc),
		
		// 回写阶段的指令是否要写CP0，用来检测数据相关
  		.wb_cp0_reg_we(wb_cp0_reg_we_i),
		.wb_cp0_reg_write_addr(wb_cp0_reg_write_addr_i),
		.wb_cp0_reg_data(wb_cp0_reg_data_i),	  

		.LLbit_we_o(mem_LLbit_we_o),
		.LLbit_value_o(mem_LLbit_value_o),

		.cp0_reg_we_o(mem_cp0_reg_we_o),
		.cp0_reg_write_addr_o(mem_cp0_reg_write_addr_o),
		.cp0_reg_data_o(mem_cp0_reg_data_o),			
	  
		// 送到MEM/WB模块的信息
		.wd_o(mem_wd_o),
		.wreg_o(mem_wreg_o),
		.wdata_o(mem_wdata_o),
		.hi_o(mem_hi_o),
		.lo_o(mem_lo_o),
		.whilo_o(mem_whilo_o),
		
		// 送到memory的信息
		.mem_addr_o(ram_addr_o),
		.mem_we_o(ram_we_o),
		.mem_sel_o(ram_sel_o),
		.mem_data_o(ram_data_o),
		.mem_ce_o(ram_ce_o),
		
		.excepttype_o(mem_excepttype_o),
		.cp0_epc_o(latest_epc),
		.is_in_delayslot_o(mem_is_in_delayslot_o),
		.current_inst_address_o(mem_current_inst_address_o)		
	);

  	// MEM/WB模块
	mem_wb mem_wb0(
		.clk(clk),
		.rst(rst),

		.stall(stall),
		.flush(flush),

		// 来自访存阶段MEM模块的信息	
		.mem_wd(mem_wd_o),
		.mem_wreg(mem_wreg_o),
		.mem_wdata(mem_wdata_o),
		.mem_hi(mem_hi_o),
		.mem_lo(mem_lo_o),
		.mem_whilo(mem_whilo_o),		

		.mem_LLbit_we(mem_LLbit_we_o),
		.mem_LLbit_value(mem_LLbit_value_o),	
	
		.mem_cp0_reg_we(mem_cp0_reg_we_o),
		.mem_cp0_reg_write_addr(mem_cp0_reg_write_addr_o),
		.mem_cp0_reg_data(mem_cp0_reg_data_o),					
	
		// 送到回写阶段的信息
		.wb_wd(wb_wd_i),
		.wb_wreg(wb_wreg_i),
		.wb_wdata(wb_wdata_i),
		.wb_hi(wb_hi_i),
		.wb_lo(wb_lo_i),
		.wb_whilo(wb_whilo_i),

		.wb_LLbit_we(wb_LLbit_we_i),
		.wb_LLbit_value(wb_LLbit_value_i),
		
		.wb_cp0_reg_we(wb_cp0_reg_we_i),
		.wb_cp0_reg_write_addr(wb_cp0_reg_write_addr_i),
		.wb_cp0_reg_data(wb_cp0_reg_data_i)						
									       	
	);

	hilo_reg hilo_reg0(
		.clk(clk),
		.rst(rst),
	
		// 写端口
		.we(wb_whilo_i),
		.hi_i(wb_hi_i),
		.lo_i(wb_lo_i),
	
		// 读端口1
		.hi_o(hi),
		.lo_o(lo)	
	);
	
	ctrl ctrl0(
		.rst(rst),
	
		.excepttype_i(mem_excepttype_o),
		.cp0_epc_i(latest_epc),
 
		// 暂停流水线请求
		.stallreq_from_id(stallreq_from_id),
		.stallreq_from_ex(stallreq_from_ex),

		.new_pc(new_pc),
		.flush(flush),
		.stall(stall)       	
	);

	div div0(
		.clk(clk),
		.rst(rst),
	
		.signed_div_i(signed_div),
		.opdata1_i(div_opdata1),
		.opdata2_i(div_opdata2),
		.start_i(div_start),
		.annul_i(flush),
	
		.result_o(div_result),
		.ready_o(div_ready)
	);

	LLbit_reg LLbit_reg0(
		.clk(clk),
		.rst(rst),
	  	.flush(flush),
	  
		// 写端口
		.LLbit_i(wb_LLbit_value_i),
		.we(wb_LLbit_we_i),
	
		// 读端口1
		.LLbit_o(LLbit_o)
	);

	cp0_reg cp0_reg0(
		.clk(clk),
		.rst(rst),
		
		.we_i(wb_cp0_reg_we_i),
		.waddr_i(wb_cp0_reg_write_addr_i),
		.raddr_i(cp0_raddr_i),
		.data_i(wb_cp0_reg_data_i),
		
		.excepttype_i(mem_excepttype_o),
		.int_i(int_i),
		.current_inst_addr_i(mem_current_inst_address_o),
		.is_in_delayslot_i(mem_is_in_delayslot_o),
		
		.data_o(cp0_data_o),
		.count_o(cp0_count),
		.compare_o(cp0_compare),
		.status_o(cp0_status),
		.cause_o(cp0_cause),
		.epc_o(cp0_epc),
		.config_o(cp0_config),
		.prid_o(cp0_prid),
		
		.timer_int_o(timer_int_o)  			
	);
	
endmodule

```

## 总结

* cpu是一个复杂的FSM，包含存储状态的时序电路和更新状态以及计算输出的组合电路 
* cpu的状态包括regfile、pc、hilo寄存器、LLbit寄存器、cp0寄存器等
* cpu的输入是rom中存储的指令和ram中存储的数据，cpu的输出是ram中的数据
* cpu的组合电路拆分成五阶段的流水线，相连的阶段插入时序电路保存传给下一个阶段的数据
* 相邻指令发生数据依赖时，沿着流水线反向传递数据
* 间隔指令发生数据依赖时，暂停流水线直到产生可反向传递的数据


