---
layout: post
title:  "k8s"
date:   2023-05-04 00:22:07 +0000
categories: jekyll
tags: k8s
---

# 搭建测试环境

## 测试环境设置

### 安装docker

https://docs.docker.com/engine/install/ubuntu/

启动dockerd: `sudo service docker start`

### 安装cri-dockerd

```shell

wget https://github.com/Mirantis/cri-dockerd/releases/download/v0.3.1/cri-dockerd-0.3.1.amd64.tgz
tar -xvf ./cri-dockerd-0.3.1.amd64.tgz
sudo install -o root -g root -m 0755 cri-dockerd/cri-dockerd /usr/bin/cri-dockerd

# 启动cri-dockerd
sudo /usr/bin/cri-dockerd 2> /dev/null &

```

### 启动测试环境

```shell
# 启动测试环境
sudo hack/local-up-cluster.sh -O

# 获取集群成员列表
kubectl --kubeconfig=/var/run/kubernetes/admin.kubeconfig get nodes

```

---

## debug环境设置

### 参考测试环境脚本

分析`hack/local-up-cluster.sh`的启动过程

```shell

# 编译
make -C "${KUBE_ROOT}" \
    WHAT="cmd/kubectl \
    cmd/kube-apiserver \
    cmd/kube-controller-manager \
    cmd/cloud-controller-manager \
    cmd/kubelet \
    cmd/kube-proxy \
    cmd/kube-scheduler"

start_etcd
{
      etcd --advertise-client-urls "${KUBE_INTEGRATION_ETCD_URL}" \
      --data-dir "${ETCD_DIR}" \
      --listen-client-urls "${KUBE_INTEGRATION_ETCD_URL}" \
      --log-level="${ETCD_LOGLEVEL}" 2> "${ETCD_LOGFILE}"
}

set_service_accounts
{
    mkdir -p "$(dirname "${SERVICE_ACCOUNT_KEY}")"
    openssl genrsa -out "${SERVICE_ACCOUNT_KEY}" 2048
}

start_apiserver
{
    ${CONTROLPLANE_SUDO} "${GO_OUT}/kube-apiserver" "${authorizer_arg}" "${priv_arg}" ${runtime_config} \
      ${cloud_config_arg} \
      "${advertise_address}" \
      "${node_port_range}" \
      --v="${LOG_LEVEL}" \
      --vmodule="${LOG_SPEC}" \
      --audit-policy-file="${AUDIT_POLICY_FILE}" \
      --audit-log-path="${LOG_DIR}/kube-apiserver-audit.log" \
      --authorization-webhook-config-file="${AUTHORIZATION_WEBHOOK_CONFIG_FILE}" \
      --authentication-token-webhook-config-file="${AUTHENTICATION_WEBHOOK_CONFIG_FILE}" \
      --cert-dir="${CERT_DIR}" \
      --egress-selector-config-file="${EGRESS_SELECTOR_CONFIG_FILE:-}" \
      --client-ca-file="${CERT_DIR}/client-ca.crt" \
      --kubelet-client-certificate="${CERT_DIR}/client-kube-apiserver.crt" \
      --kubelet-client-key="${CERT_DIR}/client-kube-apiserver.key" \
      --service-account-key-file="${SERVICE_ACCOUNT_KEY}" \
      --service-account-lookup="${SERVICE_ACCOUNT_LOOKUP}" \
      --service-account-issuer="https://kubernetes.default.svc" \
      --service-account-jwks-uri="https://kubernetes.default.svc/openid/v1/jwks" \
      --service-account-signing-key-file="${SERVICE_ACCOUNT_KEY}" \
      --enable-admission-plugins="${ENABLE_ADMISSION_PLUGINS}" \
      --disable-admission-plugins="${DISABLE_ADMISSION_PLUGINS}" \
      --admission-control-config-file="${ADMISSION_CONTROL_CONFIG_FILE}" \
      --bind-address="${API_BIND_ADDR}" \
      --secure-port="${API_SECURE_PORT}" \
      --tls-cert-file="${CERT_DIR}/serving-kube-apiserver.crt" \
      --tls-private-key-file="${CERT_DIR}/serving-kube-apiserver.key" \
      --storage-backend="${STORAGE_BACKEND}" \
      --storage-media-type="${STORAGE_MEDIA_TYPE}" \
      --etcd-servers="http://${ETCD_HOST}:${ETCD_PORT}" \
      --service-cluster-ip-range="${SERVICE_CLUSTER_IP_RANGE}" \
      --feature-gates="${FEATURE_GATES}" \
      --external-hostname="${EXTERNAL_HOSTNAME}" \
      --requestheader-username-headers=X-Remote-User \
      --requestheader-group-headers=X-Remote-Group \
      --requestheader-extra-headers-prefix=X-Remote-Extra- \
      --requestheader-client-ca-file="${CERT_DIR}/request-header-ca.crt" \
      --requestheader-allowed-names=system:auth-proxy \
      --proxy-client-cert-file="${CERT_DIR}/client-auth-proxy.crt" \
      --proxy-client-key-file="${CERT_DIR}/client-auth-proxy.key" \
      --cors-allowed-origins="${API_CORS_ALLOWED_ORIGINS}" >"${APISERVER_LOG}"

    kube::util::write_client_kubeconfig "${CONTROLPLANE_SUDO}" "${CERT_DIR}" "${ROOT_CA_FILE}" "${API_HOST}" "${API_SECURE_PORT}" admin
    ${CONTROLPLANE_SUDO} chown "${USER}" "${CERT_DIR}/client-admin.key" # make readable for kubectl
    kube::util::write_client_kubeconfig "${CONTROLPLANE_SUDO}" "${CERT_DIR}" "${ROOT_CA_FILE}" "${API_HOST}" "${API_SECURE_PORT}" controller
    kube::util::write_client_kubeconfig "${CONTROLPLANE_SUDO}" "${CERT_DIR}" "${ROOT_CA_FILE}" "${API_HOST}" "${API_SECURE_PORT}" scheduler

    ${KUBECTL} --kubeconfig "${CERT_DIR}/admin.kubeconfig" create clusterrolebinding kube-apiserver-kubelet-admin --clusterrole=system:kubelet-api-admin --user=kube-apiserver

    ${KUBECTL} --kubeconfig "${CERT_DIR}/admin.kubeconfig" create clusterrolebinding kubelet-csr --clusterrole=system:certificates.k8s.io:certificatesigningrequests:selfnodeclient --group=system:nodes

    ${KUBECTL} config set-cluster local-up-cluster --kubeconfig="${CERT_DIR}/admin-kube-aggregator.kubeconfig" --server="https://${API_HOST_IP}:31090"
}

start_controller_manager
{
    ${CONTROLPLANE_SUDO} "${GO_OUT}/kube-controller-manager" \
      --v="${LOG_LEVEL}" \
      --vmodule="${LOG_SPEC}" \
      --service-account-private-key-file="${SERVICE_ACCOUNT_KEY}" \
      --service-cluster-ip-range="${SERVICE_CLUSTER_IP_RANGE}" \
      --root-ca-file="${ROOT_CA_FILE}" \
      --cluster-signing-cert-file="${CLUSTER_SIGNING_CERT_FILE}" \
      --cluster-signing-key-file="${CLUSTER_SIGNING_KEY_FILE}" \
      --enable-hostpath-provisioner="${ENABLE_HOSTPATH_PROVISIONER}" \
      --pvclaimbinder-sync-period="${CLAIM_BINDER_SYNC_PERIOD}" \
      --feature-gates="${FEATURE_GATES}" \
      "${cloud_config_arg[@]}" \
      --authentication-kubeconfig "${CERT_DIR}"/controller.kubeconfig \
      --authorization-kubeconfig "${CERT_DIR}"/controller.kubeconfig \
      --kubeconfig "${CERT_DIR}"/controller.kubeconfig \
      --use-service-account-credentials \
      --controllers="${KUBE_CONTROLLERS}" \
      --leader-elect=false \
      --cert-dir="${CERT_DIR}" \
      --master="https://${API_HOST}:${API_SECURE_PORT}" >"${CTLRMGR_LOG}"
}

start_kubescheduler
{
    ${CONTROLPLANE_SUDO} "${GO_OUT}/kube-scheduler" \
      --v="${LOG_LEVEL}" \
      --config=/tmp/kube-scheduler.yaml \
      --feature-gates="${FEATURE_GATES}" \
      --authentication-kubeconfig "${CERT_DIR}"/scheduler.kubeconfig \
      --authorization-kubeconfig "${CERT_DIR}"/scheduler.kubeconfig \
      --master="https://${API_HOST}:${API_SECURE_PORT}" >"${SCHEDULER_LOG}"
}

start_dns_addon
{
    ${KUBECTL} --kubeconfig="${CERT_DIR}/admin.kubeconfig" --namespace=kube-system create -f dns.yaml
}

start_kubelet
{
    all_kubelet_flags=(
      "--v=${LOG_LEVEL}"
      "--vmodule=${LOG_SPEC}"
      "--container-runtime=${CONTAINER_RUNTIME}"
      "--hostname-override=${HOSTNAME_OVERRIDE}"
      "${cloud_config_arg[@]}"
      "--bootstrap-kubeconfig=${CERT_DIR}/kubelet.kubeconfig"
      "--kubeconfig=${CERT_DIR}/kubelet-rotated.kubeconfig"
      ${container_runtime_endpoint_args[@]+"${container_runtime_endpoint_args[@]}"}
      ${image_service_endpoint_args[@]+"${image_service_endpoint_args[@]}"}
      ${KUBELET_FLAGS}
    )

    sudo -E "${GO_OUT}/kubelet" "${all_kubelet_flags[@]}" \
      --config=/tmp/kubelet.yaml >"${KUBELET_LOG}"
}

start_kubeproxy
{
    sudo "${GO_OUT}/kube-proxy" \
      --v="${LOG_LEVEL}" \
      --config=/tmp/kube-proxy.yaml \
      --master="https://${API_HOST}:${API_SECURE_PORT}" >"${PROXY_LOG}"
}

create_storage_class
{
    ${KUBECTL} --kubeconfig="${CERT_DIR}/admin.kubeconfig" create -f "${CLASS_FILE}"
}

```

---

### vscode配置

```json

{
    "version": "0.2.0",
    "configurations": [
        // 0. sudo service docker start; sleep 5; sudo /usr/bin/cri-dockerd 2> /dev/null &
        // 1. etcd --data-dir /tmp/tmp.SuYoMB6tEG 2> /dev/null &
        // 2. kube-apiserver
        {
            "name": "kube-apiserver",
            "type": "go",
            "request": "launch",
            "mode": "auto",
            "program": "cmd/kube-apiserver",
            "args": [
                "--authorization-mode=Node,RBAC",
                "--v=3",
                "--audit-policy-file=${workspaceFolder}/etc/kube-audit-policy-file",
                "--cert-dir=${workspaceFolder}/etc/cert",
                "--egress-selector-config-file=${workspaceFolder}/etc/kube_egress_selector_configuration.yaml",
                "--client-ca-file=${workspaceFolder}/etc/cert/client-ca.crt",
                "--kubelet-client-certificate=${workspaceFolder}/etc/cert/client-kube-apiserver.crt",
                "--kubelet-client-key=${workspaceFolder}/etc/cert/client-kube-apiserver.key",
                "--service-account-key-file=${workspaceFolder}/etc/kube-serviceaccount.key",
                "--service-account-lookup=true",
                "--service-account-issuer=https://kubernetes.default.svc",
                "--service-account-jwks-uri=https://kubernetes.default.svc/openid/v1/jwks",
                "--service-account-signing-key-file=${workspaceFolder}/etc/kube-serviceaccount.key",
                "--enable-admission-plugins=NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,Priority,MutatingAdmissionWebhook,ValidatingAdmissionWebhook,ResourceQuota,NodeRestriction",
                "--bind-address=0.0.0.0",
                "--secure-port=6443",
                "--tls-cert-file=${workspaceFolder}/etc/cert/serving-kube-apiserver.crt",
                "--tls-private-key-file=${workspaceFolder}/etc/cert/serving-kube-apiserver.key",
                "--storage-backend=etcd3",
                "--storage-media-type=application/vnd.kubernetes.protobuf",
                "--etcd-servers=http://127.0.0.1:2379",
                "--service-cluster-ip-range=10.0.0.0/24",
                "--feature-gates=AllAlpha=false",
                "--external-hostname=localhost",
                "--requestheader-username-headers=X-Remote-User",
                "--requestheader-group-headers=X-Remote-Group",
                "--requestheader-extra-headers-prefix=X-Remote-Extra-",
                "--requestheader-client-ca-file=${workspaceFolder}/etc/cert/request-header-ca.crt",
                "--requestheader-allowed-names=system:auth-proxy",
                "--proxy-client-cert-file=${workspaceFolder}/etc/cert/client-auth-proxy.crt",
                "--proxy-client-key-file=${workspaceFolder}/etc/cert/client-auth-proxy.key",
                "--cors-allowed-origins=/127.0.0.1(:[0-9]+)?$,/localhost(:[0-9]+)?$"
            ]
        },
        // _output/bin/kubectl --kubeconfig etc/cert/admin.kubeconfig create clusterrolebinding kube-apiserver-kubelet-admin --clusterrole=system:kubelet-api-admin --user=kube-apiserver
        // _output/bin/kubectl --kubeconfig etc/cert/admin.kubeconfig create clusterrolebinding kubelet-csr --clusterrole=system:certificates.k8s.io:certificatesigningrequests:selfnodeclient --group=system:nodes
        // _output/bin/kubectl --kubeconfig etc/cert/admin-kube-aggregator.kubeconfig config set-cluster local-up-cluster --server="https://127.0.0.1:31090"
        // 3. kube-controller-manager
        {
            "name": "kube-controller-manager",
            "type": "go",
            "request": "launch",
            "mode": "auto",
            "program": "cmd/kube-controller-manager",
            "args": [
                "--v=3",
                "--service-account-private-key-file=${workspaceFolder}/etc/kube-serviceaccount.key",
                "--service-cluster-ip-range=10.0.0.0/24",
                "--root-ca-file=${workspaceFolder}/etc/cert/server-ca.crt",
                "--cluster-signing-cert-file=${workspaceFolder}/etc/cert/client-ca.crt",
                "--cluster-signing-key-file=${workspaceFolder}/etc/cert/client-ca.key",
                "--enable-hostpath-provisioner=false",
                "--pvclaimbinder-sync-period=15s",
                "--feature-gates=AllAlpha=false",
                "--authentication-kubeconfig", "${workspaceFolder}/etc/cert/controller.kubeconfig",
                "--authorization-kubeconfig", "${workspaceFolder}/etc/cert/controller.kubeconfig",
                "--kubeconfig", "${workspaceFolder}/etc/cert/controller.kubeconfig",
                "--use-service-account-credentials",
                "--controllers=*",
                "--leader-elect=false",
                "--cert-dir=${workspaceFolder}/etc/cert",
                "--master=https://localhost:6443"
            ]
        },
        // 4. kube-scheduler
        {
            "name": "kube-scheduler",
            "type": "go",
            "request": "launch",
            "mode": "auto",
            "program": "cmd/kube-scheduler",
            "args": [
                "--v=3",
                "--config=${workspaceFolder}/etc/kube-scheduler.yaml",
                "--feature-gates=AllAlpha=false",
                "--authentication-kubeconfig", "${workspaceFolder}/etc/cert/scheduler.kubeconfig",
                "--authorization-kubeconfig", "${workspaceFolder}/etc/cert/scheduler.kubeconfig",
                "--master=https://localhost:6443"
            ]
        },
        // 5. start_dns_addon
        // _output/bin/kubectl --kubeconfig etc/cert/admin.kubeconfig create --namespace=kube-system -f etc/dns.yaml
        // 6. kubelet
        {
            "name": "kubelet",
            "type": "go",
            "request": "launch",
            "mode": "auto",
            "program": "cmd/kubelet",
            "asRoot": true,
            "console": "integratedTerminal",
            "args": [
                "--v=3",
                "--root-dir=${workspaceFolder}/etc/kubelet",
                "--cert-dir=${workspaceFolder}/etc/kubelet/pki",
                "--container-runtime=remote",
                "--container-runtime-endpoint=unix:///run/cri-dockerd.sock",
                "--hostname-override=127.0.0.1",
                "--bootstrap-kubeconfig=${workspaceFolder}/etc/cert/kubelet.kubeconfig",
                "--kubeconfig=${workspaceFolder}/etc/cert/kubelet-rotated.kubeconfig",
                "--config=${workspaceFolder}/etc/kubelet.yaml"
            ]
        },
        // 7. kube-proxy
        {
            "name": "kube-proxy",
            "type": "go",
            "request": "launch",
            "mode": "auto",
            "program": "cmd/kube-proxy",
            // "asRoot": true,
            // "console": "integratedTerminal",
            "args": [
                "--v=3",
                "--config=${workspaceFolder}/etc/kube-proxy.yaml",
                "--master=https://localhost:6443"
            ]
        },
        // 8. create_storage_class
        // _output/bin/kubectl --kubeconfig etc/cert/admin.kubeconfig create -f cluster/addons/storage-class/local/default.yaml
        {
            "name": "kubectl",
            "type": "go",
            "request": "launch",
            "mode": "auto",
            "program": "cmd/kubectl",
            "env": {
                "KUBECONFIG": "${workspaceFolder}/etc/cert/admin.kubeconfig"
            },
            "args": [
                "get", "pods"
            ],
        }
    ]
}

```

---

# 系统组件

## The control plane

A Kubernetes control plane node runs a collection of system services that make up the control plane of the cluster. These services are the brains of the cluster where all the control and scheduling decisions happen. Behind the scenes, these services include `the API server`, `the cluster store`, `scheduler`, and `core controllers`. 

`The API server` is the front-end into the control plane and all instructions and communication pass through it. 

![control-plane](/assets/images/2023-05-04/control-plane.png)

---

### The API server

All communication, between all components, must go through the API server. It’s important to understand that internal system components, as well as external user components, all communicate through `the API server` – all roads lead to the API Server.

It exposes a `RESTful API` that you `POST YAML` configuration files to over HTTPS. These YAML files, which we sometimes call manifests, describe the desired state of an application. This desired state includes things like which container images to use, which ports to expose, and how many Pod replicas to run.

All requests to the API server are subject to authentication and authorization. Once these are done, the config in the YAML file is validated, persisted to the cluster store, and changes are scheduled to the worker nodes.

---

### The cluster store

`The cluster store` is the only stateful part of the control plane and persistently stores the entire configuration and state of the cluster. As such, it’s a vital component of every Kubernetes cluster – `no cluster store, no cluster`.

The cluster store is currently `based on etcd`, a popular distributed database. As it’s the single source of truth for a cluster, you should run between 3-5 etcd replicas for high-availability, and you should provide adequate ways to recover when things go wrong.

---

### The controller manager

`The controller manager` implements all the background controllers that monitor cluster components and respond to events.

Architecturally, the controller manager is a controller of controllers, meaning it spawns all the core controllers and monitors them.

Some of the core controllers include `the Deployment controller`, `the StatefulSet controller`, and `the ReplicaSet controller`. Each one is responsible for a small subset of cluster intelligence and runs as a background watch-loop constantly watching the API Server for changes.

`The goal of each controller is to ensure the observed state of the cluster matches the desired state`. 

The following logic, implemented by each controller, is at the heart of Kubernetes and declarative design patterns:

1. Obtain desired state
2. Observe current state
3. Determine differences
4. Reconcile differences

Each controller is also extremely specialized and only interested in its own little corner of the Kubernetes cluster. No attempt is made to over-complicate design by implementing awareness of other parts of the system. This is key to the distributed design of Kubernetes and adheres to the Unix philosophy of building complex systems from small specialized parts.

---

### The scheduler

At a high level, `the scheduler` watches the API server for new work tasks and assigns them to appropriate healthy worker nodes. Behind the scenes, it implements complex logic that `filters out nodes incapable` of running tasks, and then `ranks the nodes that are capable`. The ranking system is complex, but the node with the highest-ranking score is selected to run the task.

When identifying nodes capable of running a task, the scheduler performs various predicate checks. These include: `is the node tainted`, `are there any affinity or anti-affinity rules`, `is the required network port available on the node`, `does it have sufficient available resources` etc. Any node incapable of running the task is ignored, and those remaining are ranked according to things such as does it already have the required image, how much free resource does it have, how many tasks is it currently running. Each is worth points, and the node with the most points is selected to run the task.

If the scheduler doesn’t find a suitable node, the task isn’t scheduled and gets marked as pending.

The scheduler is only responsible for picking the nodes to run tasks, it isn’t responsible for running them. A task is normally a Pod/container. 

---

## Worker nodes

`Worker nodes` are where user applications run.
At a high-level they do three things:

1. Watch the API server for new work assignments
2. Execute work assignments
3. Report back to the control plane (via the API server)

![work-node](/assets/images/2023-05-04/work-node.png)

---

### Kubelet

The `kubelet` is the main Kubernetes agent and runs on every worker node.

When you join a node to a cluster, the process installs the kubelet, which is then responsible for `registering it with the cluster`. This registers the node’s CPU, memory, and storage into the wider cluster pool.

One of the main jobs of the kubelet is to `watch the API server for new work tasks`. Any time it sees one, it executes the task and maintains a reporting channel back to the control plane.

If a kubelet can’t run a task, it reports back to the control plane and lets the control plane decide what actions to take. For example, if a kubelet cannot execute a task, it simply reports back to the control plane and the control plane decides what to do.

---

### Container runtime

The kubelet needs a container runtime to perform container-related tasks. This includes pulling images and starting and stopping containers.

In the early days, `Kubernetes` had native support for `Docker`. More recently, it’s moved to a plugin model called the `Container Runtime Interface (CRI)`. At a high-level, the CRI masks the internal machinery of Kubernetes and exposes a clean documented interface for 3rd-party container runtimes to plug into.

---

### Kube-proxy

The `kube-proxy` runs on every node and is responsible for `local cluster networking`. It ensures each node gets its own unique IP address, and it implements local iptables or IPVS rules to handle routing and load-balancing of traffic. 

---

## Kubernetes DNS

Every Kubernetes cluster has an internal `DNS service` that is vital to service discovery. 

The cluster’s DNS service has a `static IP address` that is hard-coded into every Pod on the cluster. This ensures every app can locate it and use it for discovery. Service registration is also automatic. This means apps don’t need to be coded with the intelligence to register with Kubernetes service discovery.

Cluster DNS is based on the open-source `CoreDNS` project (https://coredns.io/).

---

# 实现机制分析

## kube-apiserver

```go

func NewAPIServerCommand() *cobra.Command {
	s := options.NewServerRunOptions()
    cmd := &cobra.Command{
		Use: "kube-apiserver",
        RunE: func(cmd *cobra.Command, args []string) error {
			// set default options
			completedOptions := Complete(s)
			return Run(completedOptions, genericapiserver.SetupSignalHandler())
            {
                server := CreateServerChain(completeOptions)
                {
                    // 自定义资源扩展服务
                    apiExtensionsServer := createAPIExtensionsServer(...)

                    // 核心服务
                    kubeAPIServer := CreateKubeAPIServer(kubeAPIServerConfig, apiExtensionsServer.GenericAPIServer)
                    {
                        kubeAPIServer := kubeAPIServerConfig.Complete().New(delegateAPIServer)
                        {
                            s := c.GenericConfig.New("kube-apiserver", delegationTarget)

                            m := &Instance{
                                GenericAPIServer:          s,
                                ClusterAuthenticationInfo: c.ExtraConfig.ClusterAuthenticationInfo,
                            }

                            m.InstallLegacyAPI(&c, c.GenericConfig.RESTOptionsGetter)
                            {
                                legacyRESTStorageProvider := corerest.LegacyRESTStorageProvider{
                                    StorageFactory:              c.ExtraConfig.StorageFactory,
                                    ProxyTransport:              c.ExtraConfig.ProxyTransport,
                                    KubeletClientConfig:         c.ExtraConfig.KubeletClientConfig,
                                    EventTTL:                    c.ExtraConfig.EventTTL,
                                    ServiceIPRange:              c.ExtraConfig.ServiceIPRange,
                                    SecondaryServiceIPRange:     c.ExtraConfig.SecondaryServiceIPRange,
                                    ServiceNodePortRange:        c.ExtraConfig.ServiceNodePortRange,
                                    LoopbackClientConfig:        c.GenericConfig.LoopbackClientConfig,
                                    ServiceAccountIssuer:        c.ExtraConfig.ServiceAccountIssuer,
                                    ExtendExpiration:            c.ExtraConfig.ExtendExpiration,
                                    ServiceAccountMaxExpiration: c.ExtraConfig.ServiceAccountMaxExpiration,
                                    APIAudiences:                c.GenericConfig.Authentication.APIAudiences,
                                }

                                legacyRESTStorage, apiGroupInfo := legacyRESTStorageProvider.NewLegacyRESTStorage(...)
                                {
                                    apiGroupInfo := genericapiserver.APIGroupInfo{
                                        PrioritizedVersions:          legacyscheme.Scheme.PrioritizedVersionsForGroup(""),
                                        VersionedResourcesStorageMap: map[string]map[string]rest.Storage{},
                                        Scheme:                       legacyscheme.Scheme,
                                        ParameterCodec:               legacyscheme.ParameterCodec,
                                        NegotiatedSerializer:         legacyscheme.Codecs,
                                    }

                                    // apiserver以资源对象为核心构造restful风格的api
                                    // 每个资源相当于rdb中的表的概念，存储在etcd中
                                    storage := map[string]rest.Storage{}
                                    if resource := "pods"; apiResourceConfigSource.ResourceEnabled(corev1.SchemeGroupVersion.WithResource(resource)) {
                                        storage[resource] = podStorage.Pod
                                        storage[resource+"/attach"] = podStorage.Attach
                                        storage[resource+"/status"] = podStorage.Status
                                        storage[resource+"/log"] = podStorage.Log
                                        storage[resource+"/exec"] = podStorage.Exec
                                        storage[resource+"/portforward"] = podStorage.PortForward
                                        storage[resource+"/proxy"] = podStorage.Proxy
                                        storage[resource+"/binding"] = podStorage.Binding
                                        if podStorage.Eviction != nil {
                                            storage[resource+"/eviction"] = podStorage.Eviction
                                        }
                                        storage[resource+"/ephemeralcontainers"] = podStorage.EphemeralContainers

                                    }
                                    if resource := "bindings"; apiResourceConfigSource.ResourceEnabled(corev1.SchemeGroupVersion.WithResource(resource)) {
                                        storage[resource] = podStorage.LegacyBinding
                                    }

                                    if resource := "podtemplates"; apiResourceConfigSource.ResourceEnabled(corev1.SchemeGroupVersion.WithResource(resource)) {
                                        storage[resource] = podTemplateStorage
                                    }

                                    if resource := "replicationcontrollers"; apiResourceConfigSource.ResourceEnabled(corev1.SchemeGroupVersion.WithResource(resource)) {
                                        storage[resource] = controllerStorage.Controller
                                        storage[resource+"/status"] = controllerStorage.Status
                                        if legacyscheme.Scheme.IsVersionRegistered(schema.GroupVersion{Group: "autoscaling", Version: "v1"}) {
                                            storage[resource+"/scale"] = controllerStorage.Scale
                                        }
                                    }

                                    if resource := "services"; apiResourceConfigSource.ResourceEnabled(corev1.SchemeGroupVersion.WithResource(resource)) {
                                        storage[resource] = serviceRESTStorage
                                        storage[resource+"/proxy"] = serviceRESTProxy
                                        storage[resource+"/status"] = serviceStatusStorage
                                    }

                                    if resource := "endpoints"; apiResourceConfigSource.ResourceEnabled(corev1.SchemeGroupVersion.WithResource(resource)) {
                                        storage[resource] = endpointsStorage
                                    }

                                    if resource := "nodes"; apiResourceConfigSource.ResourceEnabled(corev1.SchemeGroupVersion.WithResource(resource)) {
                                        storage[resource] = nodeStorage.Node
                                        storage[resource+"/proxy"] = nodeStorage.Proxy
                                        storage[resource+"/status"] = nodeStorage.Status
                                    }

                                    if resource := "events"; apiResourceConfigSource.ResourceEnabled(corev1.SchemeGroupVersion.WithResource(resource)) {
                                        storage[resource] = eventStorage
                                    }

                                    if resource := "limitranges"; apiResourceConfigSource.ResourceEnabled(corev1.SchemeGroupVersion.WithResource(resource)) {
                                        storage[resource] = limitRangeStorage
                                    }

                                    if resource := "resourcequotas"; apiResourceConfigSource.ResourceEnabled(corev1.SchemeGroupVersion.WithResource(resource)) {
                                        storage[resource] = resourceQuotaStorage
                                        storage[resource+"/status"] = resourceQuotaStatusStorage
                                    }

                                    if resource := "namespaces"; apiResourceConfigSource.ResourceEnabled(corev1.SchemeGroupVersion.WithResource(resource)) {
                                        storage[resource] = namespaceStorage
                                        storage[resource+"/status"] = namespaceStatusStorage
                                        storage[resource+"/finalize"] = namespaceFinalizeStorage
                                    }

                                    if resource := "secrets"; apiResourceConfigSource.ResourceEnabled(corev1.SchemeGroupVersion.WithResource(resource)) {
                                        storage[resource] = secretStorage
                                    }

                                    if resource := "serviceaccounts"; apiResourceConfigSource.ResourceEnabled(corev1.SchemeGroupVersion.WithResource(resource)) {
                                        storage[resource] = serviceAccountStorage
                                        if serviceAccountStorage.Token != nil {
                                            storage[resource+"/token"] = serviceAccountStorage.Token
                                        }
                                    }

                                    if resource := "persistentvolumes"; apiResourceConfigSource.ResourceEnabled(corev1.SchemeGroupVersion.WithResource(resource)) {
                                        storage[resource] = persistentVolumeStorage
                                        storage[resource+"/status"] = persistentVolumeStatusStorage
                                    }

                                    if resource := "persistentvolumeclaims"; apiResourceConfigSource.ResourceEnabled(corev1.SchemeGroupVersion.WithResource(resource)) {
                                        storage[resource] = persistentVolumeClaimStorage
                                        storage[resource+"/status"] = persistentVolumeClaimStatusStorage
                                    }

                                    if resource := "configmaps"; apiResourceConfigSource.ResourceEnabled(corev1.SchemeGroupVersion.WithResource(resource)) {
                                        storage[resource] = configMapStorage
                                    }

                                    if resource := "componentstatuses"; apiResourceConfigSource.ResourceEnabled(corev1.SchemeGroupVersion.WithResource(resource)) {
                                        storage[resource] = componentstatus.NewStorage(componentStatusStorage{c.StorageFactory}.serversToValidate)
                                    }

                                    apiGroupInfo.VersionedResourcesStorageMap["v1"] = storage
                                }

                                m.GenericAPIServer.InstallLegacyAPIGroup(genericapiserver.DefaultLegacyAPIPrefix, &apiGroupInfo)
                                {
                                    s.installAPIResources(apiPrefix, apiGroupInfo, openAPIModels)
                                    {
                                        for _, groupVersion := range apiGroupInfo.PrioritizedVersions {
                                            apiGroupVersion := s.getAPIGroupVersion(apiGroupInfo, groupVersion, apiPrefix)
                                            apiGroupVersion.InstallREST(s.Handler.GoRestfulContainer)
                                            {
                                                prefix := path.Join(g.Root, g.GroupVersion.Group, g.GroupVersion.Version)
                                                installer := &APIInstaller{
                                                    group:             g,
                                                    prefix:            prefix,
                                                    minRequestTimeout: g.MinRequestTimeout,
                                                }

                                                installer.Install()
                                                {
                                                    paths := make([]string, len(a.group.Storage))
                                                    var i int = 0
                                                    for path := range a.group.Storage {
                                                        paths[i] = path
                                                        i++
                                                    }
                                                    sort.Strings(paths)

                                                    // 每个资源对象根据实现的接口来决定支持的访问方式
                                                    for _, path := range paths {
                                                        a.registerResourceHandlers(path, a.group.Storage[path], ws)
                                                        {
                                                            resource, subresource := splitSubresource(path)
                                                            group, version := a.group.GroupVersion.Group, a.group.GroupVersion.Version
                                                            namespaceScoped = scoper.NamespaceScoped()

                                                            // what verbs are supported by the storage, used to know what verbs we support per path
                                                            // POST: New()/Create()
                                                            creater, isCreater := storage.(rest.Creater)
                                                            namedCreater, isNamedCreater := storage.(rest.NamedCreater)
                                                            // LIST: NewList()/List()
                                                            lister, isLister := storage.(rest.Lister)
                                                            // GET: Get()
                                                            getter, isGetter := storage.(rest.Getter)
                                                            getterWithOptions, isGetterWithOptions := storage.(rest.GetterWithOptions)
                                                            // DELETE: Delete()
                                                            gracefulDeleter, isGracefulDeleter := storage.(rest.GracefulDeleter)
                                                            collectionDeleter, isCollectionDeleter := storage.(rest.CollectionDeleter)
                                                            // PUT: New()/Update()
                                                            updater, isUpdater := storage.(rest.Updater)
                                                            // PATCH: Getter/Updater
                                                            patcher, isPatcher := storage.(rest.Patcher)
                                                            // WATCH: Watch()
                                                            watcher, isWatcher := storage.(rest.Watcher)
                                                            // CONNECT: Connect()
                                                            connecter, isConnecter := storage.(rest.Connecter)
                                                            storageMeta, isMetadata := storage.(rest.StorageMetadata)
                                                            storageVersionProvider, isStorageVersionProvider := storage.(rest.StorageVersionProvider)

                                                            resourcePath := resource
                                                            resourceParams := params
                                                            itemPath := resourcePath + "/{name}"
                                                            nameParams := append(params, nameParam)
                                                            proxyParams := append(nameParams, pathParam)
                                                            suffix := ""
                                                            if isSubresource {
                                                                suffix = "/" + subresource
                                                                itemPath = itemPath + suffix
                                                                resourcePath = itemPath
                                                                resourceParams = nameParams
                                                            }
                                                            apiResource.Name = path
                                                            apiResource.Namespaced = false
                                                            apiResource.Kind = resourceKind
                                                            namer := handlers.ContextBasedNaming{
                                                                Namer:         a.group.Namer,
                                                                ClusterScoped: true,
                                                            }

                                                            // Handler for standard REST verbs (GET, PUT, POST and DELETE).
                                                            // Add actions at the resource path: /api/apiVersion/resource
                                                            actions = appendIf(actions, action{"LIST", resourcePath, resourceParams, namer, false}, isLister)
                                                            actions = appendIf(actions, action{"POST", resourcePath, resourceParams, namer, false}, isCreater)
                                                            actions = appendIf(actions, action{"DELETECOLLECTION", resourcePath, resourceParams, namer, false}, isCollectionDeleter)
                                                            // DEPRECATED in 1.11
                                                            actions = appendIf(actions, action{"WATCHLIST", "watch/" + resourcePath, resourceParams, namer, false}, allowWatchList)

                                                            // Add actions at the item path: /api/apiVersion/resource/{name}
                                                            actions = appendIf(actions, action{"GET", itemPath, nameParams, namer, false}, isGetter)
                                                            if getSubpath {
                                                                actions = appendIf(actions, action{"GET", itemPath + "/{path:*}", proxyParams, namer, false}, isGetter)
                                                            }
                                                            actions = appendIf(actions, action{"PUT", itemPath, nameParams, namer, false}, isUpdater)
                                                            actions = appendIf(actions, action{"PATCH", itemPath, nameParams, namer, false}, isPatcher)
                                                            actions = appendIf(actions, action{"DELETE", itemPath, nameParams, namer, false}, isGracefulDeleter)
                                                            // DEPRECATED in 1.11
                                                            actions = appendIf(actions, action{"WATCH", "watch/" + itemPath, nameParams, namer, false}, isWatcher)
                                                            actions = appendIf(actions, action{"CONNECT", itemPath, nameParams, namer, false}, isConnecter)
                                                            actions = appendIf(actions, action{"CONNECT", itemPath + "/{path:*}", proxyParams, namer, false}, isConnecter && connectSubpath)

                                                            for _, action := range actions {
                                                                switch action.Verb {
                                                                case "GET": // Get a resource.
                                                                    var handler restful.RouteFunction
                                                                    if isGetterWithOptions {
                                                                        handler = restfulGetResourceWithOptions(getterWithOptions, reqScope, isSubresource)
                                                                    } else {
                                                                        handler = restfulGetResource(getter, reqScope)
                                                                    }

                                                                    if needOverride {
                                                                        // need change the reported verb
                                                                        handler = metrics.InstrumentRouteFunc(verbOverrider.OverrideMetricsVerb(action.Verb), group, version, resource, subresource, requestScope, metrics.APIServerComponent, deprecated, removedRelease, handler)
                                                                    } else {
                                                                        handler = metrics.InstrumentRouteFunc(action.Verb, group, version, resource, subresource, requestScope, metrics.APIServerComponent, deprecated, removedRelease, handler)
                                                                    }
                                                                    handler = utilwarning.AddWarningsHandler(handler, warnings)

                                                                    doc := "read the specified " + kind
                                                                    if isSubresource {
                                                                        doc = "read " + subresource + " of the specified " + kind
                                                                    }
                                                                    route := ws.GET(action.Path).To(handler).
                                                                        Doc(doc).
                                                                        Param(ws.QueryParameter("pretty", "If 'true', then the output is pretty printed.")).
                                                                        Operation("read"+namespaced+kind+strings.Title(subresource)+operationSuffix).
                                                                        Produces(append(storageMeta.ProducesMIMETypes(action.Verb), mediaTypes...)...).
                                                                        Returns(http.StatusOK, "OK", producedObject).
                                                                        Writes(producedObject)
                                                                    if isGetterWithOptions {
                                                                        if err := AddObjectParams(ws, route, versionedGetOptions); err != nil {
                                                                            return nil, nil, err
                                                                        }
                                                                    }
                                                                    addParams(route, action.Params)
                                                                    routes = append(routes, route)
                                                                case "LIST": // List all resources of a kind.
                                                                    doc := "list objects of kind " + kind
                                                                    if isSubresource {
                                                                        doc = "list " + subresource + " of objects of kind " + kind
                                                                    }
                                                                    handler := metrics.InstrumentRouteFunc(action.Verb, group, version, resource, subresource, requestScope, metrics.APIServerComponent, deprecated, removedRelease, restfulListResource(lister, watcher, reqScope, false, a.minRequestTimeout))
                                                                    handler = utilwarning.AddWarningsHandler(handler, warnings)
                                                                    route := ws.GET(action.Path).To(handler).
                                                                        Doc(doc).
                                                                        Param(ws.QueryParameter("pretty", "If 'true', then the output is pretty printed.")).
                                                                        Operation("list"+namespaced+kind+strings.Title(subresource)+operationSuffix).
                                                                        Produces(append(storageMeta.ProducesMIMETypes(action.Verb), allMediaTypes...)...).
                                                                        Returns(http.StatusOK, "OK", versionedList).
                                                                        Writes(versionedList)
                                                                    if err := AddObjectParams(ws, route, versionedListOptions); err != nil {
                                                                        return nil, nil, err
                                                                    }
                                                                    switch {
                                                                    case isLister && isWatcher:
                                                                        doc := "list or watch objects of kind " + kind
                                                                        if isSubresource {
                                                                            doc = "list or watch " + subresource + " of objects of kind " + kind
                                                                        }
                                                                        route.Doc(doc)
                                                                    case isWatcher:
                                                                        doc := "watch objects of kind " + kind
                                                                        if isSubresource {
                                                                            doc = "watch " + subresource + "of objects of kind " + kind
                                                                        }
                                                                        route.Doc(doc)
                                                                    }
                                                                    addParams(route, action.Params)
                                                                    routes = append(routes, route)
                                                                case "PUT": // Update a resource.
                                                                    doc := "replace the specified " + kind
                                                                    if isSubresource {
                                                                        doc = "replace " + subresource + " of the specified " + kind
                                                                    }
                                                                    handler := metrics.InstrumentRouteFunc(action.Verb, group, version, resource, subresource, requestScope, metrics.APIServerComponent, deprecated, removedRelease, restfulUpdateResource(updater, reqScope, admit))
                                                                    handler = utilwarning.AddWarningsHandler(handler, warnings)
                                                                    route := ws.PUT(action.Path).To(handler).
                                                                        Doc(doc).
                                                                        Param(ws.QueryParameter("pretty", "If 'true', then the output is pretty printed.")).
                                                                        Operation("replace"+namespaced+kind+strings.Title(subresource)+operationSuffix).
                                                                        Produces(append(storageMeta.ProducesMIMETypes(action.Verb), mediaTypes...)...).
                                                                        Returns(http.StatusOK, "OK", producedObject).
                                                                        // TODO: in some cases, the API may return a v1.Status instead of the versioned object
                                                                        // but currently go-restful can't handle multiple different objects being returned.
                                                                        Returns(http.StatusCreated, "Created", producedObject).
                                                                        Reads(defaultVersionedObject).
                                                                        Writes(producedObject)
                                                                    if err := AddObjectParams(ws, route, versionedUpdateOptions, disabledParams...); err != nil {
                                                                        return nil, nil, err
                                                                    }
                                                                    addParams(route, action.Params)
                                                                    routes = append(routes, route)
                                                                case "PATCH": // Partially update a resource
                                                                    doc := "partially update the specified " + kind
                                                                    if isSubresource {
                                                                        doc = "partially update " + subresource + " of the specified " + kind
                                                                    }
                                                                    supportedTypes := []string{
                                                                        string(types.JSONPatchType),
                                                                        string(types.MergePatchType),
                                                                        string(types.StrategicMergePatchType),
                                                                        string(types.ApplyPatchType),
                                                                    }
                                                                    handler := metrics.InstrumentRouteFunc(action.Verb, group, version, resource, subresource, requestScope, metrics.APIServerComponent, deprecated, removedRelease, restfulPatchResource(patcher, reqScope, admit, supportedTypes))
                                                                    handler = utilwarning.AddWarningsHandler(handler, warnings)
                                                                    route := ws.PATCH(action.Path).To(handler).
                                                                        Doc(doc).
                                                                        Param(ws.QueryParameter("pretty", "If 'true', then the output is pretty printed.")).
                                                                        Consumes(supportedTypes...).
                                                                        Operation("patch"+namespaced+kind+strings.Title(subresource)+operationSuffix).
                                                                        Produces(append(storageMeta.ProducesMIMETypes(action.Verb), mediaTypes...)...).
                                                                        Returns(http.StatusOK, "OK", producedObject).
                                                                        // Patch can return 201 when a server side apply is requested
                                                                        Returns(http.StatusCreated, "Created", producedObject).
                                                                        Reads(metav1.Patch{}).
                                                                        Writes(producedObject)
                                                                    if err := AddObjectParams(ws, route, versionedPatchOptions, disabledParams...); err != nil {
                                                                        return nil, nil, err
                                                                    }
                                                                    addParams(route, action.Params)
                                                                    routes = append(routes, route)
                                                                case "POST": // Create a resource.
                                                                    var handler restful.RouteFunction
                                                                    if isNamedCreater {
                                                                        handler = restfulCreateNamedResource(namedCreater, reqScope, admit)
                                                                    } else {
                                                                        handler = restfulCreateResource(creater, reqScope, admit)
                                                                    }
                                                                    handler = metrics.InstrumentRouteFunc(action.Verb, group, version, resource, subresource, requestScope, metrics.APIServerComponent, deprecated, removedRelease, handler)
                                                                    handler = utilwarning.AddWarningsHandler(handler, warnings)
                                                                    article := GetArticleForNoun(kind, " ")
                                                                    doc := "create" + article + kind
                                                                    if isSubresource {
                                                                        doc = "create " + subresource + " of" + article + kind
                                                                    }
                                                                    route := ws.POST(action.Path).To(handler).
                                                                        Doc(doc).
                                                                        Param(ws.QueryParameter("pretty", "If 'true', then the output is pretty printed.")).
                                                                        Operation("create"+namespaced+kind+strings.Title(subresource)+operationSuffix).
                                                                        Produces(append(storageMeta.ProducesMIMETypes(action.Verb), mediaTypes...)...).
                                                                        Returns(http.StatusOK, "OK", producedObject).
                                                                        // TODO: in some cases, the API may return a v1.Status instead of the versioned object
                                                                        // but currently go-restful can't handle multiple different objects being returned.
                                                                        Returns(http.StatusCreated, "Created", producedObject).
                                                                        Returns(http.StatusAccepted, "Accepted", producedObject).
                                                                        Reads(defaultVersionedObject).
                                                                        Writes(producedObject)
                                                                    if err := AddObjectParams(ws, route, versionedCreateOptions, disabledParams...); err != nil {
                                                                        return nil, nil, err
                                                                    }
                                                                    addParams(route, action.Params)
                                                                    routes = append(routes, route)
                                                                case "DELETE": // Delete a resource.
                                                                    article := GetArticleForNoun(kind, " ")
                                                                    doc := "delete" + article + kind
                                                                    if isSubresource {
                                                                        doc = "delete " + subresource + " of" + article + kind
                                                                    }
                                                                    deleteReturnType := versionedStatus
                                                                    if deleteReturnsDeletedObject {
                                                                        deleteReturnType = producedObject
                                                                    }
                                                                    handler := metrics.InstrumentRouteFunc(action.Verb, group, version, resource, subresource, requestScope, metrics.APIServerComponent, deprecated, removedRelease, restfulDeleteResource(gracefulDeleter, isGracefulDeleter, reqScope, admit))
                                                                    handler = utilwarning.AddWarningsHandler(handler, warnings)
                                                                    route := ws.DELETE(action.Path).To(handler).
                                                                        Doc(doc).
                                                                        Param(ws.QueryParameter("pretty", "If 'true', then the output is pretty printed.")).
                                                                        Operation("delete"+namespaced+kind+strings.Title(subresource)+operationSuffix).
                                                                        Produces(append(storageMeta.ProducesMIMETypes(action.Verb), mediaTypes...)...).
                                                                        Writes(deleteReturnType).
                                                                        Returns(http.StatusOK, "OK", deleteReturnType).
                                                                        Returns(http.StatusAccepted, "Accepted", deleteReturnType)
                                                                    if isGracefulDeleter {
                                                                        route.Reads(versionedDeleterObject)
                                                                        route.ParameterNamed("body").Required(false)
                                                                        if err := AddObjectParams(ws, route, versionedDeleteOptions); err != nil {
                                                                            return nil, nil, err
                                                                        }
                                                                    }
                                                                    addParams(route, action.Params)
                                                                    routes = append(routes, route)
                                                                case "DELETECOLLECTION":
                                                                    doc := "delete collection of " + kind
                                                                    if isSubresource {
                                                                        doc = "delete collection of " + subresource + " of a " + kind
                                                                    }
                                                                    handler := metrics.InstrumentRouteFunc(action.Verb, group, version, resource, subresource, requestScope, metrics.APIServerComponent, deprecated, removedRelease, restfulDeleteCollection(collectionDeleter, isCollectionDeleter, reqScope, admit))
                                                                    handler = utilwarning.AddWarningsHandler(handler, warnings)
                                                                    route := ws.DELETE(action.Path).To(handler).
                                                                        Doc(doc).
                                                                        Param(ws.QueryParameter("pretty", "If 'true', then the output is pretty printed.")).
                                                                        Operation("deletecollection"+namespaced+kind+strings.Title(subresource)+operationSuffix).
                                                                        Produces(append(storageMeta.ProducesMIMETypes(action.Verb), mediaTypes...)...).
                                                                        Writes(versionedStatus).
                                                                        Returns(http.StatusOK, "OK", versionedStatus)
                                                                    if isCollectionDeleter {
                                                                        route.Reads(versionedDeleterObject)
                                                                        route.ParameterNamed("body").Required(false)
                                                                        if err := AddObjectParams(ws, route, versionedDeleteOptions); err != nil {
                                                                            return nil, nil, err
                                                                        }
                                                                    }
                                                                    if err := AddObjectParams(ws, route, versionedListOptions, "watch", "allowWatchBookmarks"); err != nil {
                                                                        return nil, nil, err
                                                                    }
                                                                    addParams(route, action.Params)
                                                                    routes = append(routes, route)
                                                                // deprecated in 1.11
                                                                case "WATCH": // Watch a resource.
                                                                    doc := "watch changes to an object of kind " + kind
                                                                    if isSubresource {
                                                                        doc = "watch changes to " + subresource + " of an object of kind " + kind
                                                                    }
                                                                    doc += ". deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter."
                                                                    handler := metrics.InstrumentRouteFunc(action.Verb, group, version, resource, subresource, requestScope, metrics.APIServerComponent, deprecated, removedRelease, restfulListResource(lister, watcher, reqScope, true, a.minRequestTimeout))
                                                                    handler = utilwarning.AddWarningsHandler(handler, warnings)
                                                                    route := ws.GET(action.Path).To(handler).
                                                                        Doc(doc).
                                                                        Param(ws.QueryParameter("pretty", "If 'true', then the output is pretty printed.")).
                                                                        Operation("watch"+namespaced+kind+strings.Title(subresource)+operationSuffix).
                                                                        Produces(allMediaTypes...).
                                                                        Returns(http.StatusOK, "OK", versionedWatchEvent).
                                                                        Writes(versionedWatchEvent)
                                                                    if err := AddObjectParams(ws, route, versionedListOptions); err != nil {
                                                                        return nil, nil, err
                                                                    }
                                                                    addParams(route, action.Params)
                                                                    routes = append(routes, route)
                                                                // deprecated in 1.11
                                                                case "WATCHLIST": // Watch all resources of a kind.
                                                                    doc := "watch individual changes to a list of " + kind
                                                                    if isSubresource {
                                                                        doc = "watch individual changes to a list of " + subresource + " of " + kind
                                                                    }
                                                                    doc += ". deprecated: use the 'watch' parameter with a list operation instead."
                                                                    handler := metrics.InstrumentRouteFunc(action.Verb, group, version, resource, subresource, requestScope, metrics.APIServerComponent, deprecated, removedRelease, restfulListResource(lister, watcher, reqScope, true, a.minRequestTimeout))
                                                                    handler = utilwarning.AddWarningsHandler(handler, warnings)
                                                                    route := ws.GET(action.Path).To(handler).
                                                                        Doc(doc).
                                                                        Param(ws.QueryParameter("pretty", "If 'true', then the output is pretty printed.")).
                                                                        Operation("watch"+namespaced+kind+strings.Title(subresource)+"List"+operationSuffix).
                                                                        Produces(allMediaTypes...).
                                                                        Returns(http.StatusOK, "OK", versionedWatchEvent).
                                                                        Writes(versionedWatchEvent)
                                                                    if err := AddObjectParams(ws, route, versionedListOptions); err != nil {
                                                                        return nil, nil, err
                                                                    }
                                                                    addParams(route, action.Params)
                                                                    routes = append(routes, route)
                                                                case "CONNECT":
                                                                    for _, method := range connecter.ConnectMethods() {
                                                                        connectProducedObject := storageMeta.ProducesObject(method)
                                                                        if connectProducedObject == nil {
                                                                            connectProducedObject = "string"
                                                                        }
                                                                        doc := "connect " + method + " requests to " + kind
                                                                        if isSubresource {
                                                                            doc = "connect " + method + " requests to " + subresource + " of " + kind
                                                                        }
                                                                        handler := metrics.InstrumentRouteFunc(action.Verb, group, version, resource, subresource, requestScope, metrics.APIServerComponent, deprecated, removedRelease, restfulConnectResource(connecter, reqScope, admit, path, isSubresource))
                                                                        handler = utilwarning.AddWarningsHandler(handler, warnings)
                                                                        route := ws.Method(method).Path(action.Path).
                                                                            To(handler).
                                                                            Doc(doc).
                                                                            Operation("connect" + strings.Title(strings.ToLower(method)) + namespaced + kind + strings.Title(subresource) + operationSuffix).
                                                                            Produces("*/*").
                                                                            Consumes("*/*").
                                                                            Writes(connectProducedObject)
                                                                        if versionedConnectOptions != nil {
                                                                            if err := AddObjectParams(ws, route, versionedConnectOptions); err != nil {
                                                                                return nil, nil, err
                                                                            }
                                                                        }
                                                                        addParams(route, action.Params)
                                                                        routes = append(routes, route)

                                                                        // transform ConnectMethods to kube verbs
                                                                        if kubeVerb, found := toDiscoveryKubeVerb[method]; found {
                                                                            if len(kubeVerb) != 0 {
                                                                                kubeVerbs[kubeVerb] = struct{}{}
                                                                            }
                                                                        }
                                                                    }
                                                                default:
                                                                    return nil, nil, fmt.Errorf("unrecognized action verb: %s", action.Verb)
                                                                }
                                                                for _, route := range routes {
                                                                    route.Metadata(ROUTE_META_GVK, metav1.GroupVersionKind{
                                                                        Group:   reqScope.Kind.Group,
                                                                        Version: reqScope.Kind.Version,
                                                                        Kind:    reqScope.Kind.Kind,
                                                                    })
                                                                    route.Metadata(ROUTE_META_ACTION, strings.ToLower(action.Verb))
                                                                    ws.Route(route)
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            restStorageProviders := []RESTStorageProvider{
                                apiserverinternalrest.StorageProvider{},
                                authenticationrest.RESTStorageProvider{...},
                                authorizationrest.RESTStorageProvider{...},
                                autoscalingrest.RESTStorageProvider{},
                                batchrest.RESTStorageProvider{},
                                certificatesrest.RESTStorageProvider{},
                                coordinationrest.RESTStorageProvider{},
                                discoveryrest.StorageProvider{},
                                networkingrest.RESTStorageProvider{},
                                noderest.RESTStorageProvider{},
                                policyrest.RESTStorageProvider{},
                                rbacrest.RESTStorageProvider{...},
                                schedulingrest.RESTStorageProvider{},
                                storagerest.RESTStorageProvider{},
                                flowcontrolrest.RESTStorageProvider{...},
                                appsrest.StorageProvider{},
                                admissionregistrationrest.RESTStorageProvider{...},
                                eventsrest.RESTStorageProvider{...},
                                resourcerest.RESTStorageProvider{},
                            }

                            m.InstallAPIs(..., restStorageProviders...)
                            {
                                for _, restStorageBuilder := range restStorageProviders {
                                    apiGroupInfo, err := restStorageBuilder.NewRESTStorage(apiResourceConfigSource, restOptionsGetter)
                                    apiGroupsInfo = append(apiGroupsInfo, &apiGroupInfo)
                                }

                                m.GenericAPIServer.InstallAPIGroups(apiGroupsInfo...)
                                {
                                    for _, apiGroupInfo := range apiGroupInfos {
                                        s.installAPIResources(APIGroupPrefix, apiGroupInfo, openAPIModels)
                                    }
                                }
                            }
                        }
                    }

                    aggregatorServer := createAggregatorServer(aggregatorConfig, kubeAPIServer.GenericAPIServer, ...)

                    return aggregatorServer, nil
                }

                prepared := server.PrepareRun()
                {
                    prepared := s.GenericAPIServer.PrepareRun()
                    return preparedAPIAggregator{APIAggregator: s, runnable: prepared}, nil
                }

                return prepared.Run(stopCh)
                {
                    s.installHealthz()
	                s.installLivez()
                    s.installReadyz()
                }
            }
		},
    }

    fs := cmd.Flags()
	// 命令行参数
	namedFlagSets := s.Flags()
	verflag.AddFlags(namedFlagSets.FlagSet("global"))
	globalflag.AddGlobalFlags(namedFlagSets.FlagSet("global"), cmd.Name(), logs.SkipLoggingConfigurationFlags())
	options.AddCustomGlobalFlags(namedFlagSets.FlagSet("generic"))
	for _, f := range namedFlagSets.FlagSets {
		fs.AddFlagSet(f)
	}

	return cmd
}

```

## kube-controller-manager

## kube-scheduler

## kubelet

## kube-proxy









