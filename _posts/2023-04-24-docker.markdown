---
layout: post
title:  "docker"
date:   2023-04-24 23:22:07 +0000
categories: jekyll
tags: docker
---

# docker

`docker`由两部分组成：`docker/cli`编译出`docker`，`moby`项目编译出`dockerd`

## 搭建测试环境

### cli

`docker/cli` is developed using Docker.

```shell

> make help
dev                  start a build container in interactive mode for in-container development
shell                alias for dev
clean                remove build artifacts

```

`/Makefile`

```Makefile

.PHONY: dev
dev:
    $(MAKE) -f docker.Makefile dev

```

`/docker.Makefile`

```Makefile

.PHONY: build_docker_image
build_docker_image:
    # build dockerfile from stdin so that we don't send the build-context; source is bind-mounted in the development environment
    cat ./dockerfiles/Dockerfile.dev | docker build ${DOCKER_BUILD_ARGS} --build-arg=GO_VERSION -t $(DEV_DOCKER_IMAGE_NAME) -

.PHONY: dev
dev: build_docker_image
    $(DOCKER_RUN) -it \
        --mount type=bind,src=/var/run/docker.sock,dst=/var/run/docker.sock \
        --net=host \
        $(DEV_DOCKER_IMAGE_NAME)

```

修改`/dockerfiles/Dockerfile.dev`增加`godlv`用于远程调试

```Dockerfile

# 参照其他几处`go install xxx`
FROM golang AS godlv
RUN --mount=type=cache,target=/root/.cache/go-build \
    --mount=type=cache,target=/go/pkg/mod \
    --mount=type=tmpfs,target=/go/src/ \
    GO111MODULE=on GOPROXY=https://goproxy.cn go install github.com/go-delve/delve/cmd/dlv@v1.20.2

COPY --from=godlv           /go/bin/* /go/bin/

```

在`make dev`启动的容器中执行命令

```shell

# 编译
make make binary

# 远程调试
dlv --listen=:2345 --headless=true --api-version=2 exec build/docker run hello-world 

```

### moby

`docs/contributing`

The Docker daemon inside the development container can be debugged with [Delve](https://github.com/go-delve/delve).

Delve debugger listens on a port, which has to be exposed outside the development container.
Also, in order to be able to debug the daemon, it has to be compiled with the debugging symbols.
This can be done by launching the development container with the following command:

```bash
$ make BIND_DIR=. DOCKER_DEBUG=1 DELVE_PORT=2345:2345 shell
```

The `DOCKER_DEBUG` variable disables build optimizations, allowing to debug the binary,
while `DELVE_PORT` publishes the specified port for use with the debugger.

The `DELVE_PORT` variable accepts the port in the same format as Docker CLI's `--publish` (`-p`) option.
This means that the port can be published in multiple ways:

1. `DELVE_PORT=127.0.0.1:2345:2345` - exposes debugger on port `2345` for local development only (recommended)
2. `DELVE_PORT=2345:2345` - exposes debugger on port `2345` without binding to specific IP
3. `DELVE_PORT=2345` - same as above

```Makefile

shell: build  ## start a shell inside the build env
    $(DOCKER_RUN_DOCKER) bash

# 通过根目录下的Dockerfile构建dockerd的开发环境
build: bundles
    $(BUILD_CMD) $(BUILD_OPTS) $(shell_target) --load -t "$(DOCKER_IMAGE)" .

```

在`make ... shell`启动的容器中执行命令

```shell

# 编译
./hack/make.sh binary

# 远程调试
dlv --listen=:2346 --headless=true --api-version=2 exec bundles/binary-daemon/dockerd

```

## 常用命令

```txt

Usage:  docker [OPTIONS] COMMAND

A self-sufficient runtime for containers

Common Commands:
  run         Create and run a new container from an image
  exec        Execute a command in a running container
  ps          List containers
  build       Build an image from a Dockerfile
  pull        Download an image from a registry
  push        Upload an image to a registry
  images      List images
  login       Log in to a registry
  logout      Log out from a registry
  search      Search Docker Hub for images
  version     Show the Docker version information
  info        Display system-wide information

Management Commands:
  builder     Manage builds
  buildx*     Docker Buildx (Docker Inc., v0.10.4)
  container   Manage containers
  context     Manage contexts
  image       Manage images
  manifest    Manage Docker image manifests and manifest lists
  network     Manage networks
  plugin      Manage plugins
  system      Manage Docker
  trust       Manage trust on Docker images
  volume      Manage volumes

Swarm Commands:
  swarm       Manage Swarm

Commands:
  attach      Attach local standard input, output, and error streams to a running container
  commit      Create a new image from a container's changes
  cp          Copy files/folders between a container and the local filesystem
  create      Create a new container
  diff        Inspect changes to files or directories on a container's filesystem
  events      Get real time events from the server
  export      Export a container's filesystem as a tar archive
  history     Show the history of an image
  import      Import the contents from a tarball to create a filesystem image
  inspect     Return low-level information on Docker objects
  kill        Kill one or more running containers
  load        Load an image from a tar archive or STDIN
  logs        Fetch the logs of a container
  pause       Pause all processes within one or more containers
  port        List port mappings or a specific mapping for the container
  rename      Rename a container
  restart     Restart one or more containers
  rm          Remove one or more containers
  rmi         Remove one or more images
  save        Save one or more images to a tar archive (streamed to STDOUT by default)
  start       Start one or more stopped containers
  stats       Display a live stream of container(s) resource usage statistics
  stop        Stop one or more running containers
  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE
  top         Display the running processes of a container
  unpause     Unpause all processes within one or more containers
  update      Update configuration of one or more containers
  wait        Block until one or more containers stop, then print their exit codes

```

## 源码分析

以`docker run hello-world`为例分析实现过程

### cli

```go

func main() {
    dockerCli := command.NewDockerCli()
    runDocker(dockerCli)
    {
        tcmd := newDockerCommand(dockerCli)
        {
            cmd := &cobra.Command{
                Use:              "docker [OPTIONS] COMMAND [ARG...]",
                Short:            "A self-sufficient runtime for containers",
                SilenceUsage:     true,
                SilenceErrors:    true,
                TraverseChildren: true,
                RunE: func(cmd *cobra.Command, args []string) error {
                    if len(args) == 0 {
                        return command.ShowHelp(dockerCli.Err())(cmd, args)
                    }
                    return fmt.Errorf("docker: '%s' is not a docker command.\nSee 'docker --help'", args[0])
                },
                PersistentPreRunE: func(cmd *cobra.Command, args []string) error {
                    return isSupported(cmd, dockerCli)
                },
                DisableFlagsInUseLine: true,
            }
            cmd.SetIn(dockerCli.In())
            cmd.SetOut(dockerCli.Out())
            cmd.SetErr(dockerCli.Err())

            // 构造支持的命令列表
            commands.AddCommands(cmd, dockerCli)
            {
                cmd.AddCommand(
                    container.NewRunCommand(dockerCli),
                    container.NewExecCommand(dockerCli),
                    container.NewPsCommand(dockerCli),
                    image.NewBuildCommand(dockerCli),
                    image.NewPullCommand(dockerCli),
                    image.NewPushCommand(dockerCli),
                    image.NewImagesCommand(dockerCli),
                    registry.NewLoginCommand(dockerCli),
                    registry.NewLogoutCommand(dockerCli),
                    registry.NewSearchCommand(dockerCli),
                    system.NewVersionCommand(dockerCli),
                    system.NewInfoCommand(dockerCli),

                    // management commands
                    builder.NewBuilderCommand(dockerCli),
                    checkpoint.NewCheckpointCommand(dockerCli),
                    container.NewContainerCommand(dockerCli),
                    context.NewContextCommand(dockerCli),
                    image.NewImageCommand(dockerCli),
                    manifest.NewManifestCommand(dockerCli),
                    network.NewNetworkCommand(dockerCli),
                    plugin.NewPluginCommand(dockerCli),
                    system.NewSystemCommand(dockerCli),
                    trust.NewTrustCommand(dockerCli),
                    volume.NewVolumeCommand(dockerCli),

                    // orchestration (swarm) commands
                    config.NewConfigCommand(dockerCli),
                    node.NewNodeCommand(dockerCli),
                    secret.NewSecretCommand(dockerCli),
                    service.NewServiceCommand(dockerCli),
                    stack.NewStackCommand(dockerCli),
                    swarm.NewSwarmCommand(dockerCli),

                    // legacy commands may be hidden
                    hide(container.NewAttachCommand(dockerCli)),
                    hide(container.NewCommitCommand(dockerCli)),
                    hide(container.NewCopyCommand(dockerCli)),
                    hide(container.NewCreateCommand(dockerCli)),
                    hide(container.NewDiffCommand(dockerCli)),
                    hide(container.NewExportCommand(dockerCli)),
                    hide(container.NewKillCommand(dockerCli)),
                    hide(container.NewLogsCommand(dockerCli)),
                    hide(container.NewPauseCommand(dockerCli)),
                    hide(container.NewPortCommand(dockerCli)),
                    hide(container.NewRenameCommand(dockerCli)),
                    hide(container.NewRestartCommand(dockerCli)),
                    hide(container.NewRmCommand(dockerCli)),
                    hide(container.NewStartCommand(dockerCli)),
                    hide(container.NewStatsCommand(dockerCli)),
                    hide(container.NewStopCommand(dockerCli)),
                    hide(container.NewTopCommand(dockerCli)),
                    hide(container.NewUnpauseCommand(dockerCli)),
                    hide(container.NewUpdateCommand(dockerCli)),
                    hide(container.NewWaitCommand(dockerCli)),
                    hide(image.NewHistoryCommand(dockerCli)),
                    hide(image.NewImportCommand(dockerCli)),
                    hide(image.NewLoadCommand(dockerCli)),
                    hide(image.NewRemoveCommand(dockerCli)),
                    hide(image.NewSaveCommand(dockerCli)),
                    hide(image.NewTagCommand(dockerCli)),
                    hide(system.NewEventsCommand(dockerCli)),
                    hide(system.NewInspectCommand(dockerCli)),
                )
            }
        }

        cmd, args := tcmd.HandleGlobalFlags()
        cmd.SetArgs(args)
        return cmd.Execute()
        {
            // 子命令匹配和参数解析
            cmd, flags, err = c.Traverse(args)
            {
                // 匹配子命令列表
                cmd := c.findNext(arg)
                if cmd == nil {
                    return c, args, nil
                }
            
                // 参数解析
                c.ParseFlags(flags)

                // 支持多级子命令嵌套
                return cmd.Traverse(args[i+1:])
            }

            // 执行命令
            cmd.execute(flags)
        }
    }
}

```

以`docker run`命令为例

```go

func NewRunCommand(dockerCli command.Cli) *cobra.Command {
	var options runOptions
	var copts *containerOptions

    cmd := &cobra.Command{
        Use:   "run [OPTIONS] IMAGE [COMMAND] [ARG...]",
        Short: "Create and run a new container from an image",
        Args:  cli.RequiresMinArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error {
            // 第一个参数表示image
            copts.Image = args[0]
            if len(args) > 1 {
                copts.Args = args[1:]
            }

            return runRun(dockerCli, cmd.Flags(), &options, copts)
            {
                // 与dockerd建立链接
                client := dockerCli.Client()
                {
                    cli.initialize()
                    {
                        cli.init.Do(func() {
                            // unix:///var/run/docker.sock
                            cli.dockerEndpoint, cli.initErr = cli.getDockerEndPoint()
                            cli.client = newAPIClientFromEndpoint(cli.dockerEndpoint, cli.configFile)
                            cli.initializeFromClient()
                        })
                    }
                }

                // HTTP_PROXY, HTTPS_PROXY
                proxyConfig := dockerCli.ConfigFile().ParseProxyConfig(client.DaemonHost(), ...)
                containerConfig, err := parse(flags, copts, dockerCli.ServerInfo().OSType)

                return runContainer(dockerCli, ropts, copts, containerConfig)
                {
                    // 创建容器
                    createResponse := createContainer(ctx, dockerCli, containerConfig, &opts.createOptions)
                    {
                        dockerCli.Client().ContainerCreate(ctx, config, hostConfig, networkingConfig, platform, opts.name)
                        {
                            cli.post(ctx, "/containers/create", query, body, nil)
                        }
                    }

                    // attach io
                    attach := config.AttachStdin || config.AttachStdout || config.AttachStderr
                    if attach {
                        attachContainer(ctx, dockerCli, &errCh, config, createResponse.ID)
                        {
                            dockerCli.Client().ContainerAttach(ctx, containerID, options)
                            {
                                cli.postHijacked(ctx, "/containers/"+container+"/attach", query, nil, headers)
                            }
                        }
                    }
                    
                    // 启动容器
                    client.ContainerStart(ctx, createResponse.ID, types.ContainerStartOptions{})
                    {
                        cli.post(ctx, "/containers/"+containerID+"/start", query, nil, nil)
                    }
                }
            }
        },
        ValidArgsFunction: completion.ImageNames(dockerCli),
        Annotations: map[string]string{
            "category-top": "1",
            "aliases":      "docker container run, docker run",
        },
    }


    // 命令行参数列表
	flags := cmd.Flags()
    flags.BoolVarP(&options.detach, "detach", "d", false, "Run container in background and print container ID")

    command.AddPlatformFlag(flags, &options.platform)
	copts = addFlags(flags)
    {
        // General purpose flags
	    flags.VarP(&copts.attach, "attach", "a", "Attach to STDIN, STDOUT or STDERR")
        flags.VarP(&copts.env, "env", "e", "Set environment variables")
        flags.StringVar(&copts.entrypoint, "entrypoint", "", "Overwrite the default ENTRYPOINT of the image")
        flags.StringVarP(&copts.user, "user", "u", "", "Username or UID (format: <name|uid>[:<group|gid>])")
	    flags.StringVarP(&copts.workingDir, "workdir", "w", "", "Working directory inside the container")
    }
}

```

### moby

```go

func main() {
    cmd := newDaemonCommand()
    {
        cmd := &cobra.Command{
            Use:           "dockerd [OPTIONS]",
            Short:         "A self-sufficient runtime for containers.",
            SilenceUsage:  true,
            SilenceErrors: true,
            Args:          cli.NoArgs,
            RunE: func(cmd *cobra.Command, args []string) error {
                opts.flags = cmd.Flags()
                return runDaemon(opts)
                {
                    daemonCli := NewDaemonCli()
	                daemonCli.start(opts)
                    {
                        // 加载/etc/docker/daemon.json
                        cli.Config = loadDaemonCliConfig(opts)

                        // config.Root默认/var/lib/docker: 存储image和container
                        daemon.CreateDaemonRoot(cli.Config)

                        // config.ExecRoot默认/var/run/docker
                        system.MkdirAll(cli.Config.ExecRoot, 0700);

                        // 创建unix:///var/run/docker.sock
                        loadListeners(cli, serverConfig)

                        // 启动contianerd
                        cli.initContainerD(ctx)
                        {
                            supervisor.Start(ctx, ...)
                            {
                                go r.monitorDaemon(ctx)
                                {
                                    // 执行containerd --config /var/run/docker/containerd/containerd.toml 
                                    r.startContainerd()
                                }
                            }
                        }

                        daemon.NewDaemon(ctx, cli.Config, pluginStore)
                        {
                            // 与contianerd建立链接
                            d.containerdCli = containerd.New(config.ContainerdAddr, ...)
                            d.initLibcontainerd(ctx)
                            {
                                daemon.containerd = remote.NewClient(ctx, daemon.containerdCli, ...)
                            }
                        }

                        // 创建路由表
                        initRouter(routerOptions)
                        {
                            routers := []router.Router{
                                // we need to add the checkpoint router before the container router or the DELETE gets masked
                                checkpointrouter.NewRouter(opts.daemon, decoder),
                                container.NewRouter(opts.daemon, decoder, opts.daemon.RawSysInfo().CgroupUnified),
                                {
                                    r.routes = []router.Route{
                                        // HEAD
                                        router.NewHeadRoute("/containers/{name:.*}/archive", r.headContainersArchive),
                                        // GET
                                        router.NewGetRoute("/containers/json", r.getContainersJSON),
                                        router.NewGetRoute("/containers/{name:.*}/export", r.getContainersExport),
                                        router.NewGetRoute("/containers/{name:.*}/changes", r.getContainersChanges),
                                        router.NewGetRoute("/containers/{name:.*}/json", r.getContainersByName),
                                        router.NewGetRoute("/containers/{name:.*}/top", r.getContainersTop),
                                        router.NewGetRoute("/containers/{name:.*}/logs", r.getContainersLogs),
                                        router.NewGetRoute("/containers/{name:.*}/stats", r.getContainersStats),
                                        router.NewGetRoute("/containers/{name:.*}/attach/ws", r.wsContainersAttach),
                                        router.NewGetRoute("/exec/{id:.*}/json", r.getExecByID),
                                        router.NewGetRoute("/containers/{name:.*}/archive", r.getContainersArchive),
                                        // POST
                                        // #dockerd#3.1 /containers/create
                                        router.NewPostRoute("/containers/create", r.postContainersCreate),
                                        router.NewPostRoute("/containers/{name:.*}/kill", r.postContainersKill),
                                        router.NewPostRoute("/containers/{name:.*}/pause", r.postContainersPause),
                                        router.NewPostRoute("/containers/{name:.*}/unpause", r.postContainersUnpause),
                                        router.NewPostRoute("/containers/{name:.*}/restart", r.postContainersRestart),
                                        // #dockerd#3.3 /containers/{name:.*}/start
                                        router.NewPostRoute("/containers/{name:.*}/start", r.postContainersStart),
                                        router.NewPostRoute("/containers/{name:.*}/stop", r.postContainersStop),
                                        router.NewPostRoute("/containers/{name:.*}/wait", r.postContainersWait),
                                        router.NewPostRoute("/containers/{name:.*}/resize", r.postContainersResize),
                                        // #dockerd#3.2 /containers/{name:.*}/attach
                                        router.NewPostRoute("/containers/{name:.*}/attach", r.postContainersAttach),
                                        router.NewPostRoute("/containers/{name:.*}/exec", r.postContainerExecCreate),
                                        router.NewPostRoute("/exec/{name:.*}/start", r.postContainerExecStart),
                                        router.NewPostRoute("/exec/{name:.*}/resize", r.postContainerExecResize),
                                        router.NewPostRoute("/containers/{name:.*}/rename", r.postContainerRename),
                                        router.NewPostRoute("/containers/{name:.*}/update", r.postContainerUpdate),
                                        router.NewPostRoute("/containers/prune", r.postContainersPrune),
                                        router.NewPostRoute("/commit", r.postCommit),
                                        // PUT
                                        router.NewPutRoute("/containers/{name:.*}/archive", r.putContainersArchive),
                                        // DELETE
                                        router.NewDeleteRoute("/containers/{name:.*}", r.deleteContainers),
                                    }
                                }

                                image.NewRouter(
                                    opts.daemon.ImageService(),
                                    opts.daemon.ReferenceStore,
                                    opts.daemon.ImageService().DistributionServices().ImageStore,
                                    opts.daemon.ImageService().DistributionServices().LayerStore,
                                ),
                                systemrouter.NewRouter(opts.daemon, opts.cluster, opts.buildkit, opts.features),
                                volume.NewRouter(opts.daemon.VolumesService(), opts.cluster),
                                build.NewRouter(opts.buildBackend, opts.daemon, opts.features),
                                sessionrouter.NewRouter(opts.sessionManager),
                                swarmrouter.NewRouter(opts.cluster),
                                pluginrouter.NewRouter(opts.daemon.PluginManager()),
                                distributionrouter.NewRouter(opts.daemon.ImageService()),
                            }

                            opts.api.InitRouter(routers...)
                        }

                        // 开始处理请求
                        go cli.api.Wait(serveAPIWait) {
                            s.serveAPI()
                        }
                    }
                }
            },
            DisableFlagsInUseLine: true
        }

        // 命令行参数
        flags := cmd.Flags()
        // 默认配置文件/etc/docker/daemon.json
        flags.StringVar(&opts.configFile, "config-file", defaultDaemonConfigFile, "Daemon configuration file")
        // daemonOptions: 命令行参数
        opts.installFlags(flags)
        // daemonConfig: 命令行参数
        installConfigFlags(opts.daemonConfig, flags)
    }

    cmd.Execute()
}

```

`post /containers/{name:.*}/start`

```go

func (s *containerRouter) postContainersStart(ctx context.Context, ...) error {
    s.backend.ContainerStart(vars["name"], hostConfig, checkpoint, checkpointDir)
    {
        ctr := daemon.GetContainer(name)
        daemon.containerStart(ctr, checkpoint, checkpointDir, true)
        {
            daemon.conditionalMountOnStart(container)
            daemon.initializeNetworking(container)
            spec := daemon.createSpec(container)

            // 请求containerd创建并启动容器
            daemon.containerd.Create(ctx, container.ID, spec, shim, createOptions)
            {
                container := containers.Container{
                    ID: id,
                    Runtime: containers.RuntimeInfo{
                        Name: c.runtime,
                    },
                }

                // 向containerd发送grpc请求
                c.ContainerService().Create(ctx, container)
            }

            pid := daemon.containerd.Start(context.Background(), container.ID, checkpointDir, ...)
        }
    }
}

```

### containerd

