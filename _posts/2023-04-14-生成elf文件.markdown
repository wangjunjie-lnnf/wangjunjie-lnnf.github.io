---
layout: post
title:  "生成elf文件"
date:   2023-04-14 10:22:07 +0000
categories: jekyll
tags: gcc as ld
---

# demo

## 示例程序

```c

#include <stdio.h>

int convert(char *str)
{
    int s = 0;
    char c;
    int i = 0;

    while ((c = str[i++]) != '\0')
    {
        if (c < '0' || c > '9')
        {
            return -3;
        }

        s *= 10;
        s += c - '0';
    }

    return s;
}

int main(int argc, char **argv)
{    
    if (argc != 2)
    {
        return -1;
    }

    char *str = argv[1];
    if (str == 0)
    {
        return -2;
    }

    int n = convert(str);

    printf("result is %d\n", n);

    return 0;
}

```

## 查看编译和链接的命令

```shell

> gcc/xgcc -### main_printf.c -o main_printf

Reading specs from /home/w/github/gcc-debug/build/obj/gcc/specs
COLLECT_GCC=/home/w/github/gcc-debug/build/obj/gcc/xgcc
COLLECT_LTO_WRAPPER=/home/w/github/gcc-debug/build/obj/gcc/lto-wrapper
Target: x86_64-pc-linux-gnu
# 编译gcc时的配置
Configured with: ../src/configure CFLAGS='-g -O0 -Wno-format-diag -Wno-format-security' CXXFLAGS='-g -O0 -Wno-format-diag -Wno-format-security' --enable-languages=c --disable-werror --disable-multilib --disable-bootstrap
Thread model: posix
Supported LTO compression algorithms: zlib
gcc version 11.3.0 (GCC) 
COLLECT_GCC_OPTIONS='-o' 'main_printf' '-mtune=generic' '-march=x86-64'
# cc1编译命令参数
 /home/w/github/gcc-debug/build/obj/gcc/cc1 -quiet -imultiarch x86_64-linux-gnu -iprefix /home/w/github/gcc-debug/build/obj/gcc/../lib/gcc/x86_64-pc-linux-gnu/11.3.0/ -isystem /home/w/github/gcc-debug/build/obj/gcc/include -isystem /home/w/github/gcc-debug/build/obj/gcc/include-fixed main_printf.c -quiet -dumpbase main_printf.c -dumpbase-ext .c "-mtune=generic" "-march=x86-64" -o /tmp/ccSJ58HL.s
COLLECT_GCC_OPTIONS='-o' 'main_printf' '-mtune=generic' '-march=x86-64'
# as汇编命令参数
 /home/w/github/gcc-debug/build/obj/gcc/as --64 -o /tmp/ccT35JnS.o /tmp/ccSJ58HL.s
COMPILER_PATH=/home/w/github/gcc-debug/build/obj/gcc/
LIBRARY_PATH=/lib/x86_64-linux-gnu/:/lib/../lib64/:/usr/lib/x86_64-linux-gnu/:/usr/lib/../lib64/:/home/w/github/gcc-debug/build/obj/gcc/:/lib/:/usr/lib/
COLLECT_GCC_OPTIONS='-o' 'main_printf' '-mtune=generic' '-march=x86-64' '-dumpdir' 'main_printf.'
# collect2链接命令参数
 /home/w/github/gcc-debug/build/obj/gcc/collect2 -plugin /home/w/github/gcc-debug/build/obj/gcc/liblto_plugin.so "-plugin-opt=/home/w/github/gcc-debug/build/obj/gcc/lto-wrapper" "-plugin-opt=-fresolution=/tmp/ccvCyrNV.res" "-plugin-opt=-pass-through=-lgcc" "-plugin-opt=-pass-through=-lgcc_s" "-plugin-opt=-pass-through=-lc" "-plugin-opt=-pass-through=-lgcc" "-plugin-opt=-pass-through=-lgcc_s" --eh-frame-hdr -m elf_x86_64 -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o main_printf /lib/x86_64-linux-gnu/crt1.o /lib/x86_64-linux-gnu/crti.o /home/w/github/gcc-debug/build/obj/gcc/crtbegin.o -L/lib/x86_64-linux-gnu -L/lib/../lib64 -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib64 -L/home/w/github/gcc-debug/build/obj/gcc /tmp/ccT35JnS.o -lgcc --push-state --as-needed -lgcc_s --pop-state -lc -lgcc --push-state --as-needed -lgcc_s --pop-state /home/w/github/gcc-debug/build/obj/gcc/crtend.o /lib/x86_64-linux-gnu/crtn.o
COLLECT_GCC_OPTIONS='-o' 'main_printf' '-mtune=generic' '-march=x86-64' '-dumpdir' 'main_printf.'

```

## 编译

`gcc/cc1 -iprefix=xxx -isystem=xxx -imultiarch x86_64-linux-gnu -o main_printf.s main_printf.c`  
编译之后产生如下汇编代码:

```asm

	.file	"main_printf.c"

	.text
	.globl	convert
	.type	convert, @function

convert:
.LFB0:
	pushq	%rbp
	movq	%rsp, %rbp
	movq	%rdi, -24(%rbp)
	movl	$0, -4(%rbp)
	movl	$0, -8(%rbp)
	jmp	.L2
.L6:
	cmpb	$47, -9(%rbp)
	jle	.L3
	cmpb	$57, -9(%rbp)
	jle	.L4
.L3:
	movl	$-3, %eax
	jmp	.L5
.L4:
	movl	-4(%rbp), %edx
	movl	%edx, %eax
	sall	$2, %eax
	addl	%edx, %eax
	addl	%eax, %eax
	movl	%eax, -4(%rbp)
	movsbl	-9(%rbp), %eax
	subl	$48, %eax
	addl	%eax, -4(%rbp)
.L2:
	movl	-8(%rbp), %eax
	leal	1(%rax), %edx
	movl	%edx, -8(%rbp)
	movslq	%eax, %rdx
	movq	-24(%rbp), %rax
	addq	%rdx, %rax
	movzbl	(%rax), %eax
	movb	%al, -9(%rbp)
	cmpb	$0, -9(%rbp)
	jne	.L6
	movl	-4(%rbp), %eax
.L5:
	popq	%rbp
	ret
.LFE0:
	.size	convert, .-convert

	.section	.rodata
.LC0:
	.string	"result is %d\n"

	.text
	.globl	main
	.type	main, @function

main:
.LFB1:
	pushq	%rbp
	movq	%rsp, %rbp
	subq	$32, %rsp
	movl	%edi, -20(%rbp)
	movq	%rsi, -32(%rbp)
	cmpl	$2, -20(%rbp)
	je	.L8
	movl	$-1, %eax
	jmp	.L9
.L8:
	movq	-32(%rbp), %rax
	movq	8(%rax), %rax
	movq	%rax, -8(%rbp)
	cmpq	$0, -8(%rbp)
	jne	.L10
	movl	$-2, %eax
	jmp	.L9
.L10:
	movq	-8(%rbp), %rax
	movq	%rax, %rdi
	call	convert
	movl	%eax, -12(%rbp)
	movl	-12(%rbp), %eax
	movl	%eax, %esi
	movl	$.LC0, %edi
	movl	$0, %eax
	call	printf
	movl	$0, %eax
.L9:
	leave
	ret
.LFE1:
	.size	main, .-main
	
	.ident	"GCC: (GNU) 11.3.0"
	.section	.note.GNU-stack,"",@progbits

```

## 汇编

`gas/as-new --64 -o main_printf.o main_printf.s`

## 链接

```shell
ld/ld-new --eh-frame-hdr \
    -dynamic-linker /lib64/ld-linux-x86-64.so.2 \
    -m elf_x86_64 \
                    \
    -o demo/main_printf \
    demo/main_printf.o   \
                            \
    /lib/x86_64-linux-gnu/crt1.o \
    /lib/x86_64-linux-gnu/crti.o \
    /lib/x86_64-linux-gnu/crtn.o \
                                \
    -L/lib/x86_64-linux-gnu \
    -L/usr/lib/x86_64-linux-gnu \
    -lc
```

## 执行

```shell

> demo/main_printf 13
result is 13

```

---

# 编译器实现

TODO

---

# 汇编器实现

## 核心数据结构



## gas实现

```c

frchainS *frchain_now;
extern fragS *frag_now;

// 虚拟符号`.`表示当前位置
symbolS dot_symbol;

int main(int argc, char **argv)
{
    // 命令行参数解析
    parse_args(&argc, &argv);

    /* 创建hash表存储符号 */
    symbol_begin();
    {
        sy_hash = htab_create_alloc(16, hash_symbol_entry, ...);
    }

    subsegs_begin();
    {
        frchain_now = NULL;
        frag_now = &dummy_frag;
    }

    /* 收集伪指令列表 */
    read_begin();
    {
        pobegin();
        {
            po_hash = htab_create_alloc(16, ...);

            /* Do the target-specific pseudo ops.  */
            md_pop_insert();
            {
                md_pseudo_table[] = {
                    {"align", s_align_bytes, 0},
                    {"arch", set_cpu_arch, 0},
                    {"bss", s_bss, 0},
                    {"intel_syntax", set_intel_syntax, 1},
                    {0, 0, 0}
                };
            }

            /* Now object specific.  Skip any that were in the target table.  */
            pop_override_ok = 1;
            obj_pop_insert();
            {
                elf_pseudo_table[] = {
                    {"local", obj_elf_local, 0},
                    {"section", obj_elf_section, 0},
                    {"pushsection", obj_elf_section, 1},
                    {"popsection", obj_elf_popsection, 0},
                    {"size", obj_elf_size, 0},
                    {"type", obj_elf_type, 0},
                    {"version", obj_elf_version, 0},
                    {"weak", obj_elf_weak, 0},

                    /* A GNU extension for object attributes.  */
                    {"gnu_attribute", obj_elf_gnu_attribute, 0},

                    /* End sentinel.  */
                    {NULL, NULL, 0},
                }
            }

            /* Now portable ones.  Skip any that we've seen already.  */
            pop_insert(potable);
            {
                potable[] = {
                    {"global", s_globl, 0},
                    {"align", s_align_ptwo, 0},
                    {"ascii", stringer, 8 + 0},

                    {"func", s_func, 0},
                    {"endfunc", s_func, 1},
                    
                    {"if", s_if, (int)O_ne},
                    {"ifeq", s_if, (int)O_eq},
                    {"ifgt", s_if, (int)O_gt},
                    {"else", s_else, 0},
                    {"elseif", s_elseif, (int)O_ne},
                    {"endif", s_endif, 0},

                    {NULL, NULL, 0} /* End sentinel.  */
                }
            }

            /* Now CFI ones: CFI=Call Frame Info.  */
            pop_override_ok = 1;
            cfi_pop_insert();
            {
                cfi_pseudo_table[] = {
                    {"cfi_startproc", dot_cfi_startproc, 0},
                    {"cfi_endproc", dot_cfi_endproc, 0},
                    {"cfi_offset", dot_cfi, DW_CFA_offset},
                    {NULL, NULL, 0};
                }
            }
        }
    }

    input_scrub_begin();
    {
        // 初始化lex数组: 每个字符的类型
        do_scrub_begin(0);
        {
            lex[' '] = LEX_IS_WHITESPACE;
            lex['\t'] = LEX_IS_WHITESPACE;
            lex['\r'] = LEX_IS_WHITESPACE;
            lex['\n'] = LEX_IS_NEWLINE;
            lex[':'] = LEX_IS_COLON;

            const char symbol_chars[] = "$._ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
            for (p = symbol_chars; *p; ++p)
                lex[(unsigned char)*p] = LEX_IS_SYMBOL_COMPONENT;

            for (c = 128; c < 256; ++c)
                lex[c] = LEX_IS_SYMBOL_COMPONENT;
        }
    }

    // 创建-o指定的输出文件
    output_file_create(out_file_name);
    {
        stdoutput = bfd_openw(name, TARGET_FORMAT);
        {
            nbfd = _bfd_new_bfd();

            bfd_find_target(target, nbfd);
            bfd_set_filename(nbfd, filename);
            nbfd->direction = write_direction;
            bfd_open_file(nbfd);
        }

        bfd_set_format(stdoutput, bfd_object);
    }

    // 表示当前地址的`.`符号
    dot_symbol_init();
    {
        dot_symbol.name = ".";
        dot_symbol.flags.forward_ref = 1;
        dot_symbol.bsym = bfd_make_empty_symbol(stdoutput);
        dot_symbol.bsym->name = ".";
        dot_symbol.x = &dot_symbol_x;
        dot_symbol.x->value.X_op = O_constant;
    }

    /* 根据命令行参数 `--defsym SYM=VAL` 合成符号插入符号表 */
    while (defsyms != NULL)
    {
        sym = symbol_new(defsyms->name, absolute_section, ...);
        S_SET_VOLATILE(sym);
        symbol_table_insert(sym);
        defsyms = defsyms->next;
    }

    perform_an_assembly_pass(argc, argv);
    {
         /* Create the standard sections, and those the assembler uses internally.  */
        text_section = subseg_new(TEXT_SECTION_NAME, 0);
        data_section = subseg_new(DATA_SECTION_NAME, 0);
        bss_section = subseg_new(BSS_SECTION_NAME, 0);

        applicable = bfd_applicable_section_flags(stdoutput);
        bfd_set_section_flags(text_section, applicable & (SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_READONLY));
        bfd_set_section_flags(data_section, applicable & (SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA));
        bfd_set_section_flags(bss_section, applicable & SEC_ALLOC);
        seg_info(bss_section)->bss = 1;

        // 默认text_section
        subseg_set(text_section, 0);

        /* 创建cpu特定的指令/寄存器符号表 */
        md_begin();
        {
             // 所有汇编指令插入op_hash
            op_hash = str_htab_create();
            i386_optab[] = {
                { "mov", 0xa0, None, 2, ... },
                { NULL, 0, 0, 0, ... };
            }

            /* Initialize reg_hash hash table.  */
	        reg_hash = str_htab_create();
            i386_regtab[] = {
                { "rax", ... },
                { "rbx", ... },
                { "rcx", ... },
                { "rdx", ... },
            }
        }

        /* 把.text/.data/.bss段名加入符号表 */
        obj_begin();

        read_a_source_file(*argv);
        {
            /* 读取数据到buf: buffer_limit指向最后一个换行符, input_line_pointer指向第一个字符 */
            while ((buffer_limit = input_scrub_next_buffer(&input_line_pointer)) != 0) {
                while (input_line_pointer < buffer_limit) {
                    // 上个字符是换行符
                    was_new_line = is_end_of_line[(unsigned char)input_line_pointer[-1]];
                    if (was_new_line) {
                        // 更新`.`
                        symbol_set_value_now(&dot_symbol);
                    }

                    // 参考上文初始化的lex: $._和字母
                    if (is_name_beginner(next_char) || next_char == '"') {
                        // 退回读取的字符
                        --input_line_pointer;

                        // 读取一个完整的标识符
                        nul_char = get_symbol_name(&s);
                        next_char = (nul_char == '"' ? input_line_pointer[1] : nul_char);
                        rest = input_line_pointer + (nul_char == '"' ? 2 : 1);

                        if (next_char == ':') {
                            // 创建label, 插入符号表
                            colon(s);
                        } else if (next_char == '=' && *rest == '=') {
                            // 赋值语句，插入符号表
                            equals(s, -1);
                        } else {
                            /* Expect pseudo-op or machine instruction.  */
                            if (*s == '.') {
                                // 标识符`.`开头的伪指令，查找伪指令表
                                pop = po_entry_find(po_hash, s + 1);

                                /* 处理伪指令 */
                                (*pop->poc_handler)(pop->poc_val);
                            } else {
                                /* 标识符表示一条汇编语句 */
                                assemble_one(s);
                                {
                                    md_assemble(line);
                                    {
                                        // 忽略汇编指令解析过程

                                        // 汇编指令写入frag
	                                    output_insn();
                                    }
                                }
                            }
                        }

                        continue;
                    }

                    // 处理`1:`之类的local label
                    if (ISDIGIT(next_char)) {
                        // 读取整个数字生成label
                        if (*input_line_pointer++ == ':')
                        {
                            /* 增加计数器 */
                            fb_label_instance_inc(temp);

                            /* 生成label_name = `.L{n}{\002}{计数器}` */
                            colon(fb_label_name(temp, 0));
                            continue;
                        }
                    }
                }
            }
        }
    }

    if (seen_at_least_1_file())
    {
        write_object_file();
        {
            subsegs_finish();

            // sec->index从0开始编码
            bfd_map_over_sections(stdoutput, renumber_sections, ...);
            // 所有frchain下的frag链接到一起
            bfd_map_over_sections(stdoutput, chain_frchains_together, (char *)0);

            struct relax_seg_info rsi;

            while (1) {
                rsi.changed = 0;
                bfd_map_over_sections(stdoutput, relax_seg, &rsi);
                if (!rsi.changed)
                    break;
            }

            bfd_map_over_sections(stdoutput, size_seg, (char *)0);

            create_obj_attrs_section();

            for (symp = symbol_rootP; symp; symp = symbol_next(symp))
			    resolve_symbol_value(symp);

            resolve_local_symbol_values();
	        resolve_reloc_expr_symbols();

            maybe_generate_build_notes();

            bfd_map_over_sections(stdoutput, adjust_reloc_syms, (char *)0);

            bfd_map_over_sections(stdoutput, fix_segment, (char *)0);

            /* Set up symbol table, and write it out.  */
            for (symp = symbol_rootP; symp; symp = symbol_next(symp)) {
                resolve_symbol_value(symp);
                symbol_get_bfdsym(symp)->value = S_GET_VALUE(symp);
            }

            /* Now that all the sizes are known, and contents correct,
               we can start writing to the file.  */
	        set_symtab();

            bfd_map_over_sections(stdoutput, write_relocs, (char *)0);

            bfd_map_over_sections(stdoutput, write_contents, (char *)0);
        }
    }
}

```

---

# 链接器实现

