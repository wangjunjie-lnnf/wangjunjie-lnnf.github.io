---
layout: post
title:  "ast"
date:   2024-05-24 21:49:07 +0000
categories: llvm
tags: llvm
---

# ast

书接上文，继续分析从`c11`源码转换为`AST`的过程，主流程如下：

```c++

/// Abstract base class to use for AST consumer-based frontend actions.
class ASTFrontendAction : public FrontendAction {
protected:
    /// Implement the ExecuteAction interface by running Sema 
    /// on the already-initialized AST consumer.
    void ExecuteAction() override;
    {
        /// Sema - implements semantic analysis and AST building for C.
        CI.createSema(getTranslationUnitKind(), ...);
        {
            TheSema.reset(new Sema(getPreprocessor(), getASTContext(), getASTConsumer(), ...));
        }
        // 预处理、词法分析、语法分析、AST生成
        ParseAST(CI.getSema(), ...);
    }
}

// 主流程
void clang::ParseAST(Sema &S, ...) {
    // ASTConsumer - 对生成的AST进一步处理
    ASTConsumer *Consumer = &S.getASTConsumer();

    // Preprocessor - 预处理源文件
    Preprocessor PP = S.getPreprocessor();

    // Parser - 解析源文件生成AST
    std::unique_ptr<Parser> ParseOP(new Parser(PP, S, ...));
    Parser &P = *ParseOP.get();

    // 开始处理源文件
    S.getPreprocessor().EnterMainSourceFile();

    // 获取第一个token
    P.Initialize();

    // 根据c11的语法规则，源文件是由一组声明语句组成的
    //
    // translation-unit:
    //     external-declaration
    //     translation-unit external-declaration
    //
    // external-declaration:
    //     function-definition
    //     declaration
    //
    // 每次声明可能包含多个变量，例如：`int a,b;`，所以类型是`DeclGroup`
    Parser::DeclGroupPtrTy ADecl;
    for (bool AtEOF = P.ParseFirstTopLevelDecl(ADecl, ImportState); 
         !AtEOF;
         AtEOF = P.ParseTopLevelDecl(ADecl, ImportState)) {
        // Consumer来决定如何使用解析的结果
        Consumer->HandleTopLevelDecl(ADecl.get());
    }

    Consumer->HandleTranslationUnit(S.getASTContext());
}

```

## 核心类

搞明白整个流程的关键是梳理几个核心类的关联关系及各自的职责

```c++

/// Parser - This implements a parser for the C family of languages.
/// Parser驱动别的类完成AST构造过程
class Parser : public CodeCompletionHandler {
private:
    // 预处理器
    Preprocessor &PP;

    /// 当前有效的token
    /// Tok - The current token we are peeking ahead.  
    /// All parsing methods assume that this is valid.
    Token Tok;

    /// Actions - These are the callbacks we invoke as we parse various constructs in the file.
    Sema &Actions;

public:
    Preprocessor &getPreprocessor() const { return PP; }
    Sema &getActions() const { return Actions; }
    const Token &getCurToken() const { return Tok; }

    /// Initialize - Warm up the parser.
    void Initialize();

    /// Parse the first top-level declaration in a translation unit.
    bool ParseFirstTopLevelDecl(DeclGroupPtrTy &Result, ...);

    /// ParseTopLevelDecl - Parse one top-level declaration.
    bool ParseTopLevelDecl(DeclGroupPtrTy &Result, ...);

    ExprResult ParseExpression(...);
    ExprResult ParseCaseExpression(...);
    ExprResult ParseAssignmentExpression(...);
    ExprResult ParseUnaryExprOrTypeTraitExpression();
    ExprResult ParseRHSOfBinaryExpression(ExprResult LHS, ...);
    ExprResult ParseParenExpression(...);

    StmtResult ParseStatement(...);
    StmtResult ParseExprStatement(...);
    StmtResult ParseLabeledStatement(...);
    StmtResult ParseCaseStatement(...);
    StmtResult ParseDefaultStatement(...);
    StmtResult ParseCompoundStatement(...);
    StmtResult ParseIfStatement(...);
    StmtResult ParseSwitchStatement(...);
    StmtResult ParseWhileStatement(...);
    StmtResult ParseDoStatement();
    StmtResult ParseForStatement(...);
    StmtResult ParseGotoStatement();
    StmtResult ParseContinueStatement();
    StmtResult ParseBreakStatement();
    StmtResult ParseReturnStatement();
    StmtResult ParseAsmStatement(...);
}

/// 管理lexer栈产生token，处理各种宏指令
class Preprocessor {
    // 语言的各种特性开关
    const LangOptions &LangOpts;

    // cpu/os等平台信息
    const TargetInfo *Target = nullptr;
    const TargetInfo *AuxTarget = nullptr;

    // 源文件管理
    FileManager       &FileMgr;
    SourceManager     &SourceMgr;
    HeaderSearch      &HeaderInfo;

    /// 核心对象CurLexer和CurTokenLexer分别表示解析源文件和宏扩展

    /// The current top of the stack that we're lexing from if
    /// not expanding a macro and we are lexing directly from source code.
    /// Only one of CurLexer, or CurTokenLexer will be non-null.
    std::unique_ptr<Lexer> CurLexer;

    /// The current macro we are expanding, if we are expanding a macro.
    /// One of CurLexer and CurTokenLexer must be null.
    std::unique_ptr<TokenLexer> CurTokenLexer;

    // 通过callback选择CurLexer或CurTokenLexer
    /// The kind of lexer we're currently working with.
    typedef bool (*LexerCallback)(Preprocessor &, Token &);
    LexerCallback CurLexerCallback = &CLK_Lexer;

    /// 此结构用于处理`#include`，类似函数调用产生的栈帧
    /// Keeps track of the stack of files currently `#included`,
    /// and macros currently being expanded from, not counting CurLexer/CurTokenLexer.
    struct IncludeStackInfo {
        LexerCallback               CurLexerCallback;
        std::unique_ptr<Lexer>      TheLexer;
        PreprocessorLexer          *ThePPLexer;
        std::unique_ptr<TokenLexer> TheTokenLexer;
    }
    std::vector<IncludeStackInfo> IncludeMacroStack;

    /// map结构的宏定义符号表，记录每个标识符定义的macro的历史
    /// For each IdentifierInfo that was associated with a macro, we
    /// keep a mapping to the history of all macro definitions and #undefs in
    /// the reverse order (the latest one is in the head of the list).
    ///
    /// This mapping lives within the `CurSubmoduleState`.
    using MacroMap = llvm::DenseMap<const IdentifierInfo *, MacroState>;

    /// Information about a submodule's preprocessor state.
    struct SubmoduleState {
        /// The macros for the submodule.
        MacroMap Macros;
    };
    SubmoduleState *CurSubmoduleState;

    /// 包含系统内置的变量以及命令行通过-Dkey=val指定的变量
    /// The predefined macros that preprocessor should use from the command line etc.
    std::string Predefines;

public:
    /// Enter the specified FileID as the main source file,
    /// which implicitly adds the builtin defines etc.
    void EnterMainSourceFile();
    {
        // 加载当前文件到内存
        EnterSourceFile(MainFileID, ...);

        // 加载系统预定义的变量
        std::unique_ptr<llvm::MemoryBuffer> SB = llvm::MemoryBuffer::getMemBufferCopy(Predefines, "<built-in>");
        FileID FID = SourceMgr.createFileID(std::move(SB));
        // 此处的效果就是源文件的开头处定义了这些系统变量！！！
        EnterSourceFile(FID, ...);
    }

    /// Add a source file to the top of the include stack and
    /// start lexing tokens from it instead of the current buffer.
    bool EnterSourceFile(FileID FID, ...);
    {
            // 构造词法解析器
            Lexer *TheLexer = new Lexer(FID, *InputFile, *this, ...);
            EnterSourceFileWithLexer(TheLexer, CurDir);
            {
                // 每个源文件都有配套的多个lexer以及关联信息，这些信息的组织结构类似函数的栈帧
                // a调用b，b调用c，会给a/b/c都创建栈帧结构存储各自的信息
                // 同样，a通过`#include`包含b，b通过`#include`包含c，a/b/c各自都会有自己的lexer，然后以类似栈帧的结构组织
                if (CurPPLexer || CurTokenLexer)
                    // 保存lexer
                    PushIncludeMacroStack();
                    {
                        IncludeMacroStack.emplace_back(..., std::move(CurLexer), CurPPLexer, std::move(CurTokenLexer), CurDirLookup);
                    }
                CurLexer.reset(TheLexer);
                CurPPLexer = TheLexer;
                CurDirLookup = CurDir;
                // callback指向Lexer
                CurLexerCallback = CLK_Lexer;
            }
        }

    /// Add a Macro to the top of the include stack and start lexing
    /// tokens from it instead of the current buffer.
    void EnterMacro(Token &Tok, ..., MacroInfo *Macro, MacroArgs *Args);
    {
        std::unique_ptr<TokenLexer> TokLexer = std::make_unique<TokenLexer>(Tok, ILEnd, Macro, Args, *this);
        
        // 保存当前的lexer
        PushIncludeMacroStack();
        CurDirLookup = nullptr;
        // 替换为macro扩展lexer
        CurTokenLexer = std::move(TokLexer);
        // callback指向TokenLexer
        CurLexerCallback = CLK_TokenLexer;
    }

    /// Callback invoked when the lexer hits the end of the current file.
    bool HandleEndOfFile(Token &Result, bool isEndOfMacro = false);
    {
        if (!IncludeMacroStack.empty()) {
            // 还原lexer
            RemoveTopOfLexerStack();
            {
                PopIncludeMacroStack();
                {
                    CurLexer = std::move(IncludeMacroStack.back().TheLexer);
                    CurPPLexer = IncludeMacroStack.back().ThePPLexer;
                    CurTokenLexer = std::move(IncludeMacroStack.back().TheTokenLexer);
                    CurLexerCallback = IncludeMacroStack.back().CurLexerCallback;
                    IncludeMacroStack.pop_back();
                }
            }
        }
    }

    /// Callback invoked when the current TokenLexer hits the end of its token stream.
    bool HandleEndOfTokenLexer(Token &Result);
    {
        // Handle this like a #include file being popped off the stack.
        return HandleEndOfFile(Result, true);
    }

    /// Lex the next token for this preprocessor.
    void Lex(Token &Result);
    {
        CurLexerCallback(*this, Result);
        {
            CurLexer->Lex(Result);
        }
    }

    // callbacks: lexer在处理过程中调用callback触发预处理

    /// Callback invoked when the lexer reads an identifier and has
    /// filled in the tokens IdentifierInfo member.
    /// 检查已识别的标识符是否是已定义的macro
    bool HandleIdentifier(Token &Identifier);

    /// Callback invoked when the lexer sees a # token at the start of a line.
    ///
    /// This consumes the directive, modifies the lexer/preprocessor state, and
    /// advances the lexer(s) so that the next token read is the correct one.
    void HandleDirective(Token &Result);

    // 处理各种macro指令
    void HandleIncludeDirective(...);
    void HandleDefineDirective(...);
    void HandleUndefDirective();
    void HandleIfdefDirective(...);
    void HandleIfDirective(...);
    void HandleEndifDirective(...);
    void HandleElseDirective(...);
    void HandleElifFamilyDirective(...);
    void HandlePragmaDirective(...);
    void HandleUndefDirective(...);
}

/// Lexer - This provides a simple interface that turns a text buffer into a stream of tokens.
/// Lexers know only about tokens within a single source file, and don't
/// know anything about preprocessor-level issues like the \#include stack, etc.
/// lexer只能看到某一个源文件，看不到全局
class Lexer : public PreprocessorLexer {
    // Start of the buffer.
    const char *BufferStart;
    // End of the buffer.
    const char *BufferEnd;
    // BufferPtr - Current pointer into the buffer. This is the next character to be lexed.
    const char *BufferPtr;

    void InitLexer(const char *BufStart, const char *BufPtr, const char *BufEnd);

    /// Lex - Return the next token in the file.
    /// If this is the end of file, it return the tok::eof token.
    bool Lex(Token &Result);
}

/// TokenLexer - This implements a lexer that returns tokens from a macro body
/// or token stream instead of lexing from a character buffer.  This is used for
/// macro expansion and _Pragma handling, for example.
class TokenLexer {

    /// The macro we are expanding from. This is null if expanding a token stream.
    MacroInfo *Macro = nullptr;

    /// The actual arguments specified for a function-like macro, or null.
    MacroArgs *ActualArgs = nullptr;

    /// This is the pointer to an array of tokens that the macro is defined to,
    /// with arguments expanded for function-like macros. 
    /// If this is a token stream, these are the tokens we are returning.
    const Token *Tokens;

public:
    // 从宏扩展的结果提取token
    TokenLexer(Token &Tok, ..., MacroInfo *MI, MacroArgs *ActualArgs, Preprocessor &pp) {
        Macro = MI;
        ActualArgs = Actuals;
        Tokens = &*Macro->tokens_begin();
    }

    // 直接从token流提取token
    TokenLexer(const Token *TokArray, unsigned NumToks, ..., Preprocessor &pp) {
        Macro = nullptr;
        ActualArgs = nullptr;
        Tokens = TokArray;
        NumTokens = NumToks;
        CurTokenIdx = 0;
    }

    /// Lex and return a token from this macro stream.
    bool Lex(Token &Tok);
}

/// Sema - This implements semantic analysis and AST building for C.
class Sema final {
public:
    Preprocessor &PP;

    // 用于语义分析的符号表
    ASTContext &Context;

    // AST的使用方
    ASTConsumer &Consumer;

    /// CurContext - This is the current declaration context of parsing.
    DeclContext *CurContext;

    void Initialize();

    // 管理作用域
    void PushFunctionScope();
    void PushBlockScope(Scope *BlockScope, BlockDecl *Block);
    void PushCompoundScope(bool IsStmtExpr);
    void PopCompoundScope();
    void ActOnPopScope(SourceLocation Loc, Scope *S);
    void ActOnTranslationUnitScope(Scope *S);

    void PushDeclContext(Scope *S, DeclContext *DC);
    void PopDeclContext();
    void EnterDeclaratorContext(Scope *S, DeclContext *DC);
    void ExitDeclaratorContext(Scope *S);

    // 维护自身状态
    void ActOnStartOfTranslationUnit();
    void ActOnEndOfTranslationUnit();
    void ActOnStartFunctionDeclarationDeclarator(Declarator &D, ...);
    void ActOnFinishFunctionDeclarationDeclarator(Declarator &D);
    void ActOnFinishInlineFunctionDef(FunctionDecl *D);
    void ActOnDefinedDeclarationSpecifier(Decl *D);
    void ActOnDefs(Scope *S, Decl *TagD, ...);
    void ActOnEnumBody(...);
    void ActOnStartOfCompoundStmt(bool IsStmtExpr);
    void ActOnFinishOfCompoundStmt();
    void ActOnForEachDeclStmt(DeclGroupPtrTy Decl);
    void ActOnCaseStmtBody(Stmt *CaseStmt, Stmt *SubStmt);

    // 生成ast
    Decl *ActOnDeclarator(Scope *S, Declarator &D);
    Decl *ActOnParamDeclarator(Scope *S, Declarator &D, ...);
    Decl *ActOnStartOfFunctionDef(Scope *S, Declarator &D, ...);
    Decl *ActOnFinishFunctionBody(Decl *Decl, Stmt *Body);
    Decl *ActOnFileScopeAsmDecl(Expr *expr, ...);
    Decl *ActOnTopLevelStmtDecl(Stmt *Statement);
    Decl *ActOnField(Scope *S, Decl *TagD, ...);
    Decl *ActOnEnumConstant(Scope *S, Decl *EnumDecl, Decl *LastEnumConstant, ...);

    TypeResult ActOnTypeName(Declarator &D);
    NamedDecl* ActOnFunctionDeclarator(Scope* S, Declarator& D, ...);

    StmtResult ActOnExprStmt(ExprResult Arg, bool DiscardedValue = true);
    StmtResult ActOnCompoundStmt(...);
    StmtResult ActOnDeclStmt(DeclGroupPtrTy Decl, ...);
    StmtResult ActOnForEachLValueExpr(Expr *E);
    StmtResult ActOnCaseStmt(ExprResult LHS, ...);
    StmtResult ActOnDefaultStmt(...);
    StmtResult ActOnLabelStmt(...);
    StmtResult ActOnIfStmt(...);
    StmtResult ActOnStartOfSwitchStmt(...);
    StmtResult ActOnFinishSwitchStmt(...);
    StmtResult ActOnWhileStmt(...);
    StmtResult ActOnDoStmt(...);
    StmtResult ActOnForStmt(...);
    StmtResult ActOnGotoStmt(...);
    StmtResult ActOnIndirectGotoStmt(...);
    StmtResult ActOnContinueStmt(...);
    StmtResult ActOnBreakStmt(...);
    StmtResult ActOnReturnStmt(...);
    StmtResult ActOnGCCAsmStmt(...);

    ExprResult ActOnPredefinedExpr(...);
    ExprResult ActOnIntegerConstant(...);
    ExprResult ActOnNumericConstant(...);
    ExprResult ActOnCharacterConstant(...);
    ExprResult ActOnParenExpr(...);
    ExprResult ActOnParenListExpr(...);
    ExprResult ActOnStringLiteral(...);
    ExprResult ActOnUnaryOp(...);
    ExprResult ActOnUnaryExprOrTypeTraitExpr(...);
    ExprResult ActOnPostfixUnaryOp(...);
    ExprResult ActOnArraySubscriptExpr(...);
    ExprResult ActOnMemberAccessExpr(...);
    ExprResult ActOnCallExpr(...);
    ExprResult ActOnCastExpr(...);
    ExprResult ActOnCaseExpr(..., ExprResult Val);
    ExprResult ActOnBinOp(...);
    ExprResult ActOnConditionalOp(...);
    ExprResult ActOnStmtExpr(...);
    ExprResult ActOnStmtExprResult(...);
}

```

从以上核心代码可以看出他们的职责和关系如下：
* `Lexer`负责解析单个源文件的`token`，`TokenLexer`负责处理`macro`扩展
* `Preprocessor`负责管理`lexer`栈并处理`#include/#define`等预处理指令
* `Parser`负责根据语法规则驱动解析的过程，从`Preprocessor`获取token，把语法单元传递给`Sema`
* `Sema`负责对语法单元进行语义分析以及生成`AST`


## 词法分析

`Lexer`负责解析单个源文件的`token`，遇到标识符和宏指令时通过`callback`通知`Preprocessor`进行处理

```c++

// 解析每个字符，根据c11的词法规则分析其类型
bool Lexer::Lex(Token &Result) {
    // Start a new token.
    Result.startToken();
    {
        Kind = tok::unknown;
        Flags = 0;
        PtrData = nullptr;
        UintData = 0;
    }

    // 数字常量/字符串常量/标识符/宏指令/各种标点及其组合
    return LexTokenInternal(Result, atPhysicalStartOfLine);
    {
    LexStart:
        const char *CurPtr = BufferPtr;

        // 跳过空白
        if (isHorizontalWhitespace(*CurPtr)) {
            do {
                ++CurPtr;
            } while (isHorizontalWhitespace(*CurPtr));

            BufferPtr = CurPtr;
            Result.setFlag(Token::LeadingSpace);
        }

        // 处理转义，获取一个有效字符
        char Char = getAndAdvanceChar(CurPtr, Result);

        tok::TokenKind Kind;

        switch (Char) {
        case 0:  // Null.
            // Found end of file?
            if (CurPtr - 1 == BufferEnd)
                return LexEndOfFile(Result, CurPtr-1);
            
            SkipWhitespace(Result, CurPtr, TokAtPhysicalStartOfLine);
            goto LexNextToken;
        case '\r':
            if (CurPtr[0] == '\n')
                (void)getAndAdvanceChar(CurPtr, Result);
            [[fallthrough]];
        case '\n':
            // No leading whitespace seen so far.
            Result.clearFlag(Token::LeadingSpace);
            SkipWhitespace(Result, CurPtr, TokAtPhysicalStartOfLine);
            goto LexNextToken;
        case ' ':
        case '\t':
            // 跳过行内空白
            SkipHorizontalWhitespace:
                Result.setFlag(Token::LeadingSpace);
                SkipWhitespace(Result, CurPtr, TokAtPhysicalStartOfLine);
            
            // 跳过注释
            SkipIgnoredUnits:
                CurPtr = BufferPtr;

            if (CurPtr[0] == '/' && CurPtr[1] == '/') {
                SkipLineComment(Result, CurPtr+2, TokAtPhysicalStartOfLine);
                goto SkipIgnoredUnits;
            } else if (CurPtr[0] == '/' && CurPtr[1] == '*') {
                SkipBlockComment(Result, CurPtr+2, TokAtPhysicalStartOfLine);
                goto SkipIgnoredUnits;
            } else if (isHorizontalWhitespace(*CurPtr)) {
                goto SkipHorizontalWhitespace;
            }

            goto LexNextToken;
        
        // 数字常量
        case '0': case '1': case '2': case '3': case '4':
        case '5': case '6': case '7': case '8': case '9':
            return LexNumericConstant(Result, CurPtr);
        
        // Identifier (e.g., uber), or
        // UTF-8 (C23/C++17) or UTF-16 (C11/C++11) character literal, or
        // UTF-8 or UTF-16 string literal (C11/C++11).
        case 'u':
        // Identifier (e.g. Uber) or C11/C++11 UTF-32 string literal
        case 'U':
        // Identifier or C++0x raw string literal
        case 'R':
            // 对于c11来说都是普通字符
            return LexIdentifierContinue(Result, CurPtr);
        // Identifier (e.g. Loony) or wide literal (L'x' or L"xyz").
        case 'L':
            Char = getCharAndSize(CurPtr, SizeTmp);
            // Wide string literal.
            if (Char == '"')
                return LexStringLiteral(Result, ...);
            // Wide character constant.
            if (Char == '\'')
                return LexCharConstant(Result, ...);
            [[fallthrough]];
        // C99 6.4.2: Identifiers.
        case 'A': case 'B': case 'C': case 'D': case 'E': case 'F': case 'G':
        case 'H': case 'I': case 'J': case 'K':    /*'L'*/case 'M': case 'N':
        case 'O': case 'P': case 'Q':    /*'R'*/case 'S': case 'T':    /*'U'*/
        case 'V': case 'W': case 'X': case 'Y': case 'Z':
        case 'a': case 'b': case 'c': case 'd': case 'e': case 'f': case 'g':
        case 'h': case 'i': case 'j': case 'k': case 'l': case 'm': case 'n':
        case 'o': case 'p': case 'q': case 'r': case 's': case 't':    /*'u'*/
        case 'v': case 'w': case 'x': case 'y': case 'z':
        case '_':
            return LexIdentifierContinue(Result, CurPtr);
        // C99 6.4.4: Character Constants.
        case '\'':
            return LexCharConstant(Result, CurPtr, tok::char_constant);
        // C99 6.4.5: String Literals.
        case '"':
            return LexStringLiteral(Result, CurPtr, ...);
        case '$':
            Kind = tok::unknown;
            break;   
        // C99 6.4.6: Punctuators.
        case '?':
            Kind = tok::question;
            break;
        case '[':
            Kind = tok::l_square;
            break;
        case ']':
            Kind = tok::r_square;
            break;
        case '(':
            Kind = tok::l_paren;
            break;
        case ')':
            Kind = tok::r_paren;
            break;
        case '{':
            Kind = tok::l_brace;
            break;
        case '}':
            Kind = tok::r_brace;
            break;
        case '.':
            Char = getCharAndSize(CurPtr, SizeTmp);
            // 浮点数
            if (Char >= '0' && Char <= '9') {
                return LexNumericConstant(Result, ...);
            } else if (Char == '.' && getCharAndSize(CurPtr+SizeTmp, SizeTmp2) == '.') {
                // 三个点
                Kind = tok::ellipsis;
                CurPtr = ConsumeChar(ConsumeChar(CurPtr, SizeTmp, Result), SizeTmp2, Result);
            } else {
                Kind = tok::period;
            }
            break;
        case '&':
            Char = getCharAndSize(CurPtr, SizeTmp);
            if (Char == '&') {
                Kind = tok::ampamp;
                CurPtr = ConsumeChar(CurPtr, SizeTmp, Result);
            } else if (Char == '=') {
                Kind = tok::ampequal;
                CurPtr = ConsumeChar(CurPtr, SizeTmp, Result);
            } else {
                Kind = tok::amp;
            }
            break;
        case '*':
            if (getCharAndSize(CurPtr, SizeTmp) == '=') {
                Kind = tok::starequal;
                CurPtr = ConsumeChar(CurPtr, SizeTmp, Result);
            } else {
                Kind = tok::star;
            }
            break;
        case '+':
            Char = getCharAndSize(CurPtr, SizeTmp);
            if (Char == '+') {
                CurPtr = ConsumeChar(CurPtr, SizeTmp, Result);
                Kind = tok::plusplus;
            } else if (Char == '=') {
                CurPtr = ConsumeChar(CurPtr, SizeTmp, Result);
                Kind = tok::plusequal;
            } else {
                Kind = tok::plus;
            }
            break;
        case '-':
            Char = getCharAndSize(CurPtr, SizeTmp);
            if (Char == '-') {      // --
                CurPtr = ConsumeChar(CurPtr, SizeTmp, Result);
                Kind = tok::minusminus;
            } else if (Char == '>') {   // ->
                CurPtr = ConsumeChar(CurPtr, SizeTmp, Result);
                Kind = tok::arrow;
            } else if (Char == '=') {   // -=
                CurPtr = ConsumeChar(CurPtr, SizeTmp, Result);
                Kind = tok::minusequal;
            } else {
                Kind = tok::minus;
            }
            break;
        case '~':
            Kind = tok::tilde;
            break;
        case '!':
            if (getCharAndSize(CurPtr, SizeTmp) == '=') {
                Kind = tok::exclaimequal;
                CurPtr = ConsumeChar(CurPtr, SizeTmp, Result);
            } else {
                Kind = tok::exclaim;
            }
            break;
        case '/':
            // 6.4.9: Comments
            Char = getCharAndSize(CurPtr, SizeTmp);
            if (Char == '/') {         // Line comment.
                SkipLineComment(Result, ...);
                goto SkipIgnoredUnits;
            }
            if (Char == '*') {  // /**/ comment.
                SkipBlockComment(Result, ...);
                goto LexNextToken;
            }

            if (Char == '=') {
                CurPtr = ConsumeChar(CurPtr, SizeTmp, Result);
                Kind = tok::slashequal;
            } else {
                Kind = tok::slash;
            }
            break;
        case '%':
            Char = getCharAndSize(CurPtr, SizeTmp);
            if (Char == '=') {
                Kind = tok::percentequal;
                CurPtr = ConsumeChar(CurPtr, SizeTmp, Result);
            } else {
                Kind = tok::percent;
            }
            break;
        case '<':
            Char = getCharAndSize(CurPtr, SizeTmp);
            if (ParsingFilename) {
                return LexAngledStringLiteral(Result, CurPtr);
            } else if (Char == '<') {
                char After = getCharAndSize(CurPtr+SizeTmp, SizeTmp2);
                if (After == '=') {
                    Kind = tok::lesslessequal;
                    CurPtr = ConsumeChar(ConsumeChar(CurPtr, SizeTmp, Result), SizeTmp2, Result);
                } else {
                    CurPtr = ConsumeChar(CurPtr, SizeTmp, Result);
                    Kind = tok::lessless;
                }
            } else if (Char == '=') {
                CurPtr = ConsumeChar(CurPtr, SizeTmp, Result);
                Kind = tok::lessequal;
            } else {
                Kind = tok::less;
            }
            break;
        case '>':
            Char = getCharAndSize(CurPtr, SizeTmp);
            if (Char == '=') {
                CurPtr = ConsumeChar(CurPtr, SizeTmp, Result);
                Kind = tok::greaterequal;
            } else if (Char == '>') {
                char After = getCharAndSize(CurPtr+SizeTmp, SizeTmp2);
                if (After == '=') {
                    CurPtr = ConsumeChar(ConsumeChar(CurPtr, SizeTmp, Result), SizeTmp2, Result);
                    Kind = tok::greatergreaterequal;
                } else {
                    CurPtr = ConsumeChar(CurPtr, SizeTmp, Result);
                    Kind = tok::greatergreater;
                }
            } else {
                Kind = tok::greater;
            }
            break;
        case '^':
            Char = getCharAndSize(CurPtr, SizeTmp);
            if (Char == '=') {
                CurPtr = ConsumeChar(CurPtr, SizeTmp, Result);
                Kind = tok::caretequal;
            } else {
                Kind = tok::caret;
            }
            break;
        case '|':
            Char = getCharAndSize(CurPtr, SizeTmp);
            if (Char == '=') {
                Kind = tok::pipeequal;
                CurPtr = ConsumeChar(CurPtr, SizeTmp, Result);
            } else if (Char == '|') {
                Kind = tok::pipepipe;
                CurPtr = ConsumeChar(CurPtr, SizeTmp, Result);
            } else {
                Kind = tok::pipe;
            }
            break;
        case ':':
            Char = getCharAndSize(CurPtr, SizeTmp);
            if (Char == ':') {
                Kind = tok::coloncolon;
                CurPtr = ConsumeChar(CurPtr, SizeTmp, Result);
            } else {
                Kind = tok::colon;
            }
            break;
        case ';':
            Kind = tok::semi;
            break;
        case '=':
            Char = getCharAndSize(CurPtr, SizeTmp);
            if (Char == '=') {
                Kind = tok::equalequal;
                CurPtr = ConsumeChar(CurPtr, SizeTmp, Result);
            } else {
                Kind = tok::equal;
            }
            break;
        case ',':
            Kind = tok::comma;
            break;
        case '#':
            Char = getCharAndSize(CurPtr, SizeTmp);
            if (Char == '#') {
                Kind = tok::hashhash;
                CurPtr = ConsumeChar(CurPtr, SizeTmp, Result);
            } else {
                // We parsed a # character.  If this occurs at the start of the line,
                // it's actually the start of a preprocessing directive.  Callback to
                // the preprocessor to handle it.
                if (TokAtPhysicalStartOfLine && !LexingRawMode && !Is_PragmaLexer)
                    goto HandleDirective;

                Kind = tok::hash;
            }
            break;
        case '@':
            Kind = tok::unknown;
            break;

        // UCNs (C99 6.4.3, C++11 [lex.charset]p2)
        case '\\':
            if (uint32_t CodePoint = tryReadUCN(CurPtr, BufferPtr, &Result)) {
                if (CheckUnicodeWhitespace(Result, CodePoint, CurPtr)) {
                    SkipWhitespace(Result, CurPtr, TokAtPhysicalStartOfLine);

                    // We only saw whitespace, so just try again with this lexer.
                    // (We manually eliminate the tail call to avoid recursion.)
                    goto LexNextToken;
                }

                return LexUnicodeIdentifierStart(Result, CodePoint, CurPtr);
            }

            Kind = tok::unknown;
            break;

        default: {
            if (isASCII(Char)) {
                Kind = tok::unknown;
                break;
            }

            BufferPtr = CurPtr+1;
            goto LexNextToken;
        }
        }

        // Update the location of token as well as BufferPtr.
        FormTokenWithChars(Result, CurPtr, Kind);
        return true;

    HandleDirective:
        // 处理#开头的指令
        FormTokenWithChars(Result, CurPtr, tok::hash);
        PP->HandleDirective(Result);
        return false;

    LexNextToken:
        Result.clearFlag(Token::NeedsCleaning);
        goto LexStart;
    }
}

// 识别标识符
bool Lexer::LexIdentifierContinue(Token &Result, const char *CurPtr) {
    CurPtr = fastParseASCIIIdentifier(CurPtr, BufferEnd);
    {
        unsigned char C = *CurPtr;
        while (isAsciiIdentifierContinue(C))
            C = *++CurPtr;
        return CurPtr;
    }

    const char *IdStart = BufferPtr;
    FormTokenWithChars(Result, CurPtr, tok::raw_identifier);
    Result.setRawIdentifierData(IdStart);

    const IdentifierInfo *II = PP->LookUpIdentifierInfo(Result);

    // 判断标识符是否是已定义的macro，是则需要进行宏扩展
    // Finally, now that we know we have an identifier, pass this off to the
    // preprocessor, which may macro expand it or something.
    if (II->isHandleIdentifierCase())
        return PP->HandleIdentifier(Result);

    return true;
}

```

`TokenLexer`负责处理宏扩展

```c++

bool TokenLexer::Lex(Token &Tok) {
    if (isAtEnd()) {
        // 根据c11规则: 正在扩展的macro不允许再次扩展
        if (Macro) Macro->EnableMacro();

        Tok.startToken();
        Tok.setFlagValue(Token::StartOfLine , AtStartOfLine);
        Tok.setFlagValue(Token::LeadingSpace, ...);
        if (CurTokenIdx == 0)
            Tok.setFlag(Token::LeadingEmptyMacro);
        return PP.HandleEndOfTokenLexer(Tok);
    }

    bool isFirstToken = CurTokenIdx == 0;

    // Get the next token to return.
    Tok = Tokens[CurTokenIdx++];

    // 宏扩展时遇到##表示其前后的token需要进行拼接
    // If this token is followed by a token paste (##) operator, paste the tokens!
    if (!isAtEnd() && Macro && Tokens[CurTokenIdx].is(tok::hashhash)) {
        pasteTokens(Tok);
    }

    if (isFirstToken) {
        Tok.setFlagValue(Token::StartOfLine , AtStartOfLine);
        Tok.setFlagValue(Token::LeadingSpace, HasLeadingSpace);
    } else {
        if (AtStartOfLine) Tok.setFlag(Token::StartOfLine);
        if (HasLeadingSpace) Tok.setFlag(Token::LeadingSpace);
    }
    AtStartOfLine = false;
    HasLeadingSpace = false;

    // 扩展过程中又遇到已定义的宏需要扩展
    // Handle recursive expansion!
    if (Tok.getIdentifierInfo() != nullptr) {
        IdentifierInfo *II = Tok.getIdentifierInfo();
        Tok.setKind(II->getTokenID());

        if (!DisableMacroExpansion && II->isHandleIdentifierCase())
            return PP.HandleIdentifier(Tok);
    }

    return true;
}

```

## 预处理

```c++

// 检查标识符是否需要扩展
void Preprocessor::HandleIdentifier(Token & Identifier) {
    IdentifierInfo &II = *Identifier.getIdentifierInfo();

    // 检查macro符号表判断标识符是否是已定义的macro
    if (const MacroDefinition MD = getMacroDefinition(&II)) {
        const auto *MI = MD.getMacroInfo();

        if (!Identifier.isExpandDisabled() && MI->isEnabled()) {
            // C99 6.10.3p10: If the preprocessing token immediately after the
            // macro name isn't a '(', this macro should not be expanded.
            // 简单宏和函数宏都要扩展
            if (!MI->isFunctionLike() || isNextPPTokenLParen())
                return HandleMacroExpandedIdentifier(Identifier, MD);
        } else {
            // C99 6.10.3.4p2 says that a disabled macro may never again be
            // expanded, even if it's in a context where it could be expanded in the future.
            // 一个宏在其某次递归扩展的过程中只能扩展一次
            Identifier.setFlag(Token::DisableExpand);
        }
    }

    return true;
}

/// HandleMacroExpandedIdentifier - If an identifier token is read that is to be
/// expanded as a macro, handle it and return the next token as 'Identifier'.
bool Preprocessor::HandleMacroExpandedIdentifier(Token &Identifier,
                                                 const MacroDefinition &M) {
    MacroInfo *MI = M.getMacroInfo();

    // If this is a builtin macro, like __LINE__ or _Pragma, handle it specially.
    if (MI->isBuiltinMacro()) {
        if (Callbacks)
            Callbacks->MacroExpands(Identifier, M, ..., /*Args=*/nullptr);
        ExpandBuiltinMacro(Identifier);
        return true;
    }

    /// Args - If this is a function-like macro expansion, this contains,
    /// for each macro argument, the list of tokens that were provided to the invocation.
    MacroArgs *Args = nullptr;

    // If this is a function-like macro, read the arguments.
    if (MI->isFunctionLike()) {
        // 解析macro扩展的参数
        Args = ReadMacroCallArgumentList(Identifier, MI, ExpansionEnd);
    }

    ...

    // Start expanding the macro.
    EnterMacro(Identifier, ExpansionEnd, MI, Args);
    return false;
}

/// HandleDirective - This callback is invoked when the lexer sees a # token
/// at the start of a line.  This consumes the directive, modifies the
/// lexer/preprocessor state, and advances the lexer(s) so that the next token
/// read is the correct one.
void Preprocessor::HandleDirective(Token &Result) {
    // Read the next token, the directive flavor.  
    // This isn't expanded due to C99 6.10.3p8.
    LexUnexpandedToken(Result);

    switch (Result.getKind()) {
    case tok::numeric_constant:  // # 7  GNU line marker directive.
        return HandleDigitDirective(Result);
    default:
        IdentifierInfo *II = Result.getIdentifierInfo();
        // Ask what the preprocessor keyword ID is.
        switch (II->getPPKeywordID()) {
        default: break;
        // C99 6.10.1 - Conditional Inclusion.
        case tok::pp_if:
            return HandleIfDirective(Result, ...);
        case tok::pp_ifdef:
            return HandleIfdefDirective(Result, ...);
        case tok::pp_ifndef:
            return HandleIfdefDirective(Result, ...);
        case tok::pp_elif:
        case tok::pp_elifdef:
        case tok::pp_elifndef:
            return HandleElifFamilyDirective(Result, ...);
        case tok::pp_else:
            return HandleElseDirective(Result, SavedHash);
        case tok::pp_endif:
            return HandleEndifDirective(Result);

        // C99 6.10.2 - Source File Inclusion.
        case tok::pp_include:
            // Handle #include.
            return HandleIncludeDirective(..., Result);
        case tok::pp___include_macros:
            // Handle -imacros.
            return HandleIncludeMacrosDirective(..., Result);

        // C99 6.10.3 - Macro Replacement.
        case tok::pp_define:
            return HandleDefineDirective(Result, ImmediatelyAfterTopLevelIfndef);
        case tok::pp_undef:
            return HandleUndefDirective();

        // C99 6.10.4 - Line Control.
        case tok::pp_line:
            return HandleLineDirective();

        // C99 6.10.5 - Error Directive.
        case tok::pp_error:
            return HandleUserDiagnosticDirective(Result, false);

        // C99 6.10.6 - Pragma Directive.
        case tok::pp_pragma:
            return HandlePragmaDirective({PIK_HashPragma, SavedHash.getLocation()});
        }
        break;
    }
}

void Preprocessor::HandleIncludeDirective(...) {
    Token FilenameTok;
    LexHeaderName(FilenameTok);

    HandleHeaderIncludeOrImport(FilenameTok, ...);
    {
        OptionalFileEntryRef File = LookupHeaderIncludeOrImport(...);

        // Check that we don't have infinite #include recursion.
        if (IncludeMacroStack.size() == MaxAllowedIncludeStackDepth-1) {
            Diag(FilenameTok, diag::err_pp_include_too_deep);
            HasReachedMaxIncludeDepth = true;
            return {ImportAction::None};
        }

        FileID FID = SourceMgr.createFileID(*File, IncludePos, FileCharacter);
        EnterSourceFile(FID, CurDir, ...);
    }
}

```


## 语法分析

此处只考虑`c11`的语法和语义

```c++

void Parser::Initialize() {
    // Sema的各种callback
    EnterScope(Scope::DeclScope);
    Actions.ActOnTranslationUnitScope(getCurScope());
    Actions.Initialize();

    // 通过preprocessor间接驱动lexer开始解析token
    ConsumeToken();
    {
        PP.Lex(Tok);
    }
}

/// Parse the first top-level declaration in a translation unit.
///
///       translation-unit:
///     [C]     external-declaration
///     [C]     translation-unit external-declaration
bool Parser::ParseFirstTopLevelDecl(DeclGroupPtrTy &Result, ...) {
    Actions.ActOnStartOfTranslationUnit();
    return ParseTopLevelDecl(Result, ...);
}

/// ParseTopLevelDecl - Parse one top-level declaration
/// top-level-declaration:
///   declaration
bool Parser::ParseTopLevelDecl(DeclGroupPtrTy &Result, ...) {
    Result = nullptr;
    // 第一个token在Initialize()获取
    switch (Tok.getKind()) {
    case ...
    case tok::eof:
        Actions.ActOnEndOfTranslationUnit();
        return true;
    case tok::identifier:
        // 旧版的c语言允许函数定义不指定返回值，默认int
        // func(int a) { return a * 2; }
        break;
    }

    // 解析__attribute((weak))等
    ParsedAttributes DeclSpecAttrs(AttrFactory);
    while (MaybeParseGNUAttributes(DeclSpecAttrs))
        ;

    // 解析外部声明
    Result = ParseExternalDeclaration(DeclAttrs, DeclSpecAttrs);
    return false;
}

/// external-declaration: [C99 6.9]
///   function-definition
///   declaration
Parser::DeclGroupPtrTy Parser::ParseExternalDeclaration(...) {
    Decl *SingleDecl = nullptr;
    switch (Tok.getKind()) {
    // 处理各种#pragma指令
    case tok::annot_pragma_xxx:
        HandlePragmaXxx();
        return nullptr;
    case tok::semi:
        // 单个分号生成空的decl
        SingleDecl = Actions.ActOnEmptyDeclaration(...);
        break;
    case tok::kw_asm: 
        // 解析嵌入式汇编
        ExprResult Result(ParseSimpleAsm(...));
        SingleDecl = Actions.ActOnFileScopeAsmDecl(Result.get(), ...);
        break;
    case tok::kw_typedef:
        return ParseDeclaration(...);
    case tok::kw_static:
        // 不确定static后面是函数定义还是声明语句
        goto dont_know;
    case tok::kw_inline:
        goto dont_know;
    case tok::kw_extern:
        goto dont_know;
    default:
    // 不确定是声明语句还是函数定义
    dont_know:
        if (!SingleDecl)
            return ParseDeclarationOrFunctionDefinition(...);  
    }

    return Actions.ConvertDeclToDeclGroup(SingleDecl);
}

/// Parse either a function-definition or a declaration.  
/// We can't tell which we have until we read up to the compound-statement in function-definition.
/// 
///       function-definition: [C99 6.9.1]
///         decl-specs      declarator declaration-list[opt] compound-statement
///
///       declaration: [C99 6.7]
///         declaration-specifiers init-declarator-list[opt] ';'
Parser::DeclGroupPtrTy Parser::ParseDeclarationOrFunctionDefinition(..., ParsingDeclSpec &DS, ...) {
    /// 解析类型以及修饰符，例如以下语句`[]`内的部分
    /// [extent const int] a;
    /// [static const struct X] x;
    /// [struct X {int a}] x;
    /// [inline const int] func();
    /// [inline const int] func() {}
    /// 
    /// ParseDeclarationSpecifiers
    ///       declaration-specifiers: [C99 6.7]
    ///         storage-class-specifier declaration-specifiers[opt]
    ///         type-specifier declaration-specifiers[opt]
    /// [C99]   function-specifier declaration-specifiers[opt]
    /// [C11]   alignment-specifier declaration-specifiers[opt]
    ParseDeclarationSpecifiers(DS, ...);

    return ParseDeclGroup(DS, DeclaratorContext::File, Attrs);
    {
        // 存储解析的declarator
        ParsingDeclarator D(*this, DS, LocalAttrs, Context);
        // 解析标识符和函数形参
        ParseDeclarator(D);

        // 已解析到函数形参
        if (D.isFunctionDeclarator()) {
            if (!(
                Tok.is(tok::equal) ||           // int X()=  -> not a function def
                Tok.is(tok::comma) ||           // int X(),  -> not a function def
                Tok.is(tok::semi)  ||           // int X();  -> not a function def
                Tok.is(tok::kw_asm) ||          // int X() __asm__ -> not a function def
                Tok.is(tok::kw___attribute)     // int X() __attr__ -> not a function def
            )) {
                if (Context == DeclaratorContext::File) {
                    // 下一个token是`{`
                    if (isStartOfFunctionDefinition(D)) {
                        // 解析函数定义
                        Decl *TheDecl = ParseFunctionDefinition(D, ...);
                        return Actions.ConvertDeclToDeclGroup(TheDecl);
                    }

                    Diag(Tok, diag::err_expected_fn_body);
                    SkipUntil(tok::semi);
                    return nullptr;
                } else {
                    // 非最外层不允许定义函数
                    if (Tok.is(tok::l_brace)) {
                        Diag(Tok, diag::err_function_definition_not_allowed);
                        SkipMalformedDecl();
                        return nullptr;
                    }
                }
            }
        }

        ParseAsmAttributesAfterDeclarator(D);

        SmallVector<Decl *, 8> DeclsInGroup;
        // 解析第一个声明: 函数声明或变量声明
        Decl *FirstDecl = ParseDeclarationAfterDeclaratorAndAttributes(D, ...);
        {
            // 由Sema生成Decl
            Decl *ThisDecl = Actions.ActOnDeclarator(getCurScope(), D);

            // 解析初始值
            if (Tok.getKind() == tok::equal) {
                ConsumeToken();
                ExprResult Init = ParseInitializer();
                Actions.AddInitializerToDecl(ThisDecl, Init.get(), /*DirectInit=*/false);
            }

            Actions.FinalizeDeclaration(ThisDecl);
        }
        DeclsInGroup.push_back(FirstDecl);

        // 遇到逗号解析更多的声明: int a = 1, b = 2;
        while (TryConsumeToken(tok::comma, ...)) {
            ParseDeclarator(D);
            Decl *ThisDecl = ParseDeclarationAfterDeclarator(D);
            {
                ParseAsmAttributesAfterDeclarator(D);
                return ParseDeclarationAfterDeclaratorAndAttributes(D, ...);
            }
            DeclsInGroup.push_back(ThisDecl);
        }

        // 应该分号结尾
        ExpectAndConsumeSemi(...);

        // 由Sema处理
        return Actions.FinalizeDeclaratorGroup(getCurScope(), DS, DeclsInGroup);
    }
}

/// ParseDeclarator - Parse and verify a newly-initialized declarator.
void Parser::ParseDeclarator(Declarator &D) {
    /// ParseDeclaratorInternal - Parse a C or C++ declarator.
    ///       declarator: [C99 6.7.5] [C++ 8p4, dcl.decl]
    /// [C]     pointer[opt] direct-declarator
    ///
    ///       pointer: [C99 6.7.5]
    ///         '*' type-qualifier-list[opt]
    ///         '*' type-qualifier-list[opt] pointer
    ParseDeclaratorInternal(D, &Parser::ParseDirectDeclarator);
    {
        tok::TokenKind Kind = Tok.getKind();
        // 非指针
        if (Kind != tok::star) {
            /// 解析标识符以及函数形参
            /// int a;
            /// int a = 1;
            /// int func(int a);
            /// 
            /// ParseDirectDeclarator
            ///       direct-declarator: [C99 6.7.5]
            /// [C99]   identifier
            ///         '(' declarator ')'
            /// [GNU]   '(' attributes declarator ')'
            /// [C90]   direct-declarator '[' constant-expression[opt] ']'
            /// [C99]   direct-declarator '[' type-qual-list[opt] assign-expr[opt] ']'
            /// [C99]   direct-declarator '[' 'static' type-qual-list[opt] assign-expr ']'
            /// [C99]   direct-declarator '[' type-qual-list 'static' assign-expr ']'
            /// [C99]   direct-declarator '[' type-qual-list[opt] '*' ']'
            ///         direct-declarator '(' parameter-type-list ')'
            ///         direct-declarator '(' identifier-list[opt] ')'
            (this->*DirectDeclParser)(D);
            {
                // 解析标识符
                if (Tok.is(tok::identifier) && D.mayHaveIdentifier()) {
                    D.SetIdentifier(Tok.getIdentifierInfo(), Tok.getLocation());
                    ConsumeToken();
                    goto PastIdentifier;
                }

            PastIdentifier:
                if (Tok.is(tok::l_paren)) {
                    // 检查小括号是否配对
                    BalancedDelimiterTracker T(*this, tok::l_paren);
                    T.consumeOpen();

                    // 解析形参
                    Actions.ActOnStartFunctionDeclarationDeclarator(D, ...);
                    ParseFunctionDeclarator(D, attrs, T, IsAmbiguous);
                    {
                        // 解析形参
                        // Build up an array of information about the parsed arguments.
                        SmallVector<DeclaratorChunk::ParamInfo, 16> ParamInfo;
                        if (Tok.isNot(tok::r_paren)) {
                            ///    parameter-type-list: [C99 6.7.5]
                            ///      parameter-list
                            ///      parameter-list ',' '...'
                            ///    parameter-list: [C99 6.7.5]
                            ///      parameter-declaration
                            ///      parameter-list ',' parameter-declaration
                            ///    parameter-declaration: [C99 6.7.5]
                            ///      declaration-specifiers declarator
                            ParseParameterDeclarationClause(D, ParamInfo, ...);
                        }
                            
                        // If we have the closing ')', eat it.
                        Tracker.consumeClose();

                        D.AddTypeInfo(DeclaratorChunk::getFunction(...));
                    }
                    Actions.ActOnFinishFunctionDeclarationDeclarator(D);
                } 
            }
            return;
        }

        ConsumeToken();  // Eat the *

        // 解析指针类型
        DeclSpec DS(AttrFactory);

        /// 解析指针之后的修饰符， 例如: `int * [const] a;`中的const
        /// ParseTypeQualifierListOpt
        ///          type-qualifier-list: [C99 6.7.5]
        ///            type-qualifier
        ParseTypeQualifierListOpt(DS, ...);

        // 递归处理剩余部分
        ParseDeclaratorInternal(D, DirectDeclParser);

        // Remember that we parsed a pointer type, and remember the type-quals.
        D.AddTypeInfo(DeclaratorChunk::getPointer(DS.getTypeQualifiers(), ...), ...);
    }
}

/// 解析函数体的组合语句
///       function-definition: [C99 6.9.1]
///         decl-specs      declarator declaration-list[opt] compound-statement
/// [C90] function-definition: [C99 6.7.1] - implicit int result
/// [C90]   decl-specs[opt] declarator declaration-list[opt] compound-statement
Decl *Parser::ParseFunctionDefinition(ParsingDeclarator &D, ...) {
    // If we didn't find the '{', bail out.
    if (Tok.isNot(tok::l_brace))
        return nullptr;

    ParseScope BodyScope(this, ...);

    // 由Sema生成函数定义
    Decl *Res = Actions.ActOnStartOfFunctionDef(getCurScope(), D, ...);
    return ParseFunctionStatementBody(Res, BodyScope);
    {
        StmtResult FnBody(ParseCompoundStatementBody());
        {
            BalancedDelimiterTracker T(*this, tok::l_brace);
            T.consumeOpen();

            // Parse any pragmas at the beginning of the compound statement.
            ParseCompoundStatementLeadingPragmas();
            Actions.ActOnAfterCompoundStatementLeadingPragmas();

            StmtVector Stmts;
            while (Tok.isNot(tok::r_brace) && Tok.isNot(tok::eof)) {
                StmtResult R = ParseStatementOrDeclaration(Stmts, SubStmtCtx);
                Stmts.push_back(R.get());
            }

            T.consumeClose()
            return Actions.ActOnCompoundStmt(Stmts, ...);
        }

        BodyScope.Exit();
        return Actions.ActOnFinishFunctionBody(Decl, FnBody.get());
    }
}

/// ParseStatementOrDeclaration - Read 'statement' or 'declaration'.
///       StatementOrDeclaration:
///         statement
///         declaration
///
///       statement:
///         labeled-statement
///         compound-statement
///         expression-statement
///         selection-statement
///         iteration-statement
///         jump-statement
/// [GNU]   asm-statement
///
///       labeled-statement:
///         identifier ':' statement
///         'case' constant-expression ':' statement
///         'default' ':' statement
///
///       selection-statement:
///         if-statement
///         switch-statement
///
///       iteration-statement:
///         while-statement
///         do-statement
///         for-statement
///
///       expression-statement:
///         expression[opt] ';'
///
///       jump-statement:
///         'goto' identifier ';'
///         'continue' ';'
///         'break' ';'
///         'return' expression[opt] ';'
/// [GNU]   'goto' '*' expression ';'
///
StmtResult Parser::ParseStatementOrDeclaration(StmtVector &Stmts, ...) {
    StmtResult Res = ParseStatementOrDeclarationAfterAttributes(Stmts, ...);
    return Actions.ActOnAttributedStmt(Attrs, Res.get());
}

StmtResult Parser::ParseStatementOrDeclarationAfterAttributes(StmtVector &Stmts, ...) {
    tok::TokenKind Kind  = Tok.getKind();
    switch (Kind) {
    case tok::identifier:
    ParseIdentifier: {
        Token Next = NextToken();
        if (Next.is(tok::colon)) {
            // 解析label: identifier ':' statement
            return ParseLabeledStatement(Attrs, StmtCtx);
        }

        // 非label那就是表达式语句
        // func(2);
        // a + b;
        [[fallthrough]];
    }
    default: 
        // 如果token是类型修饰符则是声明语句
        if (isDeclarationStatement()) {
            DeclGroupPtrTy Decl = ParseDeclaration(DeclaratorContext::Block, ...);
            {
                ///       simple-declaration: [C99 6.7: declaration] 
                ///         declaration-specifiers init-declarator-list[opt] ';'
                return ParseSimpleDeclaration(Context, ...);
                {
                    ParsingDeclSpec DS(*this);
                    ParseDeclarationSpecifiers(DS, ...);

                    // C99 6.7.2.3p6: Handle "struct-or-union identifier;", "enum { X };"
                    if (Tok.is(tok::semi)) {
                        // 记录定义的匿名的struct/union/enum
                        RecordDecl *AnonRecord = nullptr;
                        Decl *TheDecl = Actions.ParsedFreeStandingDeclSpec(..., AnonRecord);
                        
                        Actions.ActOnDefinedDeclarationSpecifier(TheDecl, ...);
                        
                        // struct { int a } x;
                        if (AnonRecord) {
                            Decl* decls[] = {AnonRecord, TheDecl};
                            return Actions.BuildDeclaratorGroup(decls);
                        }

                        // struct X x;
                        return Actions.ConvertDeclToDeclGroup(TheDecl);
                    }
                }
            }

            return Actions.ActOnDeclStmt(Decl, DeclStart, DeclEnd);
        }

        // eg: func(2);
        return ParseExprStatement(StmtCtx);
    case tok::kw_case:                // C99 6.8.1: labeled-statement
        return ParseCaseStatement(StmtCtx);
    case tok::kw_default:             // C99 6.8.1: labeled-statement
        return ParseDefaultStatement(StmtCtx);
    case tok::l_brace:                // C99 6.8.2: compound-statement
        return ParseCompoundStatement();
    case tok::semi:                   // C99 6.8.3p3: expression[opt] ';'
        return Actions.ActOnNullStmt(ConsumeToken(), ...); 
    case tok::kw_if:                  // C99 6.8.4.1: if-statement
    return ParseIfStatement(TrailingElseLoc);
    case tok::kw_switch:              // C99 6.8.4.2: switch-statement
        return ParseSwitchStatement(TrailingElseLoc);
    case tok::kw_while:               // C99 6.8.5.1: while-statement
        return ParseWhileStatement(TrailingElseLoc);
    case tok::kw_do:                  // C99 6.8.5.2: do-statement
        Res = ParseDoStatement();
        break;
    case tok::kw_for:                 // C99 6.8.5.3: for-statement
        return ParseForStatement(TrailingElseLoc);
    case tok::kw_goto:                // C99 6.8.6.1: goto-statement
        Res = ParseGotoStatement();
        break;
    case tok::kw_continue:            // C99 6.8.6.2: continue-statement
        Res = ParseContinueStatement();
        break;
    case tok::kw_break:               // C99 6.8.6.3: break-statement
        Res = ParseBreakStatement();
        break;
    case tok::kw_return:              // C99 6.8.6.4: return-statement
        Res = ParseReturnStatement();
        break;   
    case tok::kw_asm:                 // 嵌入式汇编
        Res = ParseAsmStatement(...);
        break;
    }

    ExpectAndConsume(tok::semi, ...);
    return Res;
}

// 以if为例分析语句解析过程
/// ParseIfStatement
///       if-statement: [C99 6.8.4.1]
///         'if' '(' expression ')' statement
///         'if' '(' expression ')' statement 'else' statement
StmtResult Parser::ParseIfStatement(...) {
    if (Tok.isNot(tok::l_paren)) {
        return StmtError();
    }

    ParseScope IfScope(this, ...);

    // Parse the condition.
    Sema::ConditionResult Cond;
    ParseParenExprOrCondition(..., Cond, ...);
    {
        BalancedDelimiterTracker T(*this, tok::l_paren);
        T.consumeOpen();

        ExprResult CondExpr = ParseExpression();
        Cond = Actions.ActOnCondition(...);

        T.consumeClose();
    }

    // 进入新的作用域解析then
    ParseScope InnerScope(this, ...);
    StmtResult ThenStmt = ParseStatement(...);
    InnerScope.Exit();

    StmtResult ElseStmt;
    if (Tok.is(tok::kw_else)) {
        ConsumeToken();

        ParseScope InnerScope(this, ...);
        ElseStmt = ParseStatement();
        InnerScope.Exit();
    }

    IfScope.Exit();

    return Actions.ActOnIfStmt(...);
}

/// 表达式按优先级从高到低排序
///       multiplicative-expression: [C99 6.5.5]
///     Note: in C++, apply pm-expression instead of cast-expression
///         cast-expression
///         multiplicative-expression '*' cast-expression
///         multiplicative-expression '/' cast-expression
///         multiplicative-expression '%' cast-expression
///
///       additive-expression: [C99 6.5.6]
///         multiplicative-expression
///         additive-expression '+' multiplicative-expression
///         additive-expression '-' multiplicative-expression
///
///       shift-expression: [C99 6.5.7]
///         additive-expression
///         shift-expression '<<' additive-expression
///         shift-expression '>>' additive-expression
///
///       compare-expression: [C++20 expr.spaceship]
///         shift-expression
///         compare-expression '<=>' shift-expression
///
///       relational-expression: [C99 6.5.8]
///         compare-expression
///         relational-expression '<' compare-expression
///         relational-expression '>' compare-expression
///         relational-expression '<=' compare-expression
///         relational-expression '>=' compare-expression
///
///       equality-expression: [C99 6.5.9]
///         relational-expression
///         equality-expression '==' relational-expression
///         equality-expression '!=' relational-expression
///
///       AND-expression: [C99 6.5.10]
///         equality-expression
///         AND-expression '&' equality-expression
///
///       exclusive-OR-expression: [C99 6.5.11]
///         AND-expression
///         exclusive-OR-expression '^' AND-expression
///
///       inclusive-OR-expression: [C99 6.5.12]
///         exclusive-OR-expression
///         inclusive-OR-expression '|' exclusive-OR-expression
///
///       logical-AND-expression: [C99 6.5.13]
///         inclusive-OR-expression
///         logical-AND-expression '&&' inclusive-OR-expression
///
///       logical-OR-expression: [C99 6.5.14]
///         logical-AND-expression
///         logical-OR-expression '||' logical-AND-expression
///
///       conditional-expression: [C99 6.5.15]
///         logical-OR-expression
///         logical-OR-expression '?' expression ':' conditional-expression
/// [GNU]   logical-OR-expression '?' ':' conditional-expression
///
///       assignment-expression: [C99 6.5.16]
///         conditional-expression
///         unary-expression assignment-operator assignment-expression
///
///       assignment-operator: one of
///         = *= /= %= += -= <<= >>= &= ^= |=
///
///       expression: [C99 6.5.17]
///         assignment-expression ...[opt]
///         expression ',' assignment-expression ...[opt]
ExprResult Parser::ParseExpression(...) {
    ExprResult LHS(ParseAssignmentExpression(isTypeCast));
    return ParseRHSOfBinaryExpression(LHS, prec::Comma);
}

StmtResult Parser::ParseStatement(...) {
    StmtResult Res;

    // We may get back a null statement if we found a #pragma. 
    // Keep going until we get an actual statement.
    StmtVector Stmts;
    do {
        Res = ParseStatementOrDeclaration(Stmts, ...);
    } while (!Res.isInvalid() && !Res.get());

    return Res;
}

```

## 语义分析

```c++

// 定义声明
Decl *Sema::ActOnDeclarator(Scope *S, Declarator &D) {
    Decl *Dcl = HandleDeclarator(S, D, MultiTemplateParamsArg());
    {
        // 查找作用域内是否定义过
        DeclarationNameInfo NameInfo = GetNameForDeclarator(D);
        LookupResult Previous(*this, NameInfo, ...);
        LookupName(Previous, S, ...);

        TypeSourceInfo *TInfo = GetTypeForDeclarator(D);
        DeclContext *DC = CurContext;

        NamedDecl *New;
        if (D.getDeclSpec().getStorageClassSpec() == DeclSpec::SCS_typedef) {
            New = ActOnTypedefDeclarator(S, D, DC, TInfo, Previous);
        } else if (R->isFunctionType()) {
            New = ActOnFunctionDeclarator(S, D, DC, TInfo, Previous, ...);
        } else {
            New = ActOnVariableDeclarator(S, D, DC, TInfo, Previous, ...);
        }

        // 加入作用域的符号表
        PushOnScopeChains(New, S);

        return New;
    }

    return Dcl;
}

// 变量声明
NamedDecl *Sema::ActOnVariableDeclarator(Scope *S, Declarator &D, ...) {
    QualType R = TInfo->getType();
    DeclarationName Name = GetNameForDeclarator(D).getName();
    IdentifierInfo *II = Name.getAsIdentifierInfo();

    DeclSpec::SCS SCSpec = D.getDeclSpec().getStorageClassSpec();
    StorageClass SC = StorageClassSpecToVarDeclStorageClass(D.getDeclSpec());

    VarDecl *NewVD = VarDecl::Create(Context, DC, ..., II, R, TInfo, SC);

    // 检查声明语句是否符合语义

    return NewVD;
}

// 函数声明
NamedDecl* Sema::ActOnFunctionDeclarator(Scope *S, Declarator &D, ...) {
    // Copy the parameter declarations from the declarator D to the function declaration NewFD
    SmallVector<ParmVarDecl*, 16> Params;

    FunctionDecl *NewFD = CreateNewFunctionDecl(*this, D, DC, R, TInfo, SC, ...);
    NewFD->setParams(Params);

    // Handle attributes.
    ProcessDeclAttributes(S, NewFD, D);

    ProcessPragmaWeak(S, NewFD);

    // 各种语义检查

    return NewFD;
}

// 函数定义
Decl * Sema::ActOnStartOfFunctionDef(Scope *FnBodyScope, Declarator &D, ...) {
    Decl *DP = HandleDeclarator(ParentScope, D, TemplateParameterLists);
    Decl *Dcl = ActOnStartOfFunctionDef(FnBodyScope, DP, SkipBody, BodyKind);
    {
        FunctionDecl *FD = cast<FunctionDecl>(D);
        
        // Enter a new function scope
        PushFunctionScope();

        ...

        return D;
    }

    return dcl;
}

```

## demo

示例程序如下:

```c

#include<stdio.h>

int func(int i) 
{
    if (i == 0 || i == 1)
    {
        return 1;
    } 
    else if (i >= 2) {
        return func(i - 1) + func(i - 2);
    }

    return -1;
}

int main(int argc, char** argv) 
{
    int n = argc;
    if (n > 2)
    {
        return -1;
    }

    char* param0 = argv[1];
    if (param0 == 0)
    {
        return -2;
    }

    int s = 0;
    char c;
    int i = 0;
    while ((c = param0[i++]) != '\0')
    {
        if (c < '0' || c > '9')
        {
            return -3;
        }
        
        s *= 10;
        s += c - '0';
    }

    printf("param = %d\n", s);
    
    int total = func(s);

    printf("total = %d\n", total);

    return 0;
}

```

执行指令`clang -emit-ast demo/main.c -o demo/main.ast`产生的`AST`如下

```ast

// 忽略`#include<stdio.h>`的输出

|-FunctionDecl 0x55555571d5c0 <demo/main.c:3:1, line:14:1> line:3:5 used func 'int (int)'
| |-ParmVarDecl 0x55555571d528 <col:10, col:14> col:14 used i 'int'
| `-CompoundStmt 0x55555571e700 <line:4:1, line:14:1>
|   |-IfStmt 0x55555571da90 <line:5:5, line:11:5> has_else
|   | |-BinaryOperator 0x55555571d760 <line:5:9, col:24> 'int' '||'
|   | | |-BinaryOperator 0x55555571d6c8 <col:9, col:14> 'int' '=='
|   | | | |-ImplicitCastExpr 0x55555571d6b0 <col:9> 'int' <LValueToRValue>
|   | | | | `-DeclRefExpr 0x55555571d670 <col:9> 'int' lvalue ParmVar 0x55555571d528 'i' 'int'
|   | | | `-IntegerLiteral 0x55555571d690 <col:14> 'int' 0
|   | | `-BinaryOperator 0x55555571d740 <col:19, col:24> 'int' '=='
|   | |   |-ImplicitCastExpr 0x55555571d728 <col:19> 'int' <LValueToRValue>
|   | |   | `-DeclRefExpr 0x55555571d6e8 <col:19> 'int' lvalue ParmVar 0x55555571d528 'i' 'int'
|   | |   `-IntegerLiteral 0x55555571d708 <col:24> 'int' 1
|   | |-CompoundStmt 0x55555571d7b0 <line:6:5, line:8:5>
|   | | `-ReturnStmt 0x55555571d7a0 <line:7:9, col:16>
|   | |   `-IntegerLiteral 0x55555571d780 <col:16> 'int' 1
|   | `-IfStmt 0x55555571da70 <line:9:10, line:11:5>
|   |   |-BinaryOperator 0x55555571d820 <line:9:14, col:19> 'int' '>='
|   |   | |-ImplicitCastExpr 0x55555571d808 <col:14> 'int' <LValueToRValue>
|   |   | | `-DeclRefExpr 0x55555571d7c8 <col:14> 'int' lvalue ParmVar 0x55555571d528 'i' 'int'
|   |   | `-IntegerLiteral 0x55555571d7e8 <col:19> 'int' 2
|   |   `-CompoundStmt 0x55555571da58 <col:22, line:11:5>
|   |     `-ReturnStmt 0x55555571da48 <line:10:9, col:40>
|   |       `-BinaryOperator 0x55555571da28 <col:16, col:40> 'int' '+'
|   |         |-CallExpr 0x55555571d928 <col:16, col:26> 'int'
|   |         | |-ImplicitCastExpr 0x55555571d910 <col:16> 'int (*)(int)' <FunctionToPointerDecay>
|   |         | | `-DeclRefExpr 0x55555571d840 <col:16> 'int (int)' Function 0x55555571d5c0 'func' 'int (int)'
|   |         | `-BinaryOperator 0x55555571d8b8 <col:21, col:25> 'int' '-'
|   |         |   |-ImplicitCastExpr 0x55555571d8a0 <col:21> 'int' <LValueToRValue>
|   |         |   | `-DeclRefExpr 0x55555571d860 <col:21> 'int' lvalue ParmVar 0x55555571d528 'i' 'int'
|   |         |   `-IntegerLiteral 0x55555571d880 <col:25> 'int' 1
|   |         `-CallExpr 0x55555571da00 <col:30, col:40> 'int'
|   |           |-ImplicitCastExpr 0x55555571d9e8 <col:30> 'int (*)(int)' <FunctionToPointerDecay>
|   |           | `-DeclRefExpr 0x55555571d950 <col:30> 'int (int)' Function 0x55555571d5c0 'func' 'int (int)'
|   |           `-BinaryOperator 0x55555571d9c8 <col:35, col:39> 'int' '-'
|   |             |-ImplicitCastExpr 0x55555571d9b0 <col:35> 'int' <LValueToRValue>
|   |             | `-DeclRefExpr 0x55555571d970 <col:35> 'int' lvalue ParmVar 0x55555571d528 'i' 'int'
|   |             `-IntegerLiteral 0x55555571d990 <col:39> 'int' 2
|   `-ReturnStmt 0x55555571daf8 <line:13:5, col:13>
|     `-UnaryOperator 0x55555571dae0 <col:12, col:13> 'int' prefix '-'
|       `-IntegerLiteral 0x55555571dac0 <col:13> 'int' 1
`-FunctionDecl 0x55555571e898 <line:16:1, line:51:1> line:16:5 main 'int (int, char **)'
  |-ParmVarDecl 0x55555571e738 <col:10, col:14> col:14 used argc 'int'
  |-ParmVarDecl 0x55555571e7b8 <col:20, col:27> col:27 used argv 'char **'
  `-CompoundStmt 0x55555571f808 <line:17:1, line:51:1>
    |-DeclStmt 0x55555571ea08 <line:18:5, col:17>
    | `-VarDecl 0x55555571e968 <col:5, col:13> col:9 used n 'int' cinit
    |   `-ImplicitCastExpr 0x55555571e9f0 <col:13> 'int' <LValueToRValue>
    |     `-DeclRefExpr 0x55555571e9d0 <col:13> 'int' lvalue ParmVar 0x55555571e738 'argc' 'int'
    |-IfStmt 0x55555571eaf8 <line:19:5, line:22:5>
    | |-BinaryOperator 0x55555571ea78 <line:19:9, col:13> 'int' '>'
    | | |-ImplicitCastExpr 0x55555571ea60 <col:9> 'int' <LValueToRValue>
    | | | `-DeclRefExpr 0x55555571ea20 <col:9> 'int' lvalue Var 0x55555571e968 'n' 'int'
    | | `-IntegerLiteral 0x55555571ea40 <col:13> 'int' 2
    | `-CompoundStmt 0x55555571eae0 <line:20:5, line:22:5>
    |   `-ReturnStmt 0x55555571ead0 <line:21:9, col:17>
    |     `-UnaryOperator 0x55555571eab8 <col:16, col:17> 'int' prefix '-'
    |       `-IntegerLiteral 0x55555571ea98 <col:17> 'int' 1
    |-DeclStmt 0x55555571ec28 <line:24:5, col:27>
    | `-VarDecl 0x55555571eb30 <col:5, col:26> col:11 used param0 'char *' cinit
    |   `-ImplicitCastExpr 0x55555571ec10 <col:20, col:26> 'char *' <LValueToRValue>
    |     `-ArraySubscriptExpr 0x55555571ebf0 <col:20, col:26> 'char *' lvalue
    |       |-ImplicitCastExpr 0x55555571ebd8 <col:20> 'char **' <LValueToRValue>
    |       | `-DeclRefExpr 0x55555571eb98 <col:20> 'char **' lvalue ParmVar 0x55555571e7b8 'argv' 'char **'
    |       `-IntegerLiteral 0x55555571ebb8 <col:25> 'int' 1
    |-IfStmt 0x55555571ed30 <line:25:5, line:28:5>
    | |-BinaryOperator 0x55555571ecb0 <line:25:9, col:19> 'int' '=='
    | | |-ImplicitCastExpr 0x55555571ec80 <col:9> 'char *' <LValueToRValue>
    | | | `-DeclRefExpr 0x55555571ec40 <col:9> 'char *' lvalue Var 0x55555571eb30 'param0' 'char *'
    | | `-ImplicitCastExpr 0x55555571ec98 <col:19> 'char *' <NullToPointer>
    | |   `-IntegerLiteral 0x55555571ec60 <col:19> 'int' 0
    | `-CompoundStmt 0x55555571ed18 <line:26:5, line:28:5>
    |   `-ReturnStmt 0x55555571ed08 <line:27:9, col:17>
    |     `-UnaryOperator 0x55555571ecf0 <col:16, col:17> 'int' prefix '-'
    |       `-IntegerLiteral 0x55555571ecd0 <col:17> 'int' 2
    |-DeclStmt 0x55555571edf0 <line:30:5, col:14>
    | `-VarDecl 0x55555571ed68 <col:5, col:13> col:9 used s 'int' cinit
    |   `-IntegerLiteral 0x55555571edd0 <col:13> 'int' 0
    |-DeclStmt 0x55555571ee80 <line:31:5, col:11>
    | `-VarDecl 0x55555571ee18 <col:5, col:10> col:10 used c 'char'
    |-DeclStmt 0x55555571ef38 <line:32:5, col:14>
    | `-VarDecl 0x55555571eeb0 <col:5, col:13> col:9 used i 'int' cinit
    |   `-IntegerLiteral 0x55555571ef18 <col:13> 'int' 0
    |-WhileStmt 0x55555571f3c8 <line:33:5, line:42:5>
    | |-BinaryOperator 0x55555571f088 <line:33:12, col:33> 'int' '!='
    | | |-ImplicitCastExpr 0x55555571f070 <col:12, col:28> 'int' <IntegralCast>
    | | | `-ParenExpr 0x55555571f038 <col:12, col:28> 'char'
    | | |   `-BinaryOperator 0x55555571f018 <col:13, col:27> 'char' '='
    | | |     |-DeclRefExpr 0x55555571ef50 <col:13> 'char' lvalue Var 0x55555571ee18 'c' 'char'
    | | |     `-ImplicitCastExpr 0x55555571f000 <col:17, col:27> 'char' <LValueToRValue>
    | | |       `-ArraySubscriptExpr 0x55555571efe0 <col:17, col:27> 'char' lvalue
    | | |         |-ImplicitCastExpr 0x55555571efc8 <col:17> 'char *' <LValueToRValue>
    | | |         | `-DeclRefExpr 0x55555571ef70 <col:17> 'char *' lvalue Var 0x55555571eb30 'param0' 'char *'
    | | |         `-UnaryOperator 0x55555571efb0 <col:24, col:25> 'int' postfix '++'
    | | |           `-DeclRefExpr 0x55555571ef90 <col:24> 'int' lvalue Var 0x55555571eeb0 'i' 'int'
    | | `-CharacterLiteral 0x55555571f058 <col:33> 'int' 0
    | `-CompoundStmt 0x55555571f3a0 <line:34:5, line:42:5>
    |   |-IfStmt 0x55555571f238 <line:35:9, line:38:9>
    |   | |-BinaryOperator 0x55555571f1b8 <line:35:13, col:28> 'int' '||'
    |   | | |-BinaryOperator 0x55555571f110 <col:13, col:17> 'int' '<'
    |   | | | |-ImplicitCastExpr 0x55555571f0f8 <col:13> 'int' <IntegralCast>
    |   | | | | `-ImplicitCastExpr 0x55555571f0e0 <col:13> 'char' <LValueToRValue>
    |   | | | |   `-DeclRefExpr 0x55555571f0a8 <col:13> 'char' lvalue Var 0x55555571ee18 'c' 'char'
    |   | | | `-CharacterLiteral 0x55555571f0c8 <col:17> 'int' 48
    |   | | `-BinaryOperator 0x55555571f198 <col:24, col:28> 'int' '>'
    |   | |   |-ImplicitCastExpr 0x55555571f180 <col:24> 'int' <IntegralCast>
    |   | |   | `-ImplicitCastExpr 0x55555571f168 <col:24> 'char' <LValueToRValue>
    |   | |   |   `-DeclRefExpr 0x55555571f130 <col:24> 'char' lvalue Var 0x55555571ee18 'c' 'char'
    |   | |   `-CharacterLiteral 0x55555571f150 <col:28> 'int' 57
    |   | `-CompoundStmt 0x55555571f220 <line:36:9, line:38:9>
    |   |   `-ReturnStmt 0x55555571f210 <line:37:13, col:21>
    |   |     `-UnaryOperator 0x55555571f1f8 <col:20, col:21> 'int' prefix '-'
    |   |       `-IntegerLiteral 0x55555571f1d8 <col:21> 'int' 3
    |   |-CompoundAssignOperator 0x55555571f298 <line:40:9, col:14> 'int' '*=' ComputeLHSTy='int' ComputeResultTy='int'
    |   | |-DeclRefExpr 0x55555571f258 <col:9> 'int' lvalue Var 0x55555571ed68 's' 'int'
    |   | `-IntegerLiteral 0x55555571f278 <col:14> 'int' 10
    |   `-CompoundAssignOperator 0x55555571f370 <line:41:9, col:18> 'int' '+=' ComputeLHSTy='int' ComputeResultTy='int'
    |     |-DeclRefExpr 0x55555571f2c8 <col:9> 'int' lvalue Var 0x55555571ed68 's' 'int'
    |     `-BinaryOperator 0x55555571f350 <col:14, col:18> 'int' '-'
    |       |-ImplicitCastExpr 0x55555571f338 <col:14> 'int' <IntegralCast>
    |       | `-ImplicitCastExpr 0x55555571f320 <col:14> 'char' <LValueToRValue>
    |       |   `-DeclRefExpr 0x55555571f2e8 <col:14> 'char' lvalue Var 0x55555571ee18 'c' 'char'
    |       `-CharacterLiteral 0x55555571f308 <col:18> 'int' 48
    |-CallExpr 0x55555571f4f8 <line:44:5, col:29> 'int'
    | |-ImplicitCastExpr 0x55555571f4e0 <col:5> 'int (*)(const char *, ...)' <FunctionToPointerDecay>
    | | `-DeclRefExpr 0x55555571f3e8 <col:5> 'int (const char *, ...)' Function 0x555555707118 'printf' 'int (const char *, ...)'
    | |-ImplicitCastExpr 0x55555571f540 <col:12> 'const char *' <NoOp>
    | | `-ImplicitCastExpr 0x55555571f528 <col:12> 'char *' <ArrayToPointerDecay>
    | |   `-StringLiteral 0x55555571f450 <col:12> 'char[12]' lvalue "param = %d\n"
    | `-ImplicitCastExpr 0x55555571f558 <col:28> 'int' <LValueToRValue>
    |   `-DeclRefExpr 0x55555571f478 <col:28> 'int' lvalue Var 0x55555571ed68 's' 'int'
    |-DeclStmt 0x55555571f688 <line:46:5, col:24>
    | `-VarDecl 0x55555571f588 <col:5, col:23> col:9 used total 'int' cinit
    |   `-CallExpr 0x55555571f648 <col:17, col:23> 'int'
    |     |-ImplicitCastExpr 0x55555571f630 <col:17> 'int (*)(int)' <FunctionToPointerDecay>
    |     | `-DeclRefExpr 0x55555571f5f0 <col:17> 'int (int)' Function 0x55555571d5c0 'func' 'int (int)'
    |     `-ImplicitCastExpr 0x55555571f670 <col:22> 'int' <LValueToRValue>
    |       `-DeclRefExpr 0x55555571f610 <col:22> 'int' lvalue Var 0x55555571ed68 's' 'int'
    |-CallExpr 0x55555571f760 <line:48:5, col:33> 'int'
    | |-ImplicitCastExpr 0x55555571f748 <col:5> 'int (*)(const char *, ...)' <FunctionToPointerDecay>
    | | `-DeclRefExpr 0x55555571f6a0 <col:5> 'int (const char *, ...)' Function 0x555555707118 'printf' 'int (const char *, ...)'
    | |-ImplicitCastExpr 0x55555571f7a8 <col:12> 'const char *' <NoOp>
    | | `-ImplicitCastExpr 0x55555571f790 <col:12> 'char *' <ArrayToPointerDecay>
    | |   `-StringLiteral 0x55555571f6c0 <col:12> 'char[12]' lvalue "total = %d\n"
    | `-ImplicitCastExpr 0x55555571f7c0 <col:28> 'int' <LValueToRValue>
    |   `-DeclRefExpr 0x55555571f710 <col:28> 'int' lvalue Var 0x55555571f588 'total' 'int'
    `-ReturnStmt 0x55555571f7f8 <line:50:5, col:12>
      `-IntegerLiteral 0x55555571f7d8 <col:12> 'int' 0

```

