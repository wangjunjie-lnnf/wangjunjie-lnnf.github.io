---
layout: post
title:  "ast"
date:   2024-05-24 21:49:07 +0000
categories: llvm
tags: llvm
---

# ast

书接上文，继续分析从`c11`源码转换为`AST`的过程，主流程如下：

```c++

/// Abstract base class to use for AST consumer-based frontend actions.
class ASTFrontendAction : public FrontendAction {
protected:
    /// Implement the ExecuteAction interface by running Sema 
    /// on the already-initialized AST consumer.
    void ExecuteAction() override;
    {
        /// Sema - implements semantic analysis and AST building for C.
        CI.createSema(getTranslationUnitKind(), ...);
        {
            TheSema.reset(new Sema(getPreprocessor(), getASTContext(), getASTConsumer(), ...));
        }
        // 预处理、词法分析、语法分析、AST生成
        ParseAST(CI.getSema(), ...);
    }
}

// 主流程
void clang::ParseAST(Sema &S, ...) {
    // ASTConsumer - 对生成的AST进一步处理
    ASTConsumer *Consumer = &S.getASTConsumer();

    // Preprocessor - 预处理源文件
    Preprocessor PP = S.getPreprocessor();

    // Parser - 解析源文件生成AST
    std::unique_ptr<Parser> ParseOP(new Parser(PP, S, ...));
    Parser &P = *ParseOP.get();

    // 开始处理源文件
    S.getPreprocessor().EnterMainSourceFile();

    // 获取第一个token
    P.Initialize();

    // 根据c11的语法规则，源文件是由一组声明语句组成的
    //
    // translation-unit:
    //     external-declaration
    //     translation-unit external-declaration
    //
    // external-declaration:
    //     function-definition
    //     declaration
    //
    // 每次声明可能包含多个变量，例如：`int a,b;`，所以类型是`DeclGroup`
    Parser::DeclGroupPtrTy ADecl;
    for (bool AtEOF = P.ParseFirstTopLevelDecl(ADecl, ImportState); 
         !AtEOF;
         AtEOF = P.ParseTopLevelDecl(ADecl, ImportState)) {
        // Consumer来决定如何使用解析的结果
        Consumer->HandleTopLevelDecl(ADecl.get());
    }

    Consumer->HandleTranslationUnit(S.getASTContext());
}

```

## 核心类

搞明白整个流程的关键是梳理几个核心类的关联关系及各自的职责

```c++

/// Parser - This implements a parser for the C family of languages.
/// Parser驱动别的类完成AST构造过程
class Parser : public CodeCompletionHandler {
private:
    // 预处理器
    Preprocessor &PP;

    /// 当前有效的token
    /// Tok - The current token we are peeking ahead.  
    /// All parsing methods assume that this is valid.
    Token Tok;

    /// Actions - These are the callbacks we invoke as we parse various constructs in the file.
    Sema &Actions;

public:
    Preprocessor &getPreprocessor() const { return PP; }
    Sema &getActions() const { return Actions; }
    const Token &getCurToken() const { return Tok; }

    /// Initialize - Warm up the parser.
    void Initialize();

    /// Parse the first top-level declaration in a translation unit.
    bool ParseFirstTopLevelDecl(DeclGroupPtrTy &Result, ...);

    /// ParseTopLevelDecl - Parse one top-level declaration.
    bool ParseTopLevelDecl(DeclGroupPtrTy &Result, ...);

    ExprResult ParseExpression(...);
    ExprResult ParseCaseExpression(...);
    ExprResult ParseAssignmentExpression(...);
    ExprResult ParseUnaryExprOrTypeTraitExpression();
    ExprResult ParseRHSOfBinaryExpression(ExprResult LHS, ...);
    ExprResult ParseParenExpression(...);

    StmtResult ParseStatement(...);
    StmtResult ParseExprStatement(...);
    StmtResult ParseLabeledStatement(...);
    StmtResult ParseCaseStatement(...);
    StmtResult ParseDefaultStatement(...);
    StmtResult ParseCompoundStatement(...);
    StmtResult ParseIfStatement(...);
    StmtResult ParseSwitchStatement(...);
    StmtResult ParseWhileStatement(...);
    StmtResult ParseDoStatement();
    StmtResult ParseForStatement(...);
    StmtResult ParseGotoStatement();
    StmtResult ParseContinueStatement();
    StmtResult ParseBreakStatement();
    StmtResult ParseReturnStatement();
    StmtResult ParseAsmStatement(...);
}

/// 管理lexer栈产生token，处理各种宏指令
class Preprocessor {
    // 语言的各种特性开关
    const LangOptions &LangOpts;

    // cpu/os等平台信息
    const TargetInfo *Target = nullptr;
    const TargetInfo *AuxTarget = nullptr;

    // 源文件管理
    FileManager       &FileMgr;
    SourceManager     &SourceMgr;
    HeaderSearch      &HeaderInfo;

    /// 核心对象CurLexer和CurTokenLexer分别表示解析源文件和宏扩展

    /// The current top of the stack that we're lexing from if
    /// not expanding a macro and we are lexing directly from source code.
    /// Only one of CurLexer, or CurTokenLexer will be non-null.
    std::unique_ptr<Lexer> CurLexer;

    /// The current macro we are expanding, if we are expanding a macro.
    /// One of CurLexer and CurTokenLexer must be null.
    std::unique_ptr<TokenLexer> CurTokenLexer;

    // 通过callback选择CurLexer或CurTokenLexer
    /// The kind of lexer we're currently working with.
    typedef bool (*LexerCallback)(Preprocessor &, Token &);
    LexerCallback CurLexerCallback = &CLK_Lexer;

    /// 此结构用于处理`#include`，类似函数调用产生的栈帧
    /// Keeps track of the stack of files currently `#included`,
    /// and macros currently being expanded from, not counting CurLexer/CurTokenLexer.
    struct IncludeStackInfo {
        LexerCallback               CurLexerCallback;
        std::unique_ptr<Lexer>      TheLexer;
        PreprocessorLexer          *ThePPLexer;
        std::unique_ptr<TokenLexer> TheTokenLexer;
    }
    std::vector<IncludeStackInfo> IncludeMacroStack;

    /// map结构的宏定义符号表，记录每个标识符定义的macro的历史
    /// For each IdentifierInfo that was associated with a macro, we
    /// keep a mapping to the history of all macro definitions and #undefs in
    /// the reverse order (the latest one is in the head of the list).
    ///
    /// This mapping lives within the `CurSubmoduleState`.
    using MacroMap = llvm::DenseMap<const IdentifierInfo *, MacroState>;

    /// Information about a submodule's preprocessor state.
    struct SubmoduleState {
        /// The macros for the submodule.
        MacroMap Macros;
    };
    SubmoduleState *CurSubmoduleState;

    /// 包含系统内置的变量以及命令行通过-Dkey=val指定的变量
    /// The predefined macros that preprocessor should use from the command line etc.
    std::string Predefines;

public:
    /// Enter the specified FileID as the main source file,
    /// which implicitly adds the builtin defines etc.
    void EnterMainSourceFile();
    {
        // 加载当前文件到内存
        EnterSourceFile(MainFileID, ...);

        // 加载系统预定义的变量
        std::unique_ptr<llvm::MemoryBuffer> SB = llvm::MemoryBuffer::getMemBufferCopy(Predefines, "<built-in>");
        FileID FID = SourceMgr.createFileID(std::move(SB));
        // 此处的效果就是源文件的开头处定义了这些系统变量！！！
        EnterSourceFile(FID, ...);
    }

    /// Add a source file to the top of the include stack and
    /// start lexing tokens from it instead of the current buffer.
    bool EnterSourceFile(FileID FID, ...);
    {
            // 构造词法解析器
            Lexer *TheLexer = new Lexer(FID, *InputFile, *this, ...);
            EnterSourceFileWithLexer(TheLexer, CurDir);
            {
                // 每个源文件都有配套的多个lexer以及关联信息，这些信息的组织结构类似函数的栈帧
                // a调用b，b调用c，会给a/b/c都创建栈帧结构存储各自的信息
                // 同样，a通过`#include`包含b，b通过`#include`包含c，a/b/c各自都会有自己的lexer，然后以类似栈帧的结构组织
                if (CurPPLexer || CurTokenLexer)
                    // 保存lexer
                    PushIncludeMacroStack();
                    {
                        IncludeMacroStack.emplace_back(..., std::move(CurLexer), CurPPLexer, std::move(CurTokenLexer), CurDirLookup);
                    }
                CurLexer.reset(TheLexer);
                CurPPLexer = TheLexer;
                CurDirLookup = CurDir;
                // callback指向Lexer
                CurLexerCallback = CLK_Lexer;
            }
        }

    /// Add a Macro to the top of the include stack and start lexing
    /// tokens from it instead of the current buffer.
    void EnterMacro(Token &Tok, ..., MacroInfo *Macro, MacroArgs *Args);
    {
        std::unique_ptr<TokenLexer> TokLexer = std::make_unique<TokenLexer>(Tok, ILEnd, Macro, Args, *this);
        
        // 保存当前的lexer
        PushIncludeMacroStack();
        CurDirLookup = nullptr;
        // 替换为macro扩展lexer
        CurTokenLexer = std::move(TokLexer);
        // callback指向TokenLexer
        CurLexerCallback = CLK_TokenLexer;
    }

    /// Callback invoked when the lexer hits the end of the current file.
    bool HandleEndOfFile(Token &Result, bool isEndOfMacro = false);
    {
        if (!IncludeMacroStack.empty()) {
            // 还原lexer
            RemoveTopOfLexerStack();
            {
                PopIncludeMacroStack();
                {
                    CurLexer = std::move(IncludeMacroStack.back().TheLexer);
                    CurPPLexer = IncludeMacroStack.back().ThePPLexer;
                    CurTokenLexer = std::move(IncludeMacroStack.back().TheTokenLexer);
                    CurLexerCallback = IncludeMacroStack.back().CurLexerCallback;
                    IncludeMacroStack.pop_back();
                }
            }
        }
    }

    /// Lex the next token for this preprocessor.
    void Lex(Token &Result);
    {
        CurLexerCallback(*this, Result);
        {
            CurLexer->Lex(Result);
        }
    }
}

/// Lexer - This provides a simple interface that turns a text buffer into a stream of tokens.
/// Lexers know only about tokens within a single source file, and don't
/// know anything about preprocessor-level issues like the \#include stack, etc.
/// lexer只能看到某一个源文件，看不到全局
class Lexer : public PreprocessorLexer {
    // Start of the buffer.
    const char *BufferStart;
    // End of the buffer.
    const char *BufferEnd;
    // BufferPtr - Current pointer into the buffer. This is the next character to be lexed.
    const char *BufferPtr;

    void InitLexer(const char *BufStart, const char *BufPtr, const char *BufEnd);

    /// Lex - Return the next token in the file.
    /// If this is the end of file, it return the tok::eof token.
    bool Lex(Token &Result);
}

/// TokenLexer - This implements a lexer that returns tokens from a macro body
/// or token stream instead of lexing from a character buffer.  This is used for
/// macro expansion and _Pragma handling, for example.
class TokenLexer {

    /// The macro we are expanding from. This is null if expanding a token stream.
    MacroInfo *Macro = nullptr;

    /// The actual arguments specified for a function-like macro, or null.
    MacroArgs *ActualArgs = nullptr;

    /// This is the pointer to an array of tokens that the macro is defined to,
    /// with arguments expanded for function-like macros. 
    /// If this is a token stream, these are the tokens we are returning.
    const Token *Tokens;

public:
    // 从宏扩展的结果提取token
    TokenLexer(Token &Tok, ..., MacroInfo *MI, MacroArgs *ActualArgs, Preprocessor &pp) {
        Macro = MI;
        ActualArgs = Actuals;
        Tokens = &*Macro->tokens_begin();
    }

    // 直接从token流提取token
    TokenLexer(const Token *TokArray, unsigned NumToks, ..., Preprocessor &pp) {
        Macro = nullptr;
        ActualArgs = nullptr;
        Tokens = TokArray;
        NumTokens = NumToks;
        CurTokenIdx = 0;
    }

    /// Lex and return a token from this macro stream.
    bool Lex(Token &Tok);
}

/// Sema - This implements semantic analysis and AST building for C.
class Sema final {
public:
    Preprocessor &PP;

    // 用于语义分析的符号表
    ASTContext &Context;

    // AST的使用方
    ASTConsumer &Consumer;

    /// CurContext - This is the current declaration context of parsing.
    DeclContext *CurContext;

    void Initialize();

    // 管理作用域
    void PushFunctionScope();
    void PushBlockScope(Scope *BlockScope, BlockDecl *Block);
    void PushCompoundScope(bool IsStmtExpr);
    void PopCompoundScope();
    void ActOnPopScope(SourceLocation Loc, Scope *S);
    void ActOnTranslationUnitScope(Scope *S);

    void PushDeclContext(Scope *S, DeclContext *DC);
    void PopDeclContext();
    void EnterDeclaratorContext(Scope *S, DeclContext *DC);
    void ExitDeclaratorContext(Scope *S);

    // 维护自身状态
    void ActOnStartOfTranslationUnit();
    void ActOnEndOfTranslationUnit();
    void ActOnStartFunctionDeclarationDeclarator(Declarator &D, ...);
    void ActOnFinishFunctionDeclarationDeclarator(Declarator &D);
    void ActOnFinishInlineFunctionDef(FunctionDecl *D);
    void ActOnDefinedDeclarationSpecifier(Decl *D);
    void ActOnDefs(Scope *S, Decl *TagD, ...);
    void ActOnEnumBody(...);
    void ActOnStartOfCompoundStmt(bool IsStmtExpr);
    void ActOnFinishOfCompoundStmt();
    void ActOnForEachDeclStmt(DeclGroupPtrTy Decl);
    void ActOnCaseStmtBody(Stmt *CaseStmt, Stmt *SubStmt);

    // 生成ast
    Decl *ActOnFinishFunctionBody(Decl *Decl, Stmt *Body);
    Decl *ActOnFileScopeAsmDecl(Expr *expr, ...);
    Decl *ActOnTopLevelStmtDecl(Stmt *Statement);
    Decl *ActOnField(Scope *S, Decl *TagD, ...);
    Decl *ActOnEnumConstant(Scope *S, Decl *EnumDecl, Decl *LastEnumConstant, ...);

    TypeResult ActOnTypeName(Declarator &D);
    NamedDecl* ActOnFunctionDeclarator(Scope* S, Declarator& D, ...);

    StmtResult ActOnExprStmt(ExprResult Arg, bool DiscardedValue = true);
    StmtResult ActOnCompoundStmt(...);
    StmtResult ActOnDeclStmt(DeclGroupPtrTy Decl, ...);
    StmtResult ActOnForEachLValueExpr(Expr *E);
    StmtResult ActOnCaseStmt(ExprResult LHS, ...);
    StmtResult ActOnDefaultStmt(...);
    StmtResult ActOnLabelStmt(...);
    StmtResult ActOnIfStmt(...);
    StmtResult ActOnStartOfSwitchStmt(...);
    StmtResult ActOnFinishSwitchStmt(...);
    StmtResult ActOnWhileStmt(...);
    StmtResult ActOnDoStmt(...);
    StmtResult ActOnForStmt(...);
    StmtResult ActOnGotoStmt(...);
    StmtResult ActOnIndirectGotoStmt(...);
    StmtResult ActOnContinueStmt(...);
    StmtResult ActOnBreakStmt(...);
    StmtResult ActOnReturnStmt(...);
    StmtResult ActOnGCCAsmStmt(...);

    ExprResult ActOnPredefinedExpr(...);
    ExprResult ActOnIntegerConstant(...);
    ExprResult ActOnNumericConstant(...);
    ExprResult ActOnCharacterConstant(...);
    ExprResult ActOnParenExpr(...);
    ExprResult ActOnParenListExpr(...);
    ExprResult ActOnStringLiteral(...);
    ExprResult ActOnUnaryOp(...);
    ExprResult ActOnUnaryExprOrTypeTraitExpr(...);
    ExprResult ActOnPostfixUnaryOp(...);
    ExprResult ActOnArraySubscriptExpr(...);
    ExprResult ActOnMemberAccessExpr(...);
    ExprResult ActOnCallExpr(...);
    ExprResult ActOnCastExpr(...);
    ExprResult ActOnCaseExpr(..., ExprResult Val);
    ExprResult ActOnBinOp(...);
    ExprResult ActOnConditionalOp(...);
    ExprResult ActOnStmtExpr(...);
    ExprResult ActOnStmtExprResult(...);
}

```

从以上核心代码可以看出他们的职责和关系如下：
* `Parser`负责根据语法规则驱动解析的过程，从`Preprocessor`获取token，把语法单元传递给`Sema`
* `Lexer`负责解析单个源文件的`token`，`TokenLexer`负责处理`macro`扩展
* `Preprocessor`负责利用`Lexer`和`TokenLexer`处理`#include/#define`等预处理指令
* `Sema`负责对语法单元进行语义分析以及生成`AST`


## 词法分析




## 预处理



## 语法分析

此处只考虑`c11`的语法和语义

```c++

void Parser::Initialize() {
    // Sema的各种callback
    EnterScope(Scope::DeclScope);
    Actions.ActOnTranslationUnitScope(getCurScope());
    Actions.Initialize();

    // 通过preprocessor间接驱动lexer开始解析token
    ConsumeToken();
    {
        PP.Lex(Tok);
    }
}

/// Parse the first top-level declaration in a translation unit.
///
///       translation-unit:
///     [C]     external-declaration
///     [C]     translation-unit external-declaration
bool Parser::ParseFirstTopLevelDecl(DeclGroupPtrTy &Result, ...) {
    Actions.ActOnStartOfTranslationUnit();
    return ParseTopLevelDecl(Result, ...);
}

/// ParseTopLevelDecl - Parse one top-level declaration
/// top-level-declaration:
///   declaration
bool Parser::ParseTopLevelDecl(DeclGroupPtrTy &Result, ...) {
    Result = nullptr;
    // 第一个token在
    switch (Tok.getKind()) {
    case ...
    case tok::eof:
        Actions.ActOnEndOfTranslationUnit();
        return true;
    case tok::identifier:
        break;
    }

    // 解析__attribute((weak))等
    ParsedAttributes DeclSpecAttrs(AttrFactory);
    while (MaybeParseGNUAttributes(DeclSpecAttrs))
        ;

    // 解析外部声明
    Result = ParseExternalDeclaration(DeclAttrs, DeclSpecAttrs);
    return false;
}

/// external-declaration: [C99 6.9]
///   function-definition
///   declaration
Parser::DeclGroupPtrTy Parser::ParseExternalDeclaration(...) {
    Decl *SingleDecl = nullptr;
    switch (Tok.getKind()) {
    // 处理各种#pragma指令
    case tok::annot_pragma_xxx:
        HandlePragmaXxx();
        return nullptr;
    case tok::semi:
        // 单个分号生成空的decl
        SingleDecl = Actions.ActOnEmptyDeclaration(...);
        break;
    case tok::kw_asm: 
        // 解析嵌入式汇编
        ExprResult Result(ParseSimpleAsm(...));
        SingleDecl = Actions.ActOnFileScopeAsmDecl(Result.get(), ...);
        break;
    case tok::kw_typedef:
        return ParseDeclaration(...);
    case tok::kw_static:
        // 不确定static后面是函数定义还是声明语句
        goto dont_know;
    case tok::kw_inline:
        goto dont_know;
    case tok::kw_extern:
        goto dont_know;
    default:
    // 不确定是声明语句还是函数定义
    dont_know:
        if (!SingleDecl)
            return ParseDeclarationOrFunctionDefinition(...);  
    }

    return Actions.ConvertDeclToDeclGroup(SingleDecl);
}

/// Parse either a function-definition or a declaration.  
/// We can't tell which we have until we read up to the compound-statement in function-definition.
/// 
///       function-definition: [C99 6.9.1]
///         decl-specs      declarator declaration-list[opt] compound-statement
///
///       declaration: [C99 6.7]
///         declaration-specifiers init-declarator-list[opt] ';'
Parser::DeclGroupPtrTy Parser::ParseDeclarationOrFunctionDefinition(..., ParsingDeclSpec &DS, ...) {
    /// 解析类型以及修饰符，例如以下语句`[]`内的部分
    /// [extent const int] a;
    /// [static const struct X] x;
    /// [struct X {int a}] x;
    /// [inline const int] func();
    /// [inline const int] func() {}
    /// 
    /// ParseDeclarationSpecifiers
    ///       declaration-specifiers: [C99 6.7]
    ///         storage-class-specifier declaration-specifiers[opt]
    ///         type-specifier declaration-specifiers[opt]
    /// [C99]   function-specifier declaration-specifiers[opt]
    /// [C11]   alignment-specifier declaration-specifiers[opt]
    ParseDeclarationSpecifiers(DS, ...);

    return ParseDeclGroup(DS, DeclaratorContext::File, Attrs);
    {
        // 存储解析的declarator
        ParsingDeclarator D(*this, DS, LocalAttrs, Context);
        // 解析标识符和函数形参
        ParseDeclarator(D);

        // 函数类型
        if (D.isFunctionDeclarator()) {
            if (!(
                Tok.is(tok::equal) ||           // int X()=  -> not a function def
                Tok.is(tok::comma) ||           // int X(),  -> not a function def
                Tok.is(tok::semi)  ||           // int X();  -> not a function def
                Tok.is(tok::kw_asm) ||          // int X() __asm__ -> not a function def
                Tok.is(tok::kw___attribute)     // int X() __attr__ -> not a function def
            )) {
                if (Context == DeclaratorContext::File) {
                    // 下一个token是`{`
                    if (isStartOfFunctionDefinition(D)) {
                        // 解析函数定义
                        Decl *TheDecl = ParseFunctionDefinition(D, ...);
                        return Actions.ConvertDeclToDeclGroup(TheDecl);
                    }

                    Diag(Tok, diag::err_expected_fn_body);
                    SkipUntil(tok::semi);
                    return nullptr;
                } else {
                    // 非最外层不允许定义函数
                    if (Tok.is(tok::l_brace)) {
                        Diag(Tok, diag::err_function_definition_not_allowed);
                        SkipMalformedDecl();
                        return nullptr;
                    }
                }
            }
        }

        ParseAsmAttributesAfterDeclarator(D);

        SmallVector<Decl *, 8> DeclsInGroup;
        // 解析第一个声明: 函数声明或变量声明
        Decl *FirstDecl = ParseDeclarationAfterDeclaratorAndAttributes(D, ...);
        {
            // 由Sema生成Decl
            Decl *ThisDecl = Actions.ActOnDeclarator(getCurScope(), D);

            // 解析初始值
            if (Tok.getKind() == tok::equal) {
                ConsumeToken();
                ExprResult Init = ParseInitializer();
                Actions.AddInitializerToDecl(ThisDecl, Init.get(), /*DirectInit=*/false);
            }

            Actions.FinalizeDeclaration(ThisDecl);
        }
        DeclsInGroup.push_back(FirstDecl);

        // 遇到逗号解析更多的声明: int a = 1, b = 2;
        while (TryConsumeToken(tok::comma, ...)) {
            ParseDeclarator(D);
            Decl *ThisDecl = ParseDeclarationAfterDeclarator(D);
            {
                ParseAsmAttributesAfterDeclarator(D);
                return ParseDeclarationAfterDeclaratorAndAttributes(D, ...);
            }
            DeclsInGroup.push_back(ThisDecl);
        }

        // 应该分号结尾
        ExpectAndConsumeSemi(...);

        // 由Sema处理
        return Actions.FinalizeDeclaratorGroup(getCurScope(), DS, DeclsInGroup);
    }
}

/// ParseDeclarator - Parse and verify a newly-initialized declarator.
void Parser::ParseDeclarator(Declarator &D) {
    /// ParseDeclaratorInternal - Parse a C or C++ declarator.
    ///       declarator: [C99 6.7.5] [C++ 8p4, dcl.decl]
    /// [C]     pointer[opt] direct-declarator
    ///
    ///       pointer: [C99 6.7.5]
    ///         '*' type-qualifier-list[opt]
    ///         '*' type-qualifier-list[opt] pointer
    ParseDeclaratorInternal(D, &Parser::ParseDirectDeclarator);
    {
        tok::TokenKind Kind = Tok.getKind();
        // 非指针
        if (Kind != tok::star) {
            /// 解析标识符以及函数形参
            /// int a;
            /// int a = 1;
            /// int func(int a);
            /// 
            /// ParseDirectDeclarator
            ///       direct-declarator: [C99 6.7.5]
            /// [C99]   identifier
            ///         '(' declarator ')'
            /// [GNU]   '(' attributes declarator ')'
            /// [C90]   direct-declarator '[' constant-expression[opt] ']'
            /// [C99]   direct-declarator '[' type-qual-list[opt] assign-expr[opt] ']'
            /// [C99]   direct-declarator '[' 'static' type-qual-list[opt] assign-expr ']'
            /// [C99]   direct-declarator '[' type-qual-list 'static' assign-expr ']'
            /// [C99]   direct-declarator '[' type-qual-list[opt] '*' ']'
            ///         direct-declarator '(' parameter-type-list ')'
            ///         direct-declarator '(' identifier-list[opt] ')'
            (this->*DirectDeclParser)(D);
            {
                // 解析标识符
                if (Tok.is(tok::identifier) && D.mayHaveIdentifier()) {
                    D.SetIdentifier(Tok.getIdentifierInfo(), Tok.getLocation());
                    ConsumeToken();
                    goto PastIdentifier;
                }

            PastIdentifier:
                if (Tok.is(tok::l_paren)) {
                    // 检查小括号是否配对
                    BalancedDelimiterTracker T(*this, tok::l_paren);
                    T.consumeOpen();

                    // 解析形参
                    Actions.ActOnStartFunctionDeclarationDeclarator(D, ...);
                    ParseFunctionDeclarator(D, attrs, T, IsAmbiguous);
                    {
                        // 解析形参
                        // Build up an array of information about the parsed arguments.
                        SmallVector<DeclaratorChunk::ParamInfo, 16> ParamInfo;
                        if (Tok.isNot(tok::r_paren)) {
                            ///    parameter-type-list: [C99 6.7.5]
                            ///      parameter-list
                            ///      parameter-list ',' '...'
                            ///    parameter-list: [C99 6.7.5]
                            ///      parameter-declaration
                            ///      parameter-list ',' parameter-declaration
                            ///    parameter-declaration: [C99 6.7.5]
                            ///      declaration-specifiers declarator
                            ParseParameterDeclarationClause(D, ParamInfo, ...);
                        }
                            
                        // If we have the closing ')', eat it.
                        Tracker.consumeClose();

                        D.AddTypeInfo(DeclaratorChunk::getFunction(...));
                    }
                    Actions.ActOnFinishFunctionDeclarationDeclarator(D);
                } 
            }
            return;
        }

        ConsumeToken();  // Eat the *

        // 解析指针类型
        DeclSpec DS(AttrFactory);

        /// 解析指针之后的修饰符， 例如: `int * [const] a;`中的const
        /// ParseTypeQualifierListOpt
        ///          type-qualifier-list: [C99 6.7.5]
        ///            type-qualifier
        ParseTypeQualifierListOpt(DS, ...);

        // 递归处理剩余部分
        ParseDeclaratorInternal(D, DirectDeclParser);

        // Remember that we parsed a pointer type, and remember the type-quals.
        D.AddTypeInfo(DeclaratorChunk::getPointer(DS.getTypeQualifiers(), ...), ...);
    }
}

/// 解析函数体的组合语句
///       function-definition: [C99 6.9.1]
///         decl-specs      declarator declaration-list[opt] compound-statement
/// [C90] function-definition: [C99 6.7.1] - implicit int result
/// [C90]   decl-specs[opt] declarator declaration-list[opt] compound-statement
Decl *Parser::ParseFunctionDefinition(ParsingDeclarator &D, ...) {
    // If we didn't find the '{', bail out.
    if (Tok.isNot(tok::l_brace))
        return nullptr;

    ParseScope BodyScope(this, ...);

    // 由Sema生成函数定义
    Decl *Res = Actions.ActOnStartOfFunctionDef(getCurScope(), D, ...);
    return ParseFunctionStatementBody(Res, BodyScope);
    {
        StmtResult FnBody(ParseCompoundStatementBody());
        {
            BalancedDelimiterTracker T(*this, tok::l_brace);
            T.consumeOpen();

            // Parse any pragmas at the beginning of the compound statement.
            ParseCompoundStatementLeadingPragmas();
            Actions.ActOnAfterCompoundStatementLeadingPragmas();

            StmtVector Stmts;
            while (Tok.isNot(tok::r_brace) && Tok.isNot(tok::eof)) {
                StmtResult R = ParseStatementOrDeclaration(Stmts, SubStmtCtx);
                Stmts.push_back(R.get());
            }

            T.consumeClose()
            return Actions.ActOnCompoundStmt(Stmts, ...);
        }

        BodyScope.Exit();
        return Actions.ActOnFinishFunctionBody(Decl, FnBody.get());
    }
}

/// ParseStatementOrDeclaration - Read 'statement' or 'declaration'.
///       StatementOrDeclaration:
///         statement
///         declaration
///
///       statement:
///         labeled-statement
///         compound-statement
///         expression-statement
///         selection-statement
///         iteration-statement
///         jump-statement
/// [GNU]   asm-statement
///
///       labeled-statement:
///         identifier ':' statement
///         'case' constant-expression ':' statement
///         'default' ':' statement
///
///       selection-statement:
///         if-statement
///         switch-statement
///
///       iteration-statement:
///         while-statement
///         do-statement
///         for-statement
///
///       expression-statement:
///         expression[opt] ';'
///
///       jump-statement:
///         'goto' identifier ';'
///         'continue' ';'
///         'break' ';'
///         'return' expression[opt] ';'
/// [GNU]   'goto' '*' expression ';'
///
StmtResult Parser::ParseStatementOrDeclaration(StmtVector &Stmts, ...) {
    StmtResult Res = ParseStatementOrDeclarationAfterAttributes(Stmts, ...);
    return Actions.ActOnAttributedStmt(Attrs, Res.get());
}

StmtResult Parser::ParseStatementOrDeclarationAfterAttributes(StmtVector &Stmts, ...) {
    tok::TokenKind Kind  = Tok.getKind();
    switch (Kind) {
    case tok::identifier:
    ParseIdentifier: {
        Token Next = NextToken();
        if (Next.is(tok::colon)) {
            // 解析label: identifier ':' statement
            return ParseLabeledStatement(Attrs, StmtCtx);
        }

        // 非label那就是表达式语句
        // func(2);
        // a + b;
        [[fallthrough]];
    }
    default: 
        // 如果token是类型修饰符则是声明语句
        if (isDeclarationStatement()) {
            DeclGroupPtrTy Decl = ParseDeclaration(DeclaratorContext::Block, ...);
            {
                ///       simple-declaration: [C99 6.7: declaration] 
                ///         declaration-specifiers init-declarator-list[opt] ';'
                return ParseSimpleDeclaration(Context, ...);
                {
                    ParsingDeclSpec DS(*this);
                    ParseDeclarationSpecifiers(DS, ...);

                    // C99 6.7.2.3p6: Handle "struct-or-union identifier;", "enum { X };"
                    if (Tok.is(tok::semi)) {
                        // 记录定义的匿名的struct/union/enum
                        RecordDecl *AnonRecord = nullptr;
                        Decl *TheDecl = Actions.ParsedFreeStandingDeclSpec(..., AnonRecord);
                        
                        Actions.ActOnDefinedDeclarationSpecifier(TheDecl, ...);
                        
                        // struct { int a } x;
                        if (AnonRecord) {
                            Decl* decls[] = {AnonRecord, TheDecl};
                            return Actions.BuildDeclaratorGroup(decls);
                        }

                        // struct X x;
                        return Actions.ConvertDeclToDeclGroup(TheDecl);
                    }
                }
            }

            return Actions.ActOnDeclStmt(Decl, DeclStart, DeclEnd);
        }

        // eg: func(2);
        return ParseExprStatement(StmtCtx);
    case tok::kw_case:                // C99 6.8.1: labeled-statement
        return ParseCaseStatement(StmtCtx);
    case tok::kw_default:             // C99 6.8.1: labeled-statement
        return ParseDefaultStatement(StmtCtx);
    case tok::l_brace:                // C99 6.8.2: compound-statement
        return ParseCompoundStatement();
    case tok::semi:                   // C99 6.8.3p3: expression[opt] ';'
        return Actions.ActOnNullStmt(ConsumeToken(), ...); 
    case tok::kw_if:                  // C99 6.8.4.1: if-statement
    return ParseIfStatement(TrailingElseLoc);
    case tok::kw_switch:              // C99 6.8.4.2: switch-statement
        return ParseSwitchStatement(TrailingElseLoc);
    case tok::kw_while:               // C99 6.8.5.1: while-statement
        return ParseWhileStatement(TrailingElseLoc);
    case tok::kw_do:                  // C99 6.8.5.2: do-statement
        Res = ParseDoStatement();
        break;
    case tok::kw_for:                 // C99 6.8.5.3: for-statement
        return ParseForStatement(TrailingElseLoc);
    case tok::kw_goto:                // C99 6.8.6.1: goto-statement
        Res = ParseGotoStatement();
        break;
    case tok::kw_continue:            // C99 6.8.6.2: continue-statement
        Res = ParseContinueStatement();
        break;
    case tok::kw_break:               // C99 6.8.6.3: break-statement
        Res = ParseBreakStatement();
        break;
    case tok::kw_return:              // C99 6.8.6.4: return-statement
        Res = ParseReturnStatement();
        break;   
    case tok::kw_asm:                 // 嵌入式汇编
        Res = ParseAsmStatement(...);
        break;
    }

    ExpectAndConsume(tok::semi, ...);
    return Res;
}

// 以if为例分析语句解析过程
/// ParseIfStatement
///       if-statement: [C99 6.8.4.1]
///         'if' '(' expression ')' statement
///         'if' '(' expression ')' statement 'else' statement
StmtResult Parser::ParseIfStatement(...) {
    if (Tok.isNot(tok::l_paren)) {
        return StmtError();
    }

    ParseScope IfScope(this, ...);

    // Parse the condition.
    Sema::ConditionResult Cond;
    ParseParenExprOrCondition(..., Cond, ...);
    {
        BalancedDelimiterTracker T(*this, tok::l_paren);
        T.consumeOpen();

        ExprResult CondExpr = ParseExpression();
        Cond = Actions.ActOnCondition(...);

        T.consumeClose();
    }

    // 进入新的作用域解析then
    ParseScope InnerScope(this, ...);
    StmtResult ThenStmt = ParseStatement(...);
    InnerScope.Exit();

    StmtResult ElseStmt;
    if (Tok.is(tok::kw_else)) {
        ConsumeToken();

        ParseScope InnerScope(this, ...);
        ElseStmt = ParseStatement();
        InnerScope.Exit();
    }

    IfScope.Exit();

    return Actions.ActOnIfStmt(...);
}

/// 表达式按优先级从高到低排序
///       multiplicative-expression: [C99 6.5.5]
///     Note: in C++, apply pm-expression instead of cast-expression
///         cast-expression
///         multiplicative-expression '*' cast-expression
///         multiplicative-expression '/' cast-expression
///         multiplicative-expression '%' cast-expression
///
///       additive-expression: [C99 6.5.6]
///         multiplicative-expression
///         additive-expression '+' multiplicative-expression
///         additive-expression '-' multiplicative-expression
///
///       shift-expression: [C99 6.5.7]
///         additive-expression
///         shift-expression '<<' additive-expression
///         shift-expression '>>' additive-expression
///
///       compare-expression: [C++20 expr.spaceship]
///         shift-expression
///         compare-expression '<=>' shift-expression
///
///       relational-expression: [C99 6.5.8]
///         compare-expression
///         relational-expression '<' compare-expression
///         relational-expression '>' compare-expression
///         relational-expression '<=' compare-expression
///         relational-expression '>=' compare-expression
///
///       equality-expression: [C99 6.5.9]
///         relational-expression
///         equality-expression '==' relational-expression
///         equality-expression '!=' relational-expression
///
///       AND-expression: [C99 6.5.10]
///         equality-expression
///         AND-expression '&' equality-expression
///
///       exclusive-OR-expression: [C99 6.5.11]
///         AND-expression
///         exclusive-OR-expression '^' AND-expression
///
///       inclusive-OR-expression: [C99 6.5.12]
///         exclusive-OR-expression
///         inclusive-OR-expression '|' exclusive-OR-expression
///
///       logical-AND-expression: [C99 6.5.13]
///         inclusive-OR-expression
///         logical-AND-expression '&&' inclusive-OR-expression
///
///       logical-OR-expression: [C99 6.5.14]
///         logical-AND-expression
///         logical-OR-expression '||' logical-AND-expression
///
///       conditional-expression: [C99 6.5.15]
///         logical-OR-expression
///         logical-OR-expression '?' expression ':' conditional-expression
/// [GNU]   logical-OR-expression '?' ':' conditional-expression
///
///       assignment-expression: [C99 6.5.16]
///         conditional-expression
///         unary-expression assignment-operator assignment-expression
///
///       assignment-operator: one of
///         = *= /= %= += -= <<= >>= &= ^= |=
///
///       expression: [C99 6.5.17]
///         assignment-expression ...[opt]
///         expression ',' assignment-expression ...[opt]
ExprResult Parser::ParseExpression(...) {
    ExprResult LHS(ParseAssignmentExpression(isTypeCast));
    return ParseRHSOfBinaryExpression(LHS, prec::Comma);
}

StmtResult Parser::ParseStatement(...) {
    StmtResult Res;

    // We may get back a null statement if we found a #pragma. 
    // Keep going until we get an actual statement.
    StmtVector Stmts;
    do {
        Res = ParseStatementOrDeclaration(Stmts, ...);
    } while (!Res.isInvalid() && !Res.get());

    return Res;
}

```


## 语义分析

